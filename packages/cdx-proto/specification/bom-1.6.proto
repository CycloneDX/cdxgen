syntax = "proto3";
package cyclonedx.v1_6;
import "google/protobuf/timestamp.proto";

// Specifies attributes of the text
message AttachedText {
  // Specifies the content type of the text. Defaults to 'text/plain' if not specified.
  optional string content_type = 1;
  // Specifies the optional encoding the text is represented in
  optional string encoding = 2;
  // SimpleContent value of element. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text.
  string value = 3;
}

message Bom {
  // The version of the CycloneDX specification a BOM is written to (starting at version 1.3)
  string spec_version = 1;
  // The version allows component publishers/authors to make changes to existing BOMs to update various aspects of the document such as description or licenses. When a system is presented with multiple BOMs for the same component, the system should use the most recent version of the BOM. The default version is '1' and should be incremented for each version of the BOM that is published. Each version of a component should have a unique BOM and if no changes are made to the BOMs, then each BOM will have a version of '1'.
  optional int32 version = 2;
  // Every BOM generated should have a unique serial number, even if the contents of the BOM being generated have not changed over time. The process or tool responsible for creating the BOM should create random UUID's for every BOM generated.
  optional string serial_number = 3;
  // Provides additional information about a BOM.
  optional Metadata metadata = 4;
  // Provides the ability to document a list of components.
  repeated Component components = 5;
  // Provides the ability to document a list of external services.
  repeated Service services = 6;
  // Provides the ability to document external references related to the BOM or to the project the BOM describes.
  repeated ExternalReference external_references = 7;
  // Provides the ability to document dependency relationships.
  repeated Dependency dependencies = 8;
  // Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.
  repeated Composition compositions = 9;
  // Vulnerabilities identified in components or services.
  repeated Vulnerability vulnerabilities = 10;
  // Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinion or commentary from various stakeholders.
  repeated Annotation annotations = 11;
  // Specifies optional, custom, properties
  repeated Property properties = 12;
  // Describes how a component or service was manufactured or deployed. This is achieved through the use of formulas, workflows, tasks, and steps, which declare the precise steps to reproduce along with the observed formulas describing the steps which transpired in the manufacturing process.
  repeated Formula formulation = 13;
  // The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence.
  repeated Declarations declarations = 14;
  // A collection of reusable objects that are defined and may be used elsewhere in the BOM.
  repeated Definition definitions = 15;
}

enum Classification {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  CLASSIFICATION_NULL = 0;
  // A software application. Refer to https://en.wikipedia.org/wiki/Application_software for information about applications.
  CLASSIFICATION_APPLICATION = 1;
  // A software framework. Refer to https://en.wikipedia.org/wiki/Software_framework for information on how frameworks vary slightly from libraries.
  CLASSIFICATION_FRAMEWORK = 2;
  // A software library. Refer to https://en.wikipedia.org/wiki/Library_(computing) for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is recommended.
  CLASSIFICATION_LIBRARY = 3;
  // A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to https://en.wikipedia.org/wiki/Operating_system
  CLASSIFICATION_OPERATING_SYSTEM = 4;
  // A hardware device such as a processor, or chip-set. A hardware device containing firmware should include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device. See also the list of known device properties: https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md
  CLASSIFICATION_DEVICE = 5;
  // A computer file. Refer to https://en.wikipedia.org/wiki/Computer_file for information about files.
  CLASSIFICATION_FILE = 6;
  // A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to https://en.wikipedia.org/wiki/OS-level_virtualization
  CLASSIFICATION_CONTAINER = 7;
  // A special type of software that provides low-level control over a devices hardware. Refer to https://en.wikipedia.org/wiki/Firmware
  CLASSIFICATION_FIRMWARE = 8;
  // A special type of software that operates or controls a particular type of device. Refer to https://en.wikipedia.org/wiki/Device_driver
  CLASSIFICATION_DEVICE_DRIVER = 9;
  // A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms.
  CLASSIFICATION_PLATFORM = 10;
  // A model based on training data that can make predictions or decisions without being explicitly programmed to do so.
  CLASSIFICATION_MACHINE_LEARNING_MODEL = 11;
  // A collection of discrete values that convey information.
  CLASSIFICATION_DATA = 12;
  // A cryptographic asset including algorithms, protocols, certificates, keys, tokens, and secrets.
  CLASSIFICATION_CRYPTOGRAPHIC_ASSET = 13;
}

message Commit {
  // A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes.
  optional string uid = 1;
  // The URL to the commit. This URL will typically point to a commit in a version control system.
  optional string url = 2;
  // The author who created the changes in the commit
  optional IdentifiableAction author = 3;
  // The person who committed or pushed the commit
  optional IdentifiableAction committer = 4;
  // The text description of the contents of the commit
  optional string message = 5;
}

message Component {
  // Specifies the type of component. For software components, classify as an application if no more specific appropriate classification is available or cannot be determined for the component.
  Classification type = 1;
  // The optional mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented, such as an image, font, or executable. Some library or framework components may also have an associated mime-type.
  optional string mime_type = 2;
  // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 3;
  // The organization that supplied the component. The supplier may often be the manufacturer but may also be a distributor or repackager.
  optional OrganizationalEntity supplier = 4;
  // DEPRECATED - DO NOT USE - This will be removed in a future version - Use `.authors` or `.manufacturer` instead. The person(s) or organization(s) that authored the component
  optional string author = 5 [deprecated = true];
  // The person(s) or organization(s) that published the component
  optional string publisher = 6;
  // The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.
  optional string group = 7;
  // The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery
  string name = 8;
  // The component version. The version should ideally comply with semantic versioning but is not enforced. Version was made optional in v1.4 of the spec. For backward compatibility, it is RECOMMENDED to use an empty string to represent components without version information.
  string version = 9;
  // Specifies a description for the component
  optional string description = 10;
  // Specifies the scope of the component. If a scope is not specified, SCOPE_REQUIRED scope should be assumed by the consumer of the BOM
  optional Scope scope = 11;
  repeated Hash hashes = 12;
  repeated LicenseChoice licenses = 13;
  // An optional copyright notice informing users of the underlying claims to copyright ownership in a published work.
  optional string copyright = 14;
  // DEPRECATED - DO NOT USE. This will be removed in a future version. Specifies a well-formed CPE name. See https://nvd.nist.gov/products/cpe
  optional string cpe = 15;
  // Specifies the package-url (PURL). The purl, if specified, must be valid and conform to the specification defined at: https://github.com/package-url/purl-spec
  optional string purl = 16;
  // Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags.
  optional Swid swid = 17;
  // DEPRECATED - DO NOT USE. This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified. A boolean value indicating is the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original.
  optional bool modified = 18;
  // Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc.
  optional Pedigree pedigree = 19;
  // Provides the ability to document external references related to the component or to the project the component describes.
  repeated ExternalReference external_references = 20;
  // Specifies optional sub-components. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system -> subsystem -> parts assembly in physical supply chains.
  repeated Component components = 21;
  // Specifies optional, custom, properties
  repeated Property properties = 22;
  // Specifies optional license and copyright evidence
  optional Evidence evidence = 23;
  // Specifies optional release notes.
  optional ReleaseNotes releaseNotes = 24;
  // A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency.
  optional ModelCard modelCard = 25;
  // This object SHOULD be specified for any component of type `data` and MUST NOT be specified for other component types.
  optional ComponentData data = 26;
  // Cryptographic assets have properties that uniquely define them and that make them actionable for further reasoning. As an example, it makes a difference if one knows the algorithm family (e.g. AES) or the specific variant or instantiation (e.g. AES-128-GCM). This is because the security level and the algorithm primitive (authenticated encryption) is only defined by the definition of the algorithm variant. The presence of a weak cryptographic algorithm like SHA1 vs. HMAC-SHA1 also makes a difference.
  optional CryptoProperties cryptoProperties = 27;
  // The organization that created the component. Manufacturer is common in components created through automated processes. Components created through manual means may have `.authors` instead.
  optional OrganizationalEntity manufacturer = 28;
  // The person(s) who created the component. Authors are common in components created through manual processes. Components created through automated means may have `.manufacturer` instead.
  repeated OrganizationalContact authors = 29;
  // Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
  repeated string tags = 30;
  // Specifies the OmniBOR Artifact ID. The OmniBOR, if specified, MUST be valid and conform to the specification defined at: https://www.iana.org/assignments/uri-schemes/prov/gitoid
  repeated string omniborId = 31;
  // Specifies the Software Heritage persistent identifier (SWHID). The SWHID, if specified, MUST be valid and conform to the specification defined at: https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html
  repeated string swhid = 32;
}

// Specifies the data flow.
message DataFlow {
  // Specifies the flow direction of the data.
  DataFlowDirection flow = 1;
  // Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
  string value = 2;
  // Name for the defined data
  optional string name = 3;
  // Short description of the data content and usage
  optional string description = 4;
  // The URI, URL, or BOM-Link of the components or services the data came in from
  repeated string source = 5;
  // The URI, URL, or BOM-Link of the components or services the data is sent to
  repeated string destination = 6;
  // Data Governance
  optional DataGovernance governance = 7;
}

// Specifies the flow direction of the data. Valid values are: inbound, outbound, bi-directional, and unknown. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways, and unknown states that the direction is not known.
// buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "DATA_FLOW_DIRECTION_"
enum DataFlowDirection {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  DATA_FLOW_NULL = 0;
  DATA_FLOW_INBOUND = 1;
  DATA_FLOW_OUTBOUND = 2;
  DATA_FLOW_BI_DIRECTIONAL = 3;
  DATA_FLOW_UNKNOWN = 4;
}

message Dependency {
  // References a component or service by its bom-ref attribute
  string ref = 1;
  // The bom-ref identifiers of the components or services that are dependencies of this dependency object.
  repeated Dependency dependencies = 2;
  // The bom-ref identifiers of the components or services that define a given specification or standard, which are provided or implemented by this dependency object.
  repeated string provides = 3;
}

message Diff {
  // Specifies the optional text of the diff
  optional AttachedText text = 1;
  // Specifies the URL to the diff
  optional string url = 2;
}

message ExternalReference {
  // Specifies the type of external reference. There are built-in types to describe common references. If a type does not exist for the reference being referred to, use the "other" type.
  ExternalReferenceType type = 1;
  // The URL to the external reference
  string url = 2;
  // An optional comment describing the external reference
  optional string comment = 3;
  // Optional integrity hashes for the external resource content
  repeated Hash hashes = 4;
}

enum ExternalReferenceType {
  // Use this if no other types accurately describe the purpose of the external reference
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `other` is our fallback, doubling `unspecified`
  EXTERNAL_REFERENCE_TYPE_OTHER = 0;
  // Version Control System
  EXTERNAL_REFERENCE_TYPE_VCS = 1;
  // Issue, defect tracking system, or an Application Lifecycle Management (ALM) system
  EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER = 2;
  // Website
  EXTERNAL_REFERENCE_TYPE_WEBSITE = 3;
  // Security advisories
  EXTERNAL_REFERENCE_TYPE_ADVISORIES = 4;
  // Bill-of-material document (CycloneDX, SPDX, SWID, etc)
  EXTERNAL_REFERENCE_TYPE_BOM = 5;
  // Mailing list or discussion group
  EXTERNAL_REFERENCE_TYPE_MAILING_LIST = 6;
  // Social media account
  EXTERNAL_REFERENCE_TYPE_SOCIAL = 7;
  // Real-time chat platform
  EXTERNAL_REFERENCE_TYPE_CHAT = 8;
  // Documentation, guides, or how-to instructions
  EXTERNAL_REFERENCE_TYPE_DOCUMENTATION = 9;
  // Community or commercial support
  EXTERNAL_REFERENCE_TYPE_SUPPORT = 10;
  // Direct or repository download location
  EXTERNAL_REFERENCE_TYPE_DISTRIBUTION = 11;
  // The URL to the license file. If a license URL has been defined in the license node, it should also be defined as an external reference for completeness
  EXTERNAL_REFERENCE_TYPE_LICENSE = 12;
  // Build-system specific meta file (i.e. pom.xml, package.json, .nuspec, etc)
  EXTERNAL_REFERENCE_TYPE_BUILD_META = 13;
  // URL to an automated build system
  EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM = 14;
  // Specifies a way to contact the maintainer, supplier, or provider in the event of a security incident. Common URIs include links to a disclosure procedure, a mailto (RFC-2368) that specifies an email address, a tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies the records containing DNS Security TXT.
  EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT = 15;
  // Human or machine-readable statements containing facts, evidence, or testimony
  EXTERNAL_REFERENCE_TYPE_ATTESTATION = 16;
  // An enumeration of identified weaknesses, threats, and countermeasures, dataflow diagram (DFD), attack tree, and other supporting documentation in human-readable or machine-readable format
  EXTERNAL_REFERENCE_TYPE_THREAT_MODEL = 17;
  // The defined assumptions, goals, and capabilities of an adversary.
  EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL = 18;
  // Identifies and analyzes the potential of future events that may negatively impact individuals, assets, and/or the environment. Risk assessments may also include judgments on the tolerability of each risk.
  EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT = 19;
  // The location where a component was published. This is often the same as "distribution" but may also include specialized publishing processes that act as an intermediary
  EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE = 20;
  // A Vulnerability Disclosure Report (VDR) which asserts the known and previously unknown vulnerabilities that affect a component, service, or product including the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on a component, service, or product
  EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION = 21;
  // A Vulnerability Exploitability eXchange (VEX) asserts the known vulnerabilities that do not affect a product, product family, or organization, and optionally, the ones that do. The VEX should include the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on the product, product family, or organization
  EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT = 22;
  // Results from an authorized simulated cyberattack on a component or service, otherwise known as a penetration test
  EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT = 23;
  // SARIF or proprietary machine or human-readable report for which static analysis has identified code quality, security, and other potential issues with the source code
  EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT = 24;
  // Dynamic analysis report that has identified issues such as vulnerabilities and misconfigurations
  EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT = 25;
  // Report generated by analyzing the call stack of a running application
  EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT = 26;
  // Report generated by Software Composition Analysis (SCA), container analysis, or other forms of component analysis
  EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT = 27;
  // Report containing a formal assessment of an organization, business unit, or team against a maturity model
  EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT = 28;
  // Industry, regulatory, or other certification from an accredited (if applicable) certification body
  EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT = 29;
  // Report or system in which quality metrics can be obtained
  EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS = 30;
  // Code or configuration that defines and provisions virtualized infrastructure, commonly referred to as Infrastructure as Code (IaC)
  EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE = 31;
  // A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency.
  EXTERNAL_REFERENCE_TYPE_MODEL_CARD = 32;
    // Plans of Action and Milestones (POAM) complement an "attestation" external reference. POAM is defined by NIST as a "document that identifies tasks needing to be accomplished. It details resources required to accomplish the elements of the plan, any milestones in meeting the tasks and scheduled completion dates for the milestones".
  EXTERNAL_REFERENCE_TYPE_POAM = 33;
  // A record of events that occurred in a computer system or application, such as problems, errors, or information on current operations.
  EXTERNAL_REFERENCE_TYPE_LOG = 34;
  // Parameters or settings that may be used by other components or services.
  EXTERNAL_REFERENCE_TYPE_CONFIGURATION = 35;
  // Information used to substantiate a claim.
  EXTERNAL_REFERENCE_TYPE_EVIDENCE = 36;
  // Describes how a component or service was manufactured or deployed.
  EXTERNAL_REFERENCE_TYPE_FORMULATION = 37;
  // The location where the source code distributable can be obtained. This is often an archive format such as zip or tar.gz. The source-distribution type complements the use of the version control (vcs) type.
  EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION = 38;
  // An e-signature is commonly a scanned representation of a written signature or a stylized script of the person's name.
  EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE = 39;
  // A signature that leverages cryptography, typically public/private key pairs, which provides strong authenticity verification.
  EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE = 40;
  // Document that complies with RFC-9116 (A File Format to Aid in Security Vulnerability Disclosure)
  EXTERNAL_REFERENCE_TYPE_RFC_9116 = 41;
}

enum HashAlg {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  HASH_ALG_NULL = 0;
  HASH_ALG_MD_5 = 1;
  HASH_ALG_SHA_1 = 2;
  HASH_ALG_SHA_256 = 3;
  HASH_ALG_SHA_384 = 4;
  HASH_ALG_SHA_512 = 5;
  HASH_ALG_SHA_3_256 = 6;
  HASH_ALG_SHA_3_384 = 7;
  HASH_ALG_SHA_3_512 = 8;
  HASH_ALG_BLAKE_2_B_256 = 9;
  HASH_ALG_BLAKE_2_B_384 = 10;
  HASH_ALG_BLAKE_2_B_512 = 11;
  HASH_ALG_BLAKE_3 = 12;
}

// Specifies the file hash of the component
message Hash {
  // Specifies the algorithm used to create the hash
  HashAlg alg = 1;
  // SimpleContent value of element
  string value = 2;
}

message IdentifiableAction {
  // The timestamp in which the action occurred
  optional google.protobuf.Timestamp timestamp = 1;
  // The name of the individual who performed the action
  optional string name = 2;
  // The email address of the individual who performed the action
  optional string email = 3;
}

enum IssueClassification {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  ISSUE_CLASSIFICATION_NULL = 0;
  // A fault, flaw, or bug in software
  ISSUE_CLASSIFICATION_DEFECT = 1;
  // A new feature or behavior in software
  ISSUE_CLASSIFICATION_ENHANCEMENT = 2;
  // A special type of defect which impacts security
  ISSUE_CLASSIFICATION_SECURITY = 3;
}

message Issue {
  // Specifies the type of issue
  IssueClassification type = 1;
  // The identifier of the issue assigned by the source of the issue
  optional string id = 2;
  // The name of the issue
  optional string name = 3;
  // A description of the issue
  optional string description = 4;
  optional Source source = 5;
  repeated string references = 6;
}

// The source of the issue where it is documented.
message Source {
  // The name of the source. For example, "National Vulnerability Database", "NVD", and "Apache"
  optional string name = 1;
  // The url of the issue documentation as provided by the source
  optional string url = 2;
}

message LicenseChoice {
  oneof choice {
    License license = 1;
    // A valid SPDX license expression. Refer to https://spdx.org/specifications for syntax requirements
    string expression = 2;
  }
  // This field must only be used when "expression" is chosen as the License object has its own acknowledgement.
  optional LicenseAcknowledgementEnumeration acknowledgement = 3;
}

message License {
  oneof license {
    // A valid SPDX license ID
    string id = 1;
    // If SPDX does not define the license used, this field may be used to provide the license name
    string name = 2;
  }
  // Specifies the optional full text of the attachment
  optional AttachedText text = 3;
  // The URL to the attachment file. If the attachment is a license or BOM, an externalReference should also be specified for completeness.
  optional string url = 4;
  // An optional identifier which can be used to reference the license elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 5;
  // Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata
  optional Licensing licensing = 6;
  // Specifies optional, custom, properties
  repeated Property properties = 7;
  // Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license.
  optional LicenseAcknowledgementEnumeration acknowledgement = 8;
}

// Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license.
enum LicenseAcknowledgementEnumeration {
  // The license acknowledgement is not specified.
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED = 0;
  // Declared licenses represent the initial intentions of authors regarding the licensing terms of their code.
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED = 1;
  // Concluded licenses are verified and confirmed.
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED = 2;
}

message Licensing {
  // License identifiers that may be used to manage licenses and their lifecycle
  repeated string altIds = 1;
  // The individual or organization that grants a license to another individual or organization
  optional OrganizationalEntityOrContact licensor = 2;
  // The individual or organization for which a license was granted to
  optional OrganizationalEntityOrContact licensee = 3;
  // The individual or organization that purchased the license
  optional OrganizationalEntityOrContact purchaser = 4;
  // The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase
  optional string purchaseOrder = 5;
  // The type of license(s) that was granted to the licensee
  repeated LicensingTypeEnum licenseTypes = 6;
  // The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed.
  optional google.protobuf.Timestamp lastRenewal = 7;
  // The timestamp indicating when the current license expires (if applicable).
  optional google.protobuf.Timestamp expiration = 8;
}

message OrganizationalEntityOrContact {
  oneof choice {
    OrganizationalEntity organization = 1;
    OrganizationalContact individual = 2;
  }
}

// buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "LICENSING_TYPE_ENUM_"
enum LicensingTypeEnum {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  LICENSING_TYPE_NULL = 0;
  // A license that grants use of software solely for the purpose of education or research.
  LICENSING_TYPE_ACADEMIC = 1;
  // A license covering use of software embedded in a specific piece of hardware.
  LICENSING_TYPE_APPLIANCE = 2;
  // A Client Access License (CAL) allows client computers to access services provided by server software.
  LICENSING_TYPE_CLIENT_ACCESS = 3;
  // A Concurrent User license (aka floating license) limits the number of licenses for a software application and licenses are shared among a larger number of users.
  LICENSING_TYPE_CONCURRENT_USER = 4;
  // A license where the core of a computer's processor is assigned a specific number of points.
  LICENSING_TYPE_CORE_POINTS = 5;
  // A license for which consumption is measured by non-standard metrics.
  LICENSING_TYPE_CUSTOM_METRIC = 6;
  // A license that covers a defined number of installations on computers and other types of devices.
  LICENSING_TYPE_DEVICE = 7;
  // A license that grants permission to install and use software for trial purposes.
  LICENSING_TYPE_EVALUATION = 8;
  // A license that grants access to the software to one or more pre-defined users.
  LICENSING_TYPE_NAMED_USER = 9;
  // A license that grants access to the software on one or more pre-defined computers or devices.
  LICENSING_TYPE_NODE_LOCKED = 10;
  // An Original Equipment Manufacturer license that is delivered with hardware, cannot be transferred to other hardware, and is valid for the life of the hardware.
  LICENSING_TYPE_OEM = 11;
  // A license where the software is sold on a one-time basis and the licensee can use a copy of the software indefinitely.
  LICENSING_TYPE_PERPETUAL = 12;
  // A license where each installation consumes points per processor.
  LICENSING_TYPE_PROCESSOR_POINTS = 13;
  // A license where the licensee pays a fee to use the software or service.
  LICENSING_TYPE_SUBSCRIPTION = 14;
  // A license that grants access to the software or service by a specified number of users.
  LICENSING_TYPE_USER = 15;
  // Another license type.
  LICENSING_TYPE_OTHER = 16;
}

message Metadata {
  // The date and time (timestamp) when the document was created.
  optional google.protobuf.Timestamp timestamp = 1;
  // The tool(s) used in the creation of the BOM.
  optional Tool tools = 2;
  // The person(s) who created the BOM. Authors are common in BOMs created through manual processes. BOMs created through automated means may have '.manufacturer' instead.
  repeated OrganizationalContact authors = 3;
  // The component that the BOM describes.
  optional Component component = 4;
  // DEPRECATED - DO NOT USE - This will be removed in a future version - Use the `.component.manufacturer` instead. The organization that manufactured the component that the BOM describes.
  optional OrganizationalEntity manufacture = 5 [deprecated = true];
  // The organization that supplied the component that the BOM describes. The supplier may often be the manufacture, but may also be a distributor or repackager.
  optional OrganizationalEntity supplier = 6;
  // The license information for the BOM document. This may be different from the license(s) of the component(s) that the BOM describes.
  repeated LicenseChoice licenses = 7;
  // Specifies optional, custom, properties
  repeated Property properties = 8;
  // Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types of data may be available at various phases of a lifecycle, such as the Software Development Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a BOM may include data specific to or only obtainable in a given lifecycle.
  repeated Lifecycles lifecycles = 9;
  // The organization that created the BOM. Manufacturer is common in BOMs created through automated processes. BOMs created through manual means may have '.authors' instead.
  optional OrganizationalEntity manufacturer = 10;
}

message Lifecycles {
   oneof choice {
     // A pre-defined phase in the product lifecycle.
     LifecyclePhase phase = 1;
     // The name of the lifecycle phase
     string name = 2;
   }
   // The description of the lifecycle phase
  optional string description = 3;
}

enum LifecyclePhase {
  // BOM produced early in the development lifecycle containing an inventory of components and services that are proposed or planned to be used. The inventory may need to be procured, retrieved, or resourced prior to use.
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
  LIFECYCLE_PHASE_DESIGN = 0;
  // BOM consists of information obtained prior to a build process and may contain source files, development artifacts, and manifests. The inventory may need to be resolved and retrieved prior to use.
  LIFECYCLE_PHASE_PRE_BUILD = 1;
  // BOM consisting of information obtained during a build process where component inventory is available for use. The precise versions of resolved components are usually available at this time as well as the provenance of where the components were retrieved from.
  LIFECYCLE_PHASE_BUILD = 2;
  // BOM consisting of information obtained after a build process has completed and the resulting components(s) are available for further analysis. Built components may exist as the result of a CI/CD process, may have been installed or deployed to a system or device, and may need to be retrieved or extracted from the system or device.
  LIFECYCLE_PHASE_POST_BUILD = 3;
  // BOM produced that represents inventory that is running and operational. This may include staging or production environments and will generally encompass multiple SBOMs describing the applications and operating system, along with HBOMs describing the hardware that makes up the system. Operations Bill of Materials (OBOM) can provide full-stack inventory of runtime environments, configurations, and additional dependencies.
  LIFECYCLE_PHASE_OPERATIONS = 4;
  // BOM consisting of information observed through network discovery providing point-in-time enumeration of embedded, on-premise, and cloud-native services such as server applications, connected devices, microservices, and serverless functions.
  LIFECYCLE_PHASE_DISCOVERY = 5;
  // BOM containing inventory that will be, or has been retired from operations.
  LIFECYCLE_PHASE_DECOMMISSION = 6;
}

message OrganizationalContact {
  // The name of the contact
  optional string name = 1;
  // The email address of the contact.
  optional string email = 2;
  // The phone number of the contact.
  optional string phone = 3;
  // An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 4;
}

message OrganizationalEntity {
  // The name of the organization
  optional string name = 1;
  // The URL of the organization. Multiple URLs are allowed.
  repeated string url = 2;
  // A contact person at the organization. Multiple contacts are allowed.
  repeated OrganizationalContact contact = 3;
  // An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 4;
  // The physical address (location) of the organization
  optional PostalAddressType address = 5;
}

enum PatchClassification {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  PATCH_CLASSIFICATION_NULL = 0;
  // A patch which is not developed by the creators or maintainers of the software being patched. Refer to https://en.wikipedia.org/wiki/Unofficial_patch
  PATCH_CLASSIFICATION_UNOFFICIAL = 1;
  // A patch which dynamically modifies runtime behavior. Refer to https://en.wikipedia.org/wiki/Monkey_patch
  PATCH_CLASSIFICATION_MONKEY = 2;
  // A patch which takes code from a newer version of software and applies it to older versions of the same software. Refer to https://en.wikipedia.org/wiki/Backporting
  PATCH_CLASSIFICATION_BACKPORT = 3;
  // A patch created by selectively applying commits from other versions or branches of the same software.
  PATCH_CLASSIFICATION_CHERRY_PICK = 4;
}

message Patch {
  // Specifies the purpose for the patch, including the resolution of defects, security issues, or new behavior or functionality
  PatchClassification type = 1;
  // The patch file (or diff) that show changes. Refer to https://en.wikipedia.org/wiki/Diff
  optional Diff diff = 2;
  repeated Issue resolves = 3;
}

// Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known.
message Pedigree {
  // Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains an ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from.
  repeated Component ancestors = 1;
  // Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component.
  repeated Component descendants = 2;
  // Variants describe relations where the relationship between the components is not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other or if they share a common ancestor.
  repeated Component variants = 3;
  // A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant.
  repeated Commit commits = 4;
  // A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complementary to commits or may be used in place of commits.
  repeated Patch patches = 5;
  // Notes, observations, and other non-structured commentary describing the component's pedigree.
  optional string notes = 6;
}

enum Scope {
  // Default
  SCOPE_UNSPECIFIED = 0;
  // The component is required for runtime
  SCOPE_REQUIRED = 1;
  // The component is optional at runtime. Optional components are components that are not capable of being called due to them not being installed or otherwise accessible by any means. Components that are installed but, due to configuration or other restrictions, are prohibited from being called must be scoped as 'required'.
  SCOPE_OPTIONAL = 2;
  // Components that are excluded provide the ability to document component usage for test and other non-runtime purposes. Excluded components are not reachable within a call graph at runtime.
  SCOPE_EXCLUDED = 3;
}

message Service {
  // An optional identifier which can be used to reference the service elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 1;
  // The organization that provides the service.
  optional OrganizationalEntity provider = 2;
  // The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided.
  optional string group = 3;
  // The name of the service. This will often be a shortened, single name of the service.
  string name = 4;
  // The service version.
  optional string version = 5;
  // Specifies a description for the service.
  optional string description = 6;
  repeated string endpoints = 7;
  // A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication.
  optional bool authenticated = 8;
  // A boolean value indicating if the use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed.
  optional bool x_trust_boundary = 9;
  repeated DataFlow data = 10;
  repeated LicenseChoice licenses = 11;
  // Provides the ability to document external references related to the service.
  repeated ExternalReference external_references = 12;
  // Specifies optional sub-service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies, similar to system -> subsystem -> parts assembly in physical supply chains.
  repeated Service services = 13;
  // Specifies optional, custom, properties
  repeated Property properties = 14;
  // Specifies optional release notes.
  optional ReleaseNotes releaseNotes = 15;
  // The name of the trust zone the service resides in.
  optional string trustZone = 16;
  // Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
  repeated string tags = 17;
}

message Swid {
  // Maps to the tagId of a SoftwareIdentity.
  string tag_id = 1;
  // Maps to the name of a SoftwareIdentity.
  string name = 2;
  // Maps to the version of a SoftwareIdentity. Defaults to '0.0' if not specified.
  optional string version = 3;
  // Maps to the tagVersion of a SoftwareIdentity. Defaults to '0' if not specified.
  optional int32 tag_version = 4;
  // Maps to the patch of a SoftwareIdentity. Defaults to 'false' if not specified.
  optional bool patch = 5;
  // Specifies the full content of the SWID tag.
  optional AttachedText text = 6;
  // The URL to the SWID file.
  optional string url = 7;
}

// Specifies a tool (manual or automated).
message Tool {
  // DEPRECATED - DO NOT USE - The vendor of the tool used to create the BOM.
  optional string vendor = 1 [deprecated = true];
  // DEPRECATED - DO NOT USE - The name of the tool used to create the BOM.
  optional string name = 2 [deprecated = true];
  // DEPRECATED - DO NOT USE - The version of the tool used to create the BOM.
  optional string version = 3 [deprecated = true];
  // DEPRECATED - DO NOT USE
  repeated Hash hashes = 4 [deprecated = true];
  // DEPRECATED - DO NOT USE - Provides the ability to document external references related to the tool.
  repeated ExternalReference external_references = 5 [deprecated = true];
  // A list of software and hardware components used as tools
  repeated Component components = 6;
  // A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services.
  repeated Service services = 7;
}

// Specifies a property
message Property {
  string name = 1;
  optional string value = 2;
}

enum Aggregate {
  // The relationship completeness is not specified.
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `not specified` is our fallback, doubling `unspecified`
  AGGREGATE_NOT_SPECIFIED = 0;
  // The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist.
  AGGREGATE_COMPLETE = 1;
  // The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies.
  AGGREGATE_INCOMPLETE = 2;
  // The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented.
  AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY = 3;
  // The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented.
  AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY = 4;
  // The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive.
  AGGREGATE_UNKNOWN = 5;
  // The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
  AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY = 6;
  // The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
  AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY = 7;
  // The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
  AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY = 8;
  // The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
  AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY = 9;
}

message Composition {
  // Indicates the aggregate completeness
  Aggregate aggregate = 1;
  // The assemblies the aggregate completeness applies to
  repeated string assemblies = 2;
  // The dependencies the aggregate completeness applies to
  repeated string dependencies = 3;
  // The bom-ref identifiers of the vulnerabilities being described.
  repeated string vulnerabilities = 4;
  // An optional identifier which can be used to reference the composition elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 5;
}

message EvidenceCopyright {
  // Copyright text
  string text = 1;
}

message Evidence {
  repeated LicenseChoice licenses = 1;
  repeated EvidenceCopyright copyright = 2;
  repeated EvidenceIdentity identity = 3;
  repeated EvidenceOccurrences occurrences = 4;
  optional Callstack callstack = 5;
}

// Evidence of the components use through the callstack.
message Callstack {
  repeated Frames frames = 1;

  message Frames {
    // A package organizes modules into namespaces, providing a unique namespace for each type it contains.
    optional string package = 1;
    // A module or class that encloses functions/methods and other code.
    string module = 2;
    // A block of code designed to perform a particular task.
    optional string function = 3;
    // Optional arguments that are passed to the module or function.
    repeated string parameters = 4;
    // The line number the code that is called resides on.
    optional int32 line = 5;
    // The column the code that is called resides.
    optional int32 column = 6;
    // The full path and filename of the module.
    optional string fullFilename = 7;
  }
}

message EvidenceIdentity {
  // The identity field of the component which the evidence describes.
  EvidenceFieldType field = 1;
  // The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence.
  optional float confidence = 2;
  // The methods used to extract and/or analyze the evidence.
  repeated EvidenceMethods methods = 3;
  // The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation.
  repeated string tools = 4;
  // The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of all methods (if available).
  optional string concludedValue = 5;
}

message EvidenceMethods {
  // The technique used in this method of analysis.
  EvidenceTechnique technique = 1;
  // The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence.
  float confidence = 2;
  // The value or contents of the evidence.
  optional string value = 3;
}

message EvidenceOccurrences {
  // An optional identifier which can be used to reference the occurrence elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 1;
  // The location or path to where the component was found.
  string location = 2;
  // The line number where the component was found.
  optional int32 line = 3;
  // The offset where the component was found.
  optional int32 offset = 4;
  // The symbol name that was found associated with the component.
  optional string symbol = 5;
  // Any additional context of the detected component (e.g. a code snippet).
  optional string additionalContext = 6;
}

// buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "EVIDENCE_FIELD_TYPE_"
enum EvidenceFieldType {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  EVIDENCE_FIELD_NULL = 0;
  EVIDENCE_FIELD_GROUP = 1;
  EVIDENCE_FIELD_NAME = 2;
  EVIDENCE_FIELD_VERSION = 3;
  EVIDENCE_FIELD_PURL = 4;
  EVIDENCE_FIELD_CPE = 5;
  EVIDENCE_FIELD_SWID = 6;
  EVIDENCE_FIELD_HASH = 7;
  EVIDENCE_FIELD_OMNIBOR_ID = 8;
  EVIDENCE_FIELD_SWHID = 9;
}

enum EvidenceTechnique {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
  EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS = 0;
  EVIDENCE_TECHNIQUE_BINARY_ANALYSIS = 1;
  EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS = 2;
  EVIDENCE_TECHNIQUE_AST_FINGERPRINT = 3;
  EVIDENCE_TECHNIQUE_HASH_COMPARISON = 4;
  EVIDENCE_TECHNIQUE_INSTRUMENTATION = 5;
  EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS = 6;
  EVIDENCE_TECHNIQUE_FILENAME = 7;
  EVIDENCE_TECHNIQUE_ATTESTATION = 8;
  EVIDENCE_TECHNIQUE_OTHER = 9;
}

message Note {
  // The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA".
  optional string locale = 1;
  // Specifies the full content of the release note.
  optional AttachedText text = 2;
}

message ReleaseNotes {
  // The software versioning type. It is RECOMMENDED that the release type use one of 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release types is not practical, so standardizing on the recommended values, whenever possible, is strongly encouraged.
  string type = 1;
  // The title of the release.
  optional string title = 2;
  // The URL to an image that may be prominently displayed with the release note.
  optional string featuredImage = 3;
  // The URL to an image that may be used in messaging on social media platforms.
  optional string socialImage = 4;
  // A short description of the release.
  optional string description = 5;
  // The date and time (timestamp) when the release note was created.
  optional google.protobuf.Timestamp timestamp = 6;
  // Optional alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names).
  repeated string aliases = 7;
  // Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection".
  repeated string tags = 8;
  // A collection of issues that have been resolved.
  repeated Issue resolves = 9;
  // Zero or more release notes containing the locale and content. Multiple note messages may be specified to support release notes in a wide variety of languages.
  repeated Note notes = 10;
  // Specifies optional, custom, properties
  repeated Property properties = 11;
}

message Vulnerability {
  // An optional identifier which can be used to reference the vulnerability elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
  optional string bom_ref = 1;
  // The identifier that uniquely identifies the vulnerability.
  optional string id = 2;
  // The source that published the vulnerability.
  optional Source source = 3;
  // Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Oftentimes, the same vulnerability may exist in multiple sources of vulnerability intelligence but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence.
  repeated VulnerabilityReference references = 4;
  // List of vulnerability ratings
  repeated VulnerabilityRating ratings = 5;
  // List of Common Weaknesses Enumerations (CWEs) codes that describe this vulnerability. For example, 399 (of https://cwe.mitre.org/data/definitions/399.html)
  repeated int32 cwes = 6;
  // A description of the vulnerability as provided by the source.
  optional string description = 7;
  // If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding the root cause.
  optional string detail = 8;
  // Recommendations of how the vulnerability can be remediated or mitigated.
  optional string recommendation = 9;
  // Published advisories of the vulnerability if provided.
  repeated Advisory advisories = 10;
  // The date and time (timestamp) when the vulnerability record was created in the vulnerability database.
  optional google.protobuf.Timestamp created = 11;
  // The date and time (timestamp) when the vulnerability record was first published.
  optional google.protobuf.Timestamp published = 12;
  // The date and time (timestamp) when the vulnerability record was last updated.
  optional google.protobuf.Timestamp updated = 13;
  // Individuals or organizations credited with the discovery of the vulnerability.
  optional VulnerabilityCredits credits = 14;
  // The tool(s) used to identify, confirm, or score the vulnerability.
  optional Tool tools = 15;
  // An assessment of the impact and exploitability of the vulnerability.
  optional VulnerabilityAnalysis analysis = 16;
  // affects
  repeated VulnerabilityAffects affects = 17;
  // Specifies optional, custom, properties
  repeated Property properties = 18;
  // The date and time (timestamp) when the vulnerability record was rejected (if applicable).
  optional google.protobuf.Timestamp rejected = 19;
  // Evidence used to reproduce the vulnerability.
  optional ProofOfConcept proofOfConcept = 20;
  // A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments.
  optional string workaround = 21;
}

message ProofOfConcept {
  // Precise steps to reproduce the vulnerability.
  optional string reproductionSteps = 1;
  // A description of the environment in which reproduction was possible.
  optional string environment = 2;
  // Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code.
  repeated AttachedText supportingMaterial = 3;
}

message VulnerabilityReference {
  // An identifier that uniquely identifies the vulnerability.
  string id = 1;
  // The source that published the vulnerability.
  Source source = 2;
}

message VulnerabilityRating {
  // The source that calculated the severity or risk rating of the vulnerability.
  optional Source source = 1;
  // The numerical score of the rating.
  optional double score = 2;
  // Textual representation of the severity that corresponds to the numerical score of the rating.
  optional Severity severity = 3;
  // Specifies the severity or risk scoring methodology or standard used.
  optional ScoreMethod method = 4;
  // Textual representation of the metric values used to score the vulnerability.
  optional string vector = 5;
  // An optional reason for rating the vulnerability as it was.
  optional string justification = 6;
}

enum Severity {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
  SEVERITY_UNKNOWN = 0;
  SEVERITY_CRITICAL = 1;
  SEVERITY_HIGH = 2;
  SEVERITY_MEDIUM = 3;
  SEVERITY_LOW = 4;
  SEVERITY_INFO = 5;
  SEVERITY_NONE = 6;
}

enum ScoreMethod {
  // An undefined score method
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  SCORE_METHOD_NULL = 0;
  // Common Vulnerability Scoring System v2 - https://www.first.org/cvss/v2/
  SCORE_METHOD_CVSSV2 = 1;
  // Common Vulnerability Scoring System v3 - https://www.first.org/cvss/v3-0/
  SCORE_METHOD_CVSSV3 = 2;
  // Common Vulnerability Scoring System v3.1 - https://www.first.org/cvss/v3-1/
  SCORE_METHOD_CVSSV31 = 3;
  // OWASP Risk Rating Methodology - https://owasp.org/www-community/OWASP_Risk_Rating_Methodology
  SCORE_METHOD_OWASP = 4;
  // Other scoring method
  SCORE_METHOD_OTHER = 5;
  // Common Vulnerability Scoring System v4.0 - https://www.first.org/cvss/v4-0/
  SCORE_METHOD_CVSSV4 = 6;
  // Stakeholder Specific Vulnerability Categorization (all versions) - https://github.com/CERTCC/SSVC
  SCORE_METHOD_SSVC = 7;
}

message Advisory {
  // An optional name of the advisory.
  optional string title = 1;
  // Location where the advisory can be obtained.
  string url = 2;
}

message VulnerabilityCredits {
  // The organizations credited with vulnerability discovery.
  repeated OrganizationalEntity organizations = 1;
  // The individuals not associated with organizations that are credited with vulnerability discovery.
  repeated OrganizationalContact individuals = 2;
}

message VulnerabilityAnalysis {
  // Declares the current state of an occurrence of a vulnerability after automated or manual analysis.
  optional ImpactAnalysisState state = 1;
  // The rationale of why the impact analysis state was asserted.
  optional ImpactAnalysisJustification justification = 2;
  // A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable.
  repeated VulnerabilityResponse response = 3;
  // Detailed description of the impact, including methods used during the assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability.
  optional string detail = 4;
  // The date and time (timestamp) when the analysis was first issued.
  optional google.protobuf.Timestamp firstIssued = 5;
  // The date and time (timestamp) when the analysis was last updated.
  optional google.protobuf.Timestamp lastUpdated = 6;
}

enum ImpactAnalysisState {
  // An undefined impact analysis state
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  IMPACT_ANALYSIS_STATE_NULL = 0;
  // The vulnerability has been remediated.
  IMPACT_ANALYSIS_STATE_RESOLVED = 1;
  // The vulnerability has been remediated, and evidence of the changes is provided in the affected components pedigree containing verifiable commit history and/or diff(s).
  IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE = 2;
  // The vulnerability may be directly or indirectly exploitable.
  IMPACT_ANALYSIS_STATE_EXPLOITABLE = 3;
  // The vulnerability is being investigated.
  IMPACT_ANALYSIS_STATE_IN_TRIAGE = 4;
  // The vulnerability is not specific to the component or service and was falsely identified or associated.
  IMPACT_ANALYSIS_STATE_FALSE_POSITIVE = 5;
  // The component or service is not affected by the vulnerability. Justification should be specified for all not_affected cases.
  IMPACT_ANALYSIS_STATE_NOT_AFFECTED = 6;
}

enum ImpactAnalysisJustification {
  // An undefined impact analysis justification
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  IMPACT_ANALYSIS_JUSTIFICATION_NULL = 0;
  // The code has been removed or tree-shaked.
  IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT = 1;
  // The vulnerable code is not invoked at runtime.
  IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE = 2;
  // Exploitability requires a configurable option to be set/unset.
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION = 3;
  // Exploitability requires a dependency that is not present.
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY = 4;
  // Exploitability requires a certain environment which is not present.
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT = 5;
  // Exploitability requires a compiler flag to be set/unset.
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER = 6;
  // Exploits are prevented at runtime.
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME = 7;
  // Attacks are blocked at physical, logical, or network perimeter.
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER = 8;
  // Preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability.
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL = 9;
}

enum VulnerabilityResponse {
  // unspecified value
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
  VULNERABILITY_RESPONSE_NULL = 0;
  VULNERABILITY_RESPONSE_CAN_NOT_FIX = 1;
  VULNERABILITY_RESPONSE_WILL_NOT_FIX = 2;
  VULNERABILITY_RESPONSE_UPDATE = 3;
  VULNERABILITY_RESPONSE_ROLLBACK = 4;
  VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE = 5;
}

message VulnerabilityAffects {
  // References a component or service by the objects bom-ref
  string ref = 1;
  // Zero or more individual versions or range of versions.
  repeated VulnerabilityAffectedVersions versions = 2;
}

message VulnerabilityAffectedVersions {
  oneof choice {
    // A single version of a component or service.
    string version = 1;
    // A version range specified in Package URL Version Range syntax (vers), which is defined at https://github.com/package-url/purl-spec/VERSION-RANGE-SPEC.rst
    string range = 2;
  }
  // The vulnerability status for the version or range of versions. Defaults to VULNERABILITY_AFFECTED_STATUS_AFFECTED if not specified.
  optional VulnerabilityAffectedStatus status = 3;
}

// The vulnerability status of a given version or range of versions of a product. The statuses 'affected' and 'unaffected' indicate that the version is affected or unaffected by the vulnerability. The status 'unknown' indicates that it is unknown or unspecified whether the given version is affected. There can be many reasons for an 'unknown' status, including that an investigation has not been undertaken or that a vendor has not disclosed the status.
enum VulnerabilityAffectedStatus {
  // It is unknown (or unspecified) whether the given version is affected.
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
  VULNERABILITY_AFFECTED_STATUS_UNKNOWN = 0;
  VULNERABILITY_AFFECTED_STATUS_AFFECTED = 1;
  VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED = 2;
}

message AnnotatorChoice {
  oneof choice {
    // The organization that created the annotation
    OrganizationalEntity organization = 1;
    // The person that created the annotation
    OrganizationalContact individual = 2;
    // The tool or component that created the annotation
    Component component = 3;
    // The service that created the annotation
    Service service = 4;
  }
}

message Annotation {
  // An optional identifier which can be used to reference the annotation elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 1;
  // The object in the BOM identified by its bom-ref. This is often a component or service but may be any object type supporting bom-refs.
  repeated string subjects = 2;
  // The organization, person, component, or service which created the textual content of the annotation.
  AnnotatorChoice annotator = 3;
  // The date and time (timestamp) when the annotation was created.
  google.protobuf.Timestamp timestamp = 4;
  // The textual content of the annotation.
  string text = 5;
}

message ModelCard {
  // An optional identifier which can be used to reference the model card elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 1;
  // Hyper-parameters for construction of the model.
  optional ModelParameters modelParameters = 2;
  // A quantitative analysis of the model
  optional QuantitativeAnalysis quantitativeAnalysis = 3;
  // What considerations should be taken into account regarding the model's construction, training, and application?
  optional ModelCardConsiderations considerations = 4;

  message ModelParameters {
    // The overall approach to learning used by the model for problem-solving.
    optional Approach approach = 1;
    // Directly influences the input and/or output. Examples include classification, regression, clustering, etc.
    optional string task = 2;
    // The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc.
    optional string architectureFamily = 3;
    //The specific architecture of the model, such as GPT-1, ResNet-50, YOLOv3, etc.
    optional string modelArchitecture = 4;
    // The datasets used to train and evaluate the model.
    repeated Datasets datasets = 5;
    // The input format(s) of the model
    repeated MachineLearningInputOutputParameters inputs = 6;
    // The output format(s) from the model
    repeated MachineLearningInputOutputParameters outputs = 7;

    message Approach {
      optional ModelParameterApproachType type = 1;
    }
    message Datasets {
      oneof choice {
        ComponentData dataset = 1;
        // References a data component by the components bom-ref attribute
        string ref = 2;
      }
    }
    message MachineLearningInputOutputParameters {
      // The data format for input/output to the model. Example formats include string, image, time-series
      optional string format = 1;
    }
  }
  message QuantitativeAnalysis {
    // The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc.
    repeated PerformanceMetrics performanceMetrics = 1;
    optional GraphicsCollection graphics = 2;

    message PerformanceMetrics {
      // The type of performance metric.
      optional string type = 1;
      // The value of the performance metric.
      optional string value = 2;
      // The name of the slice this metric was computed on. By default, assume this metric is not sliced.
      optional string slice = 3;
      // The confidence interval of the metric.
      optional ConfidenceInterval confidenceInterval = 4;

      message ConfidenceInterval {
        // The lower bound of the confidence interval.
        optional string lowerBound = 1;
        // The upper bound of the confidence interval.
        optional string upperBound = 2;
      }
    }
  }
  message ModelCardConsiderations {
    // Who are the intended users of the model?
    repeated string users = 1;
    // What are the intended use cases of the model?
    repeated string useCases = 2;
    // What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance?
    repeated string technicalLimitations = 3;
    // What are the known tradeoffs in accuracy/performance of the model?
    repeated string performanceTradeoffs = 4;
    // What are the ethical risks involved in the application of this model?
    repeated EthicalConsiderations ethicalConsiderations = 5;
    // How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups?
    repeated FairnessAssessments fairnessAssessments = 6;
    // What are the various environmental impacts the corresponding machine learning model has exhibited across its lifecycle?
    optional EnvironmentalConsiderations environmentalConsiderations = 7;

    message EthicalConsiderations {
      // The name of the risk.
      optional string name = 1;
      // Strategy used to address this risk.
      optional string mitigationStrategy = 2;
    }
    message FairnessAssessments {
      // The groups or individuals at risk of being systematically disadvantaged by the model.
      optional string groupAtRisk = 1;
      // Expected benefits to the identified groups.
      optional string benefits = 2;
      // Expected harms to the identified groups.
      optional string harms = 3;
      // With respect to the benefits and harms outlined, please describe any mitigation strategy implemented.
      optional string mitigationStrategy = 4;
    }
    message EnvironmentalConsiderations {
      // Describes energy consumption information incurred for one or more component lifecycle activities.
      repeated EnergyConsumption energyConsumptions = 1;
      // Specifies optional, custom properties for environment considerations
      repeated Property properties = 2;
    }
    // Describes energy consumption information incurred for the specified lifecycle activity.
    message EnergyConsumption {
      // An activity that is part of a machine learning model development or operational lifecycle.
      enum ActivityType {
        ACTIVITY_TYPE_UNSPECIFIED = 0;
        // a lifecycle activity type whose description does not match currently defined values (the default type).
        ACTIVITY_TYPE_OTHER = 1;
        // model design including problem framing, goal definition and algorithm selection.
        ACTIVITY_TYPE_DESIGN = 2;
        // model data acquisition including search, selection and transfer.
        ACTIVITY_TYPE_DATA_COLLECTION = 3;
        // model data preparation including data cleaning, labeling and conversion.
        ACTIVITY_TYPE_DATA_PREPARATION = 4;
        // model building, training and generalized tuning.
        ACTIVITY_TYPE_TRAINING = 5;
        // refining a trained model to produce desired outputs for a given problem space.
        ACTIVITY_TYPE_FINE_TUNING = 6;
        // model validation including model output evaluation and testing.
        ACTIVITY_TYPE_VALIDATION = 7;
        // explicit model deployment to a target hosting infrastructure.
        ACTIVITY_TYPE_DEPLOYMENT = 8;
        // generating an output response from a hosted model from a set of inputs.
        ACTIVITY_TYPE_INFERENCE = 9;
      }

      // The type of activity that is part of a machine learning model development or operational lifecycle.
      ActivityType activity = 1;
      // The providers of the energy consumed by the associated model development lifecycle activity.
      repeated EnergyProviderType energyProviders = 2;
      // The total energy cost associated with the model lifecycle activity.
      EnergyMeasureType activityEnergyCost = 3;
      // The CO2 cost or debit equivalent to the total energy cost.
      optional CO2MeasureType co2CostEquivalent = 4;
      // The CO2 offset or credit for the CO2 equivalent cost.
      optional CO2MeasureType co2CostOffset = 5;
      // Specifies optional, custom properties for environment considerations
      repeated Property properties = 6;
    }
  }
}


// Describes the physical provider of energy used for model development or operations.
message EnergyProviderType {
  enum EnergySourceType {
    ENERGY_SOURCE_TYPE_UNSPECIFIED = 0;
    // energy source: unknown. The energy source is unknown.
    ENERGY_SOURCE_TYPE_UNKNOWN = 1;
    // energy source: other. An energy source that is not listed.
    ENERGY_SOURCE_TYPE_OTHER = 2;
    // energy source: coal. Energy produced by types of coal.
    ENERGY_SOURCE_TYPE_COAL = 3;
    // energy source: oil. Petroleum products (primarily crude oil and its derivative fuel oils).
    ENERGY_SOURCE_TYPE_OIL = 4;
    // energy source: natural-gas. Hydrocarbon gas liquids (HGL) that occur as gases at atmospheric pressure and as liquids under higher pressures including Natural gas (C5H12 and heavier), Ethane (C2H6), Propane (C3H8), etc.
    ENERGY_SOURCE_TYPE_NATURAL_GAS = 5;
    // energy source: nuclear. Energy produced from the cores of atoms (i.e., through nuclear fission or fusion).
    ENERGY_SOURCE_TYPE_NUCLEAR = 6;
    // energy source: wind. Energy produced from moving air.
    ENERGY_SOURCE_TYPE_WIND = 7;
    // energy source: solar. Energy produced from the sun (i.e., solar radiation).
    ENERGY_SOURCE_TYPE_SOLAR = 8;
    // energy source: geothermal. Energy produced from heat within the earth.
    ENERGY_SOURCE_TYPE_GEOTHERMAL = 9;
    // energy source: hydropower. Energy produced from flowing water.
    ENERGY_SOURCE_TYPE_HYDROPOWER = 10;
    // energy source: biofuel. Liquid fuels produced from biomass feedstocks (i.e., organic materials such as plants or animals).
    ENERGY_SOURCE_TYPE_BIOFUEL = 11;
  }

  // BOM unique reference to the energy provider.
  optional string bom_ref = 1;
  // A description of the energy provider.
  string description = 2;
  // The organization of the energy provider.
  OrganizationalEntity organization = 3;
  // The energy source for the energy provider.
  EnergySourceType energySource = 4;
  // The energy provided by the energy source for an associated activity.
  EnergyMeasureType energyProvided = 5;
  // Provides the ability to document external references related to the BOM or to the project the BOM describes.
  repeated ExternalReference external_references = 6;
}

// A measure of energy.
message EnergyMeasureType {
  enum EnergyMeasureUnitType {
    ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED = 0;
    // kilowatt-hour (kWh) is the energy delivered by one kilowatt (kW) of power for one hour (h) (the default unit).
    ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS = 1;
  }

  // Quantity of energy.
  float value = 1;
  // Unit of energy.
  EnergyMeasureUnitType unit = 2;
}


// A measure of carbon dioxide (CO2).
message CO2MeasureType {
  enum CO2MeasureUnitType {
    CO2_MEASURE_UNIT_TYPE_UNSPECIFIED = 0;
    // Tonnes (t) of carbon dioxide (CO2) equivalent (eq) (the default unit).
    CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT = 1;
  }

  // Quantity of carbon dioxide (CO2).
  float value = 1;
  // Unit of carbon dioxide (CO2).
  CO2MeasureUnitType unit = 2;
}


// An address used to identify a contactable location.
message PostalAddressType {
  // An optional identifier which can be used to reference the address elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 1;
  // The country name or the two-letter ISO 3166-1 country code.
  optional string country = 2;
  // The region or state in the country. For example, Texas.
  optional string region = 3;
  // The locality or city within the country. For example, Austin.
  optional string locality = 4;
  // The post office box number. For example, 901.
  optional string postOfficeBoxNumber = 5;
  // The postal code. For example, 78758.
  optional string postalCodeue = 6;
  // The street address. For example, 100 Main Street.
  optional string streetAddress = 7;
}

enum ModelParameterApproachType {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
  // Supervised machine learning involves training an algorithm on labeled data to predict or classify new data based on the patterns learned from the labeled examples.
  MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED = 0;
  // Unsupervised machine learning involves training algorithms on unlabeled data to discover patterns, structures, or relationships without explicit guidance, allowing the model to identify inherent structures or clusters within the data.
  MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED = 1;
  // Reinforcement learning is a type of machine learning where an agent learns to make decisions by interacting with an environment to maximize cumulative rewards, through trial and error.
  MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING = 2;
  // Semi-supervised machine learning utilizes a combination of labeled and unlabeled data during training to improve model performance, leveraging the benefits of both supervised and unsupervised learning techniques.
  MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED = 3;
  // Self-supervised machine learning involves training models to predict parts of the input data from other parts of the same data, without requiring external labels, enabling learning from large amounts of unlabeled data.
  MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED = 4;
}

message ComponentData {
  // An optional identifier which can be used to reference the dataset elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
  optional string bom_ref = 1;
  // The general theme or subject matter of the data being specified.
  ComponentDataType type = 2;
  // The name of the dataset.
  optional string name = 3;
  // The contents or references to the contents of the data being described.
  optional ComponentDataContents contents = 4;
  // Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
  optional string classification = 5;
  // A description of any sensitive data in a dataset.
  repeated string sensitiveData = 6;
  // A collection of graphics that represent various measurements.
  optional GraphicsCollection graphics = 7;
  // A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc.
  optional string description = 8;
  // Data Governance
  optional DataGovernance governance = 9;

  message ComponentDataContents {
    // An optional way to include textual or encoded data.
    optional AttachedText attachment = 1;
    // The URL to where the data can be retrieved.
    optional string url = 2;
    // Provides the ability to document name-value parameters used for configuration.
    repeated Property properties = 3;
  }
}

message DataGovernance {
  // Data custodians are responsible for the safe custody, transport, and storage of data.
  repeated DataGovernanceResponsibleParty custodians = 1;
  // Data stewards are responsible for data content, context, and associated business rules.
  repeated DataGovernanceResponsibleParty stewards = 2;
  // Data owners are concerned with risk and appropriate access to data.
  repeated DataGovernanceResponsibleParty owners = 3;

  message DataGovernanceResponsibleParty {
    oneof choice {
      OrganizationalEntity organization = 1;
      OrganizationalContact contact = 2;
    }
  }
}

enum ComponentDataType {
  // Any type of code, code snippet, or data-as-code
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
  COMPONENT_DATA_TYPE_SOURCE_CODE = 0;
  // Parameters or settings that may be used by other components.
  COMPONENT_DATA_TYPE_CONFIGURATION = 1;
  // A collection of data.
  COMPONENT_DATA_TYPE_DATASET = 2;
  // Data that can be used to create new instances of what the definition defines.
  COMPONENT_DATA_TYPE_DEFINITION = 3;
  // Any other type of data that does not fit into existing definitions.
  COMPONENT_DATA_TYPE_OTHER = 4;
}

message GraphicsCollection {
  // A description of this collection of graphics.
  optional string description = 1;
  // A collection of graphics.
  repeated Graphic graphic = 2;

  message Graphic {
    // The name of the graphic.
    optional string name = 1;
    // The graphic (vector or raster). Base64 encoding MUST be specified for binary images.
    optional AttachedText image = 2;
  }
}

// Describes workflows and resources that captures rules and other aspects of how the associated BOM component or service was formed.
message Formula {
  // BOM unique reference to the resource.
  optional string bom_ref = 1;
  // Transient components that are used in tasks that constitute one or more of this formula's workflows
  repeated Component components = 2;
  // Transient services that are used in tasks that constitute one or more of this formula's workflows
  repeated Service services = 3;
  // List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered.
  repeated Workflow workflows = 4;
  // Domain-specific formula properties.
  repeated Property properties = 5;
}

// A specialized orchestration task.
message Workflow {
  // BOM unique reference to the resource.
  string bom_ref = 1;
  // The unique identifier for the resource instance within its deployment context.
  string uid = 2;
  // The name of the resource instance.
  optional string name = 3;
  // A description of the resource instance.
  optional string description = 4;
  // Domain-specific resource instance properties.
  repeated Property properties = 5;
  // References to component or service resources that are used to realize the resource instance.
  repeated ResourceReferenceChoice resourceReferences = 6;
  // The tasks that comprise the workflow.
  repeated Task tasks = 7;
  // The graph of dependencies between tasks within the workflow.
  repeated Dependency taskDependencies = 8;
  // Indicates the types of activities performed by the set of workflow tasks.
  repeated TaskType taskTypes = 9;
  // The trigger that initiated the task.
  optional Trigger trigger = 10;
  // The sequence of steps for the task.
  repeated Step steps = 11;
  // Represents resources and data brought into a task at runtime by executor or task commands
  repeated InputType inputs = 12;
  // Represents resources and data output from a task at runtime by executor or task commands
  repeated OutputType outputs = 13;
  // The date and time (timestamp) when the task started.
  optional google.protobuf.Timestamp timeStart = 14;
  // The date and time (timestamp) when the task ended.
  optional google.protobuf.Timestamp timeEnd = 15;
  // A set of named filesystem or data resource shareable by workflow tasks.
  repeated Workspace workspaces = 16;
  // A graph of the component runtime topology for workflow's instance.
  repeated Dependency runtimeTopology = 17;
}

// Describes the inputs, sequence of steps and resources used to accomplish a task and its output.
message Task {
  // BOM unique reference to the resource.
  string bom_ref = 1;
  // The unique identifier for the resource instance within its deployment context.
  string uid = 2;
  // The name of the resource instance.
  optional string name = 3;
  // A description of the resource instance.
  optional string description = 4;
  // Domain-specific task instance properties.
  repeated Property properties = 5;
  // References to component or service resources that are used to realize the resource instance.
  repeated ResourceReferenceChoice resourceReferences = 6;
  // Indicates the types of activities performed by the set of workflow tasks.
  repeated TaskType taskTypes = 7;
  // The trigger that initiated the task.
  optional Trigger trigger = 8;
  // "The sequence of steps for the task.
  repeated Step steps = 9;
  // Represents resources and data brought into a task at runtime by an executor or task commands
  repeated InputType inputs = 10;
  // Represents resources and data output from a task at runtime by an executor or task commands
  repeated OutputType outputs = 11;
  // The date and time (timestamp) when the task started.
  optional google.protobuf.Timestamp timeStart = 14;
  // The date and time (timestamp) when the task ended.
  optional google.protobuf.Timestamp timeEnd = 15;
  // A set of named filesystem or data resource shareable by workflow tasks.
  repeated Workspace workspaces = 16;
  // A graph of the component runtime topology for task's instance.
  repeated Dependency runtimeTopology = 17;
}

// Executes specific commands or tools in order to accomplish its owning task as part of a sequence.
message Step {
  // A name for the step.
  optional string name = 1;
  // A description of the step.
  optional string description = 2;
  // Ordered list of commands or directives for the step
  repeated Command commands = 3;
  // Domain-specific step properties.
  repeated Property properties = 4;
}

message Command {
  // A text representation of the executed command.
  optional string executed = 1;
  // Domain-specific command properties.
  repeated Property properties = 2;
}

// A named filesystem or data resource shareable by workflow tasks.
message Workspace {
  // BOM unique reference to the resource.
  string bom_ref = 1;
  // The unique identifier for the resource instance within its deployment context.
  string uid = 2;
  // The name of the resource instance.
  optional string name = 3;
  // The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps.
  repeated string aliases = 4;
  // A description of the resource instance.
  optional string description = 5;
  // Domain-specific workspace instance properties.
  repeated Property properties = 6;
  // References to component or service resources that are used to realize the resource instance.
  repeated ResourceReferenceChoice resourceReferences = 7;
  // Describes the read-write access control for the workspace relative to the owning resource instance.
  optional AccessMode accessMode = 8;
  // A path to a location on disk where the workspace will be available for the associated task's steps.
  optional string mountPath = 9;
  // The name of a domain-specific data type the workspace represents.
  optional string managedDataType = 10;
  // Identifies the reference to the request for a specific volume type and parameters.
  optional string volumeRequest = 11;
  // Information about the actual volume instance allocated to the workspace.
  optional Volume volume = 12;

  enum AccessMode {
    // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
    ACCESS_MODE_READ_ONLY = 0;
    ACCESS_MODE_READ_WRITE = 1;
    ACCESS_MODE_READ_WRITE_ONCE = 2;
    ACCESS_MODE_WRITE_ONCE = 3;
    ACCESS_MODE_WRITE_ONLY = 4;
  }
}

// An identifiable, logical unit of data storage tied to a physical device.
message Volume {
  // The unique identifier for the volume instance within its deployment context.
  optional string uid = 1;
  // The name of the volume instance
  optional string name = 2;
  // The volume mode for the volume instance.
  optional VolumeMode mode = 3;
  // The underlying path created from the actual volume.
  optional string path = 4;
  // The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as the IEC standard unit in either decimal or binary form.
  optional string sizeAllocated = 5;
  // Indicates if the volume persists beyond the life of the resource it is associated with.
  optional bool persistent = 6;
  // Indicates if the volume is remotely (i.e., network) attached.
  optional bool remote = 7;
  // Domain-specific volume instance properties.
  repeated Property properties = 8;

  enum VolumeMode {
    // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
    VOLUME_MODE_FILESYSTEM = 0;
    VOLUME_MODE_BLOCK = 1;
  }
}

// Represents a resource that can conditionally activate (or fire) tasks based upon associated events and their data.
message Trigger {
  // BOM unique reference to the resource.
  string bom_ref = 1;
  // The unique identifier for the resource instance within its deployment context.
  string uid = 2;
  // The name of the resource instance.
  optional string name = 3;
  // A description of the resource instance.
  optional string description = 4;
  // Additional properties of the trigger.
  repeated Property properties = 5;
  // References to component or service resources that are used to realize the resource instance.
  repeated ResourceReferenceChoice resourceReferences = 6;
  // The source type of event which caused the trigger to fire.
  TriggerType type = 7;
  // The event data that caused the associated trigger to activate.
  optional Event event = 8;
  // Conditions
  repeated Condition conditions = 9;
  // The date and time (timestamp) when the trigger was activated.
  optional google.protobuf.Timestamp timeActivated = 10;
  // Represents resources and data brought into a task at runtime by an executor or task commands
  repeated InputType inputs = 11;
  // Represents resources and data output from a task at runtime by an executor or task commands
  repeated OutputType outputs = 12;

  enum TriggerType {
    // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
    TRIGGER_TYPE_MANUAL = 0;
    TRIGGER_TYPE_API = 1;
    TRIGGER_TYPE_WEBHOOK = 2;
    TRIGGER_TYPE_SCHEDULED = 3;
  }
}

// Represents something that happened that may trigger a response.
message Event {
  // The unique identifier of the event.
  optional string uid = 1;
  // A description of the event.
  optional string description = 2;
  // The date and time (timestamp) when the event was received.
  optional google.protobuf.Timestamp timeReceived = 3;
  // Encoding of the raw event data.
  optional AttachedText data = 4;
  // References the component or service that was the source of the event
  optional ResourceReferenceChoice source = 5;
  // References the component or service that was the target of the event
  optional ResourceReferenceChoice target = 6;
  // Additional properties of the event.
  repeated Property properties = 7;
}

// Type that represents various input data types and formats.
message InputType {
  // A references to the component or service that provided the input to the task (e.g., reference to a service with a data flow value of `inbound`)
  optional ResourceReferenceChoice source = 1;
  // A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace)
  optional ResourceReferenceChoice target = 2;
  // A reference to an independent resource provided as an input to a task by the workflow runtime.
  optional ResourceReferenceChoice resource = 3;
  // Inputs that have the form of parameters with names and values.
  repeated Parameter parameters = 4;
  // Inputs that have the form of parameters with names and values.
  repeated EnvironmentVars environmentVars = 5;
  // Inputs that have the form of data.
  optional AttachedText data = 6;
  // Additional properties of the input data.
  repeated Property properties = 7;
}

// Type that represents various output data types and formats.
message OutputType {
  // Describes the type of data output.
  optional OutputTypeType type = 1;
  // Component or service that generated or provided the output from the task (e.g., a build tool)
  optional ResourceReferenceChoice source = 2;
  // Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`)
  optional ResourceReferenceChoice target = 3;
  // A reference to an independent resource generated as output by the task.
  optional ResourceReferenceChoice resource = 4;
  // Outputs that have the form of data.
  optional AttachedText data = 5;
  // Outputs that have the form of environment variables.
  repeated EnvironmentVars environmentVars = 6;
  // Additional properties of the output data.
  repeated Property properties = 7;

  // buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "OUTPUT_TYPE_TYPE_"
  enum OutputTypeType {
    // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
    OUTPUT_TYPE_ARTIFACT = 0;
    OUTPUT_TYPE_ATTESTATION = 1;
    OUTPUT_TYPE_LOG = 2;
    OUTPUT_TYPE_EVIDENCE = 3;
    OUTPUT_TYPE_METRICS = 4;
    OUTPUT_TYPE_OTHER = 5;
  }
}

// Type that permits a choice to reference a resource using an iternal bom-ref identifier or an external reference.
message ResourceReferenceChoice {
  oneof choice {
    string ref = 1;
    ExternalReference externalReference = 2;
  }
}

// A condition that was used to determine a trigger should be activated.
message Condition {
  // Describes the set of conditions which cause the trigger to activate.
  optional string description = 1;
  // The logical expression that was evaluated that determined the trigger should be fired.
  optional string expression = 2;
  // Domain-specific condition instance properties.
  repeated Property properties = 3;
}

enum TaskType {
  // A task that copies software or data used to accomplish other tasks in the workflow.
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
  TASK_TYPE_COPY = 0;
  // A task that clones a software repository into the workflow in order to retrieve its source code or data for use in a build step.
  TASK_TYPE_CLONE = 1;
  // A task that checks source code for programmatic and stylistic errors.
  TASK_TYPE_LINT = 2;
  // A task that performs a scan against source code, or built or deployed components and services. Scans are typically run to gather or test for security vulnerabilities or policy compliance.
  TASK_TYPE_SCAN = 3;
  // A task that merges changes or fixes into source code prior to a build step in the workflow.
  TASK_TYPE_MERGE = 4;
  // A task that builds the source code, dependencies and/or data into an artifact that can be deployed to and executed on target systems.
  TASK_TYPE_BUILD = 5;
  // A task that verifies the functionality of a component or service.
  TASK_TYPE_TEST = 6;
  // A task that delivers a built artifact to one or more target repositories or storage systems.
  TASK_TYPE_DELIVER = 7;
  // A task that deploys a built artifact for execution on one or more target systems.
  TASK_TYPE_DEPLOY = 8;
  // A task that releases a built, versioned artifact to a target repository or distribution system.
  TASK_TYPE_RELEASE = 9;
  // A task that cleans unnecessary tools, build artifacts and/or data from workflow storage.
  TASK_TYPE_CLEAN = 10;
  // A workflow task that does not match current task type definitions.
  TASK_TYPE_OTHER = 11;
}

// A representation of a functional parameter.
message Parameter {
  // The name of the parameter.
  optional string name = 1;
  // The value of the parameter.
  optional string value = 2;
  // The data type of the parameter.
  optional string dataType = 3;
}

message EnvironmentVars {
  oneof choice {
    Property property = 1;
    string value = 2;
  }
}

message Declarations {
  message Assessor {
    // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
    optional string bom_ref = 1;
    // The boolean indicating if the assessor is outside the organization generating claims. A value of false indicates a self assessor.
    optional bool thirdParty = 2;
    // The entity issuing the assessment.
    optional OrganizationalEntity organization = 3;
  }
  message Attestation {
    message AttestationMap {
      message AttestationConformance {
        // The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance.
        optional double score = 1;
        // The rationale for the conformance score.
        optional string rationale = 2;
        // The list of  `bom-ref` to the evidence provided describing the mitigation strategies.
        repeated string mitigationStrategies = 3;
      }
      message AttestationConfidence {
        // The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence.
        optional double score = 1;
        // The rationale for the confidence score.
        optional string rationale = 2;
      }
      // The `bom-ref` to the requirement being attested to.
      optional string requirement = 1;
      // The list of `bom-ref` to the claims being attested to.
      repeated string claims = 2;
      // The list of  `bom-ref` to the counter claims being attested to.
      repeated string counterClaims = 3;
      // The conformance of the claim meeting a requirement.
      optional AttestationConformance conformance = 4;
      // The confidence of the claim meeting the requirement.
      optional AttestationConfidence confidence = 5;
    }
    // The short description explaining the main points of the attestation.
    optional string summary = 1;
    // The `bom-ref` to the assessor asserting the attestation.
    optional string assessor = 2;
    // The grouping of requirements to claims and the attestors' declared conformance and confidence thereof.
    repeated AttestationMap map = 3;
  }
  message Claim {
    // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
    optional string bom_ref = 1;
    // The `bom-ref` to a target representing a specific system, application, API, module, team, person, process, business unit, company, etc...  that this claim is being applied to.
    optional string target = 2;
    // The specific statement or assertion about the target.
    optional string predicate = 3;
    // The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each mitigation strategy should include an explanation of how any weaknesses in the evidence will be mitigated.
    repeated string mitigationStrategies = 4;
    // The written explanation of why the evidence provided substantiates the claim.
    optional string reasoning = 5;
    // The list of `bom-ref` to evidence that supports this claim.
    repeated string evidence = 6;
    // The list of `bom-ref` to counterEvidence that supports this claim.
    repeated string counterEvidence = 7;
    // External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
    repeated ExternalReference externalReferences = 8;
  }
  message Evidence {
    message Data {
      message Contents {
        // An optional way to include textual or encoded data.
        optional AttachedText attachment = 1;
        // The URL to where the data can be retrieved.
        optional string url = 2;
      }
      // The name of the data.
      optional string name = 1;
      // The contents or references to the contents of the data being described.
      optional Contents contents = 2;
      // Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed.
      optional string classification = 3;
      // A description of any sensitive data included.
      repeated string sensitiveData = 4;
      // Data Governance
      optional DataGovernance governance = 5;
    }
    // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
    optional string bom_ref = 1;
    // The reference to the property name as defined in the CycloneDX Property Taxonomy: https://github.com/CycloneDX/cyclonedx-property-taxonomy/.
    optional string propertyName = 2;
    // The written description of what this evidence is and how it was created.
    optional string description = 3;
    // The output or analysis that supports claims.
    repeated Data data = 4;
    // The date and time (timestamp) when the evidence was created.
    optional google.protobuf.Timestamp created = 5;
    // The optional date and time (timestamp) when the evidence is no longer valid.
    optional google.protobuf.Timestamp expires = 6;
    // The author of the evidence.
    optional OrganizationalContact author = 7;
    // The reviewer of the evidence.
    optional OrganizationalContact reviewer = 8;
  }
  message Targets {
    // The list of organizations which claims are made against.
    repeated OrganizationalEntity organizations = 1;
    // The list of components which claims are made against.
    repeated Component components = 2;
    // The list of services which claims are made against.
    repeated Service services = 3;
  }
  message Affirmation {
    message Signatory {
      // The signatory's name.
      optional string name = 1;
      // The signatory's role within an organization.
      optional string role = 2;
      // The signatory's organization.
      optional OrganizationalEntity organization = 3;
      // An External reference provides a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
      optional ExternalReference externalReference = 4;
    }
    // The brief statement affirmed by an individual regarding all declarations. Notes: This could be an affirmation of acceptance by a third-party auditor or receiving individual of a file.
    optional string statement = 1;
    // The list of signatories authorized on behalf of an organization to assert validity of this document.
    repeated Signatory signatories = 2;
  }
  // The list of assessors evaluating claims and determining conformance to requirements and confidence in that assessment.
  repeated Assessor assessors = 1;
  // The list of attestations asserted by an assessor that maps requirements to claims.
  repeated Attestation attestations = 2;
  // The list of claims.
  repeated Claim claims = 3;
  // The list of evidence
  repeated Evidence evidence = 4;
  // The list of targets which claims are made against.
  optional Targets targets = 5;
  // affirmation
  optional Affirmation affirmation = 6;
}

message Definition {
  message Standard {
    message Requirement {
      // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
      optional string bom_ref = 1;
      // The unique identifier used in the standard to identify a specific requirement. This should match what is in the standard and should not be the requirements bom-ref.
      optional string identifier = 2;
      // The title of the requirement.
      optional string title = 3;
      // The textual content of the requirement.
      optional string text = 4;
      // The supplemental text that provides additional guidance or context to the requirement but is not directly part of the requirement.
      repeated string descriptions = 5;
      // The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and standardized framework for uniting security standards and guidelines. CRE links each section of a resource to a shared topic identifier (a Common Requirement). Through this shared topic link, all resources map to each other. The use of CRE promotes clear and unambiguous communication among stakeholders.
      repeated string openCre = 6;
      // The optional `bom-ref` to a parent requirement. This establishes a hierarchy of requirements. Top-level requirements must not define a parent. Only child requirements should define parents.
      optional string parent = 7;
      // Specifies optional, custom, properties
      repeated Property properties = 8;
      // External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
      repeated ExternalReference externalReferences = 9;
    }
    message Level {
      // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
      optional string bom_ref = 1;
      // The identifier used in the standard to identify a specific level.
      optional string identifier = 2;
      // The title of the level.
      optional string title = 3;
      // The description of the level.
      optional string description = 4;
      // The list of requirement `bom-ref`s that comprise the level.
      repeated string requirements = 5;
    }
    // An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element.
    optional string bom_ref = 1;
    // The name of the standard. This will often be a shortened, single name of the standard.
    optional string name = 2;
    // The version of the standard.
    optional string version = 3;
    // The description of the standard.
    optional string description = 4;
    // The owner of the standard, often the entity responsible for its release.
    optional string owner = 5;
    // The list of requirements comprising the standard.
    repeated Requirement requirements = 6;
    // The list of levels associated with the standard. Some standards have different levels of compliance.
    repeated Level levels = 7;
    // External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM.
    repeated ExternalReference externalReferences = 8;
  }
  repeated Standard standards = 1;
}

message CryptoProperties {
  enum CryptoAssetType {
    // ProtoBuff's default value
    CRYPTO_ASSET_TYPE_UNSPECIFIED = 0;
    CRYPTO_ASSET_TYPE_ALGORITHM = 1;
    CRYPTO_ASSET_TYPE_CERTIFICATE = 2;
    CRYPTO_ASSET_TYPE_PROTOCOL = 3;
    CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL = 4;
  }
  message AlgorithmProperties {
    enum CryptoPrimitive {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_PRIMITIVE_UNSPECIFIED = 0;
      // The primitive is not known
      CRYPTO_PRIMITIVE_UNKNOWN = 1;
      // Another primitive type - none of the following
      CRYPTO_PRIMITIVE_OTHER = 2;
      CRYPTO_PRIMITIVE_DRBG = 3;
      CRYPTO_PRIMITIVE_MAC = 4;
      CRYPTO_PRIMITIVE_BLOCK_CIPHER = 5;
      CRYPTO_PRIMITIVE_STREAM_CIPHER = 6;
      CRYPTO_PRIMITIVE_SIGNATURE = 7;
      CRYPTO_PRIMITIVE_HASH = 8;
      CRYPTO_PRIMITIVE_PKE = 9;
      CRYPTO_PRIMITIVE_XOF = 10;
      CRYPTO_PRIMITIVE_KDF = 11;
      CRYPTO_PRIMITIVE_KEY_AGREE = 12;
      CRYPTO_PRIMITIVE_KEM = 13;
      CRYPTO_PRIMITIVE_AE = 14;
      CRYPTO_PRIMITIVE_COMBINER = 15;
    }
    enum CryptoExecutionEnvironment {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED = 0;
      // The execution environment is not known
      CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN = 1;
      // Another implementation environment - none of the following
      CRYPTO_EXECUTION_ENVIRONMENT_OTHER = 2;
      CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM = 3;
      CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM = 4;
      CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE = 5;
      CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE = 6;
    }
    enum CryptoImplementationPlatform {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED = 0;
      // the platform is not known
      CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN = 1;
      // none of the following
      CRYPTO_IMPLEMENTATION_PLATFORM_OTHER = 2;
      CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC = 3;
      CRYPTO_IMPLEMENTATION_PLATFORM_X86_32 = 4;
      CRYPTO_IMPLEMENTATION_PLATFORM_X86_64 = 5;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A = 6;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M = 7;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A = 8;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M = 9;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A = 10;
      CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M = 11;
      CRYPTO_IMPLEMENTATION_PLATFORM_X390X = 12;
      CRYPTO_IMPLEMENTATION_PLATFORM_PPC64 = 13;
      CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE = 14;
    }
    enum CryptoAlgorithmMode {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_ALGORITHM_MODE_UNSPECIFIED = 0;
      // The mode of operation is not known
      CRYPTO_ALGORITHM_MODE_UNKNOWN = 1;
      // Another mode of operation - none of the following
      CRYPTO_ALGORITHM_MODE_OTHER = 2;
      CRYPTO_ALGORITHM_MODE_CBC = 3;
      CRYPTO_ALGORITHM_MODE_ECB = 4;
      CRYPTO_ALGORITHM_MODE_CCM = 5;
      CRYPTO_ALGORITHM_MODE_GCM = 6;
      CRYPTO_ALGORITHM_MODE_CFB = 7;
      CRYPTO_ALGORITHM_MODE_OFB = 8;
      CRYPTO_ALGORITHM_MODE_CTR = 9;
    }
    enum CryptoAlgorithmPadding {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_ALGORITHM_PADDING_UNSPECIFIED = 0;
      // The padding scheme is not known
      CRYPTO_ALGORITHM_PADDING_UNKNOWN = 1;
      // Another padding scheme - none of the following
      CRYPTO_ALGORITHM_PADDING_OTHER = 2;
      CRYPTO_ALGORITHM_PADDING_PKCS5 = 3;
      CRYPTO_ALGORITHM_PADDING_PKCS7 = 4;
      CRYPTO_ALGORITHM_PADDING_PKCS1V15 = 5;
      CRYPTO_ALGORITHM_PADDING_OAEP = 6;
      CRYPTO_ALGORITHM_PADDING_RAW = 7;
    }
    enum CryptoAlgorithmFunction {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED = 0;
      // meaning "there is some, but it is unclear which one"
      CRYPTO_ALGORITHM_FUNCTION_UNKNOWN = 1;
      // none of the following
      CRYPTO_ALGORITHM_FUNCTION_OTHER = 2;
      CRYPTO_ALGORITHM_FUNCTION_GENERATE = 3;
      CRYPTO_ALGORITHM_FUNCTION_KEYGEN = 4;
      CRYPTO_ALGORITHM_FUNCTION_ENCRYPT = 5;
      CRYPTO_ALGORITHM_FUNCTION_DECRYPT = 6;
      CRYPTO_ALGORITHM_FUNCTION_DIGEST = 7;
      CRYPTO_ALGORITHM_FUNCTION_TAG = 8;
      CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE = 9;
      CRYPTO_ALGORITHM_FUNCTION_SIGN = 10;
      CRYPTO_ALGORITHM_FUNCTION_VERIFY = 11;
      CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE = 12;
      CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE = 13;
    }
    // Cryptographic building blocks used in higher-level cryptographic systems and protocols. Primitives represent different cryptographic routines: deterministic random bit generators (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. SP800-56Cr2).
    optional CryptoPrimitive primitive = 1;
    // An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies a parameter set used in SLH-DSA (FIPS205).
    optional string parameterSetIdentifier = 2;
    // The specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. Absent an authoritative source of curve names, CycloneDX recommends use of curve names as defined at [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source from which can be found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves).
    optional string curve = 3;
    // The target and execution environment in which the algorithm is implemented in.
    optional CryptoExecutionEnvironment executionEnvironment = 4;
    // The target platform for which the algorithm is implemented. The implementation can be 'generic', running on any platform or for a specific platform.
    optional CryptoImplementationPlatform implementationPlatform = 5;
    // The certification that the implementation of the cryptographic algorithm has received, if any. Certifications include revisions and levels of FIPS 140 or Common Criteria of different Extended Assurance Levels (CC-EAL).
    repeated string certificationLevel = 6;
    // The mode of operation in which the cryptographic algorithm (block cipher) is used.
    optional CryptoAlgorithmMode mode = 7;
    // The padding scheme that is used for the cryptographic algorithm.
    optional CryptoAlgorithmPadding padding = 8;
    // The cryptographic functions implemented by the cryptographic algorithm.
    repeated CryptoAlgorithmFunction cryptoFunctions = 9;
    // The classical security level that a cryptographic algorithm provides (in bits).
    optional int32 classicalSecurityLevel = 10;
    // The NIST security strength category as defined in https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). A value of 0 indicates that none of the categories are met.
    optional int32 nistQuantumSecurityLevel = 11;
  } // end of AlgorithmProperties
  message CertificateProperties {
    // The subject name for the certificate
    optional string subjectName = 1;
    // The issuer name for the certificate
    optional string issuerName = 2;
    // The date and time according to ISO-8601 standard from which the certificate is valid
    optional google.protobuf.Timestamp notValidBefore = 3;
    // The date and time according to ISO-8601 standard from which the certificate is not valid anymore
    optional google.protobuf.Timestamp notValidAfter = 4;
    // The bom-ref to signature algorithm used by the certificate
    optional string signatureAlgorithmRef = 5;
    // The bom-ref to the public key of the subject
    optional string subjectPublicKeyRef = 6;
    // The format of the certificate. Examples include X.509, PEM, DER, and CVC.
    optional string certificateFormat = 7;
    // The file extension of the certificate. Examples include crt, pem, cer, der, and p12.
    optional string certificateExtension = 8;
  } // end of CertificateProperties
  message RelatedCryptoMaterialProperties {
    enum CryptoRelatedType {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_RELATED_TYPE_UNSPECIFIED = 0;
      // The type of cryptographic asset is not known.
      CRYPTO_RELATED_TYPE_UNKNOWN = 1;
      // Another type of cryptographic asset - none of the following
      CRYPTO_RELATED_TYPE_OTHER = 2;
      CRYPTO_RELATED_TYPE_PRIVATE_KEY = 3;
      CRYPTO_RELATED_TYPE_PUBLIC_KEY = 4;
      CRYPTO_RELATED_TYPE_SECRET_KEY = 5;
      CRYPTO_RELATED_TYPE_KEY = 6;
      CRYPTO_RELATED_TYPE_CIPHERTEXT = 7;
      CRYPTO_RELATED_TYPE_SIGNATURE = 8;
      CRYPTO_RELATED_TYPE_DIGEST = 9;
      CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR = 10;
      CRYPTO_RELATED_TYPE_NONCE = 11;
      CRYPTO_RELATED_TYPE_SEED = 12;
      CRYPTO_RELATED_TYPE_SALT = 13;
      CRYPTO_RELATED_TYPE_SHARED_SECRET = 14;
      CRYPTO_RELATED_TYPE_TAG = 15;
      CRYPTO_RELATED_TYPE_ADDITIONAL_DATA = 16;
      CRYPTO_RELATED_TYPE_PASSWORD = 17;
      CRYPTO_RELATED_TYPE_CREDENTIAL = 18;
      CRYPTO_RELATED_TYPE_TOKEN = 19;
    }
    enum CryptoRelatedState {
      // Default
      CRYPTO_RELATED_STATE_UNSPECIFIED = 0;
      CRYPTO_RELATED_STATE_PRE_ACTIVATION = 1;
      CRYPTO_RELATED_STATE_ACTIVE = 2;
      CRYPTO_RELATED_STATE_SUSPENDED = 3;
      CRYPTO_RELATED_STATE_DEACTIVATED = 4;
      CRYPTO_RELATED_STATE_COMPROMISED = 5;
      CRYPTO_RELATED_STATE_DESTROYED = 6;
    }
    message CryptoRelatedSecuredBy {
      // Specifies the mechanism by which the cryptographic asset is secured. Examples include HSM, TPM, SGX, Software, and None
      optional string mechanism = 1;
      // The bom-ref to the algorithm.
      optional string algorithmRef = 2;
    }
    // The type for the related cryptographic material
    optional CryptoRelatedType type = 1;
    // The optional unique identifier for the related cryptographic material.
    optional string id = 2;
    // The key state as defined by NIST SP 800-57.
    optional CryptoRelatedState state = 3;
    // The bom-ref to the algorithm used to generate the related cryptographic material.
    optional string algorithmRef = 4;
    // The date and time (timestamp) when the related cryptographic material was created.
    optional google.protobuf.Timestamp creationDate = 5;
    // The date and time (timestamp) when the related cryptographic material was activated.
    optional google.protobuf.Timestamp activationDate = 6;
    // The date and time (timestamp) when the related cryptographic material was updated.
    optional google.protobuf.Timestamp updateDate = 7;
    // The date and time (timestamp) when the related cryptographic material expires.
    optional google.protobuf.Timestamp expirationDate = 8;
    // The associated value of the cryptographic material.
    optional string value = 9;
    // The size of the cryptographic asset (in bits).
    optional int64 size = 10;
    // The format of the related cryptographic material (e.g. P8, PEM, DER).
    optional string format = 11;
    // The mechanism by which the cryptographic asset is secured.
    optional CryptoRelatedSecuredBy securedBy = 12;
  } // end of RelatedCryptoMaterialProperties
  message ProtocolProperties {
    enum CryptoProtocolType {
      // ProtoBuff's default value -- it differs from "unknown"
      CRYPTO_PROTOCOL_TYPE_UNSPECIFIED = 0;
      // The protocol type is not known
      CRYPTO_PROTOCOL_TYPE_UNKNOWN = 1;
      // Another protocol type - none of the following
      CRYPTO_PROTOCOL_TYPE_OTHER = 2;
      CRYPTO_PROTOCOL_TYPE_TLS = 3;
      CRYPTO_PROTOCOL_TYPE_SSH = 4;
      CRYPTO_PROTOCOL_TYPE_IPSEC = 5;
      CRYPTO_PROTOCOL_TYPE_IKE = 6;
      CRYPTO_PROTOCOL_TYPE_SSTP = 7;
      CRYPTO_PROTOCOL_TYPE_WPA = 8;
    }
    message CryptoProtocolCipherSuite {
      // A common name for the cipher suite. For example: TLS_DHE_RSA_WITH_AES_128_CCM
      optional string name = 1;
      // A list of algorithms related to the cipher suite. Use the bom-ref to the algorithm cryptographic asset.
      repeated string algorithms = 2;
      // A list of common identifiers for the cipher suite. For example: 0xC0 and 0x9E
      repeated string identifiers = 3;
    }
    message Ikev2TransformTypes {
      // Transform Type 1: encryption algorithms
      repeated string encr = 1;
      // Transform Type 2: pseudorandom functions
      repeated string prf = 2;
      // Transform Type 3: integrity algorithms
      repeated string integ = 3;
      // Transform Type 4: Key Exchange Method (KE) per RFC9370, formerly called Diffie-Hellman Group (D-H)
      repeated string ke = 4;
      // Specifies if an Extended Sequence Number (ESN) is used.
      optional bool esn = 5;
      // IKEv2 Authentication method
      repeated string auth = 6;
    }
    // The concrete protocol type.
    optional CryptoProtocolType type = 1;
    // The version of the protocol. Examples include 1.0, 1.2, and 1.99.
    optional string version = 2;
    // A list of cipher suites related to the protocol.
    repeated CryptoProtocolCipherSuite cipherSuites = 3;
    // The IKEv2 transform types supported (types 1-4), defined in RFC7296 section 3.3.2, and additional properties.
    optional Ikev2TransformTypes ikev2TransformTypes = 4;
  } // end of ProtocolProperties
  // Cryptographic assets occur in several forms. Algorithms and protocols are most commonly implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' in software components. Certificates and related cryptographic material like keys, tokens, secrets or passwords are other cryptographic assets to be modelled.
  CryptoAssetType assetType = 1;
  // Additional properties specific to a cryptographic algorithm.
  optional AlgorithmProperties algorithmProperties = 2;
  // Properties for cryptographic assets of asset type 'certificate'
  optional CertificateProperties certificateProperties = 3;
  // Properties for cryptographic assets of asset type: `related-crypto-material`
  optional RelatedCryptoMaterialProperties relatedCryptoMaterialProperties = 4;
  // Properties specific to cryptographic assets of type: `protocol`.
  optional ProtocolProperties protocolProperties = 5;
  // The object identifier (OID) of the cryptographic asset.
  optional string oid = 6;
}
