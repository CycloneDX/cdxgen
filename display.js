import { table } from "table";

// https://github.com/yangshun/tree-node-cli/blob/master/src/index.js
const SYMBOLS_ANSI = {
  BRANCH: "├── ",
  EMPTY: "",
  INDENT: "  ",
  LAST_BRANCH: "└── ",
  VERTICAL: "│ "
};

const MAX_TREE_DEPTH = 3;

export const printTable = (bomJson) => {
  const data = [["Group", "Name", "Version", "Scope"]];
  if (!bomJson || !bomJson.components) {
    return;
  }
  for (const comp of bomJson.components) {
    data.push([comp.group || "", comp.name, comp.version, comp.scope || ""]);
  }
  const config = {
    header: {
      alignment: "center",
      content: "Software Bill-of-Materials\nGenerated by @cyclonedx/cdxgen"
    }
  };
  console.log(table(data, config));
  console.log(
    "BOM includes",
    bomJson.components.length,
    "components and",
    bomJson.dependencies.length,
    "dependencies"
  );
};
export const printDependencyTree = (bomJson) => {
  const dependencies = bomJson.dependencies || [];
  if (!dependencies.length) {
    return;
  }
  const depMap = {};
  for (const d of dependencies) {
    if (d.dependsOn && d.dependsOn.length) {
      depMap[d.ref] = d.dependsOn.sort();
    }
  }
  const shownList = [];
  const treeGraphics = [];
  recursePrint(depMap, dependencies, 0, shownList, treeGraphics);
  const config = {
    header: {
      alignment: "center",
      content: "Dependency Tree\nGenerated with \u2665 by cdxgen"
    }
  };
  console.log(table([[treeGraphics.join("\n")]], config));
};

const levelPrefix = (level, isLast) => {
  if (level === 0) {
    return SYMBOLS_ANSI.EMPTY;
  }
  let prefix = `${isLast ? SYMBOLS_ANSI.LAST_BRANCH : SYMBOLS_ANSI.BRANCH}`;
  for (let i = 0; i < level - 1; i++) {
    prefix = `${
      isLast
        ? SYMBOLS_ANSI.LAST_BRANCH.replace(" ", "─")
        : SYMBOLS_ANSI.VERTICAL
    }${isLast ? "" : SYMBOLS_ANSI.INDENT}${prefix}`;
  }
  return prefix;
};

const isReallyRoot = (depMap, refStr) => {
  for (const k of Object.keys(depMap)) {
    const dependsOn = depMap[k] || [];
    if (
      dependsOn.includes(refStr) ||
      dependsOn.includes(refStr.toLowerCase())
    ) {
      return false;
    }
  }
  return true;
};

const recursePrint = (depMap, subtree, level, shownList, treeGraphics) => {
  const listToUse = Array.isArray(subtree) ? subtree : [subtree];
  for (let i = 0; i < listToUse.length; i++) {
    const l = listToUse[i];
    const refStr = l.ref || l;
    if (
      (level === 0 &&
        isReallyRoot(depMap, refStr) &&
        !shownList.includes(refStr.toLowerCase())) ||
      level > 0
    ) {
      treeGraphics.push(
        `${levelPrefix(level, i == listToUse.length - 1)}${refStr}`
      );
      shownList.push(refStr.toLowerCase());
      if (l && depMap[refStr]) {
        if (level < MAX_TREE_DEPTH) {
          recursePrint(
            depMap,
            depMap[refStr],
            level + 1,
            shownList,
            treeGraphics
          );
        }
      }
    }
  }
};
