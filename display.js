import { table } from "table";

// https://github.com/yangshun/tree-node-cli/blob/master/src/index.js
const SYMBOLS_ANSI = {
  BRANCH: "├── ",
  EMPTY: "",
  INDENT: "  ",
  LAST_BRANCH: "└── ",
  VERTICAL: "│ "
};

export const printTable = (bomJson) => {
  const data = [["Group", "Name", "Version", "Scope"]];
  for (const comp of bomJson.components) {
    data.push([comp.group || "", comp.name, comp.version, comp.scope || ""]);
  }
  const config = {
    header: {
      alignment: "center",
      content: "Software Bill-of-Materials\nGenerated by @cyclonedx/cdxgen"
    }
  };
  console.log(table(data, config));
  console.log(
    "BOM includes",
    bomJson.components.length,
    "components and",
    bomJson.dependencies.length,
    "dependencies"
  );
};
export const printDependencyTree = (bomJson) => {
  const dependencies = bomJson.dependencies || [];
  if (!dependencies.length) {
    return;
  }
  const depMap = {};
  for (const d of dependencies) {
    if (d.dependsOn && d.dependsOn.length) {
      depMap[d.ref] = d.dependsOn;
    }
  }
  const shownList = [];
  const treeGraphics = [];
  recursePrint(depMap, dependencies, 0, shownList, treeGraphics);
  if (treeGraphics && treeGraphics.length) {
    // Patch up the last line
    treeGraphics[treeGraphics.length - 1] = treeGraphics[
      treeGraphics.length - 1
    ].replace(SYMBOLS_ANSI.BRANCH, SYMBOLS_ANSI.LAST_BRANCH);
    if (treeGraphics[treeGraphics.length - 1].includes(SYMBOLS_ANSI.VERTICAL)) {
      treeGraphics[treeGraphics.length - 1] = treeGraphics[
        treeGraphics.length - 1
      ]
        .replace(SYMBOLS_ANSI.VERTICAL, SYMBOLS_ANSI.LAST_BRANCH)
        .replace(
          SYMBOLS_ANSI.INDENT + SYMBOLS_ANSI.LAST_BRANCH,
          SYMBOLS_ANSI.LAST_BRANCH
        );
    }
  }
  const config = {
    header: {
      alignment: "center",
      content: "Dependency Tree\nGenerated with \u2665 by cdxgen"
    }
  };
  console.log(table([[treeGraphics.join("\n")]], config));
};

const levelPrefix = (level) => {
  if (level === 0) {
    return SYMBOLS_ANSI.EMPTY;
  }
  let prefix = `${SYMBOLS_ANSI.BRANCH}`;
  for (let i = 0; i < level - 1; i++) {
    prefix = `${SYMBOLS_ANSI.VERTICAL}${SYMBOLS_ANSI.INDENT}${prefix}`;
  }
  return prefix;
};

const recursePrint = (depMap, subtree, level, shownList, treeGraphics) => {
  const listToUse = Array.isArray(subtree) ? subtree : [subtree];
  for (const l of listToUse) {
    const refStr = l.ref || l;
    if (!shownList.includes(refStr.toLowerCase())) {
      shownList.push(refStr.toLowerCase());
      treeGraphics.push(`${levelPrefix(level)}${refStr}`);
      if (l && depMap[refStr]) {
        if (level < 3) {
          recursePrint(
            depMap,
            depMap[refStr],
            level + 1,
            shownList,
            treeGraphics
          );
        }
      }
    }
  }
};
