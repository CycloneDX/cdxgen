{
  "answers": [
    {
      "question": "What is Docker and how does it differ from traditional virtual machines? Explain the key benefits of using containerization in development and deployment workflows.",
      "answer": "Docker is a containerization platform that enables developers to package applications and their dependencies into lightweight, portable containers. Unlike traditional virtual machines (VMs), which run a full operating system for each instance, Docker containers share the host OS kernel. This makes them faster to start and more efficient in terms of resource usage.\n\nBenefits of containerization include: faster startup times, smaller image sizes, better isolation, improved portability, easier scaling, and simplified deployment. Containers provide a consistent environment from development to production, reducing the 'works on my machine' problem and streamlining CI/CD pipelines."
    },
    {
      "question": "How do you create a Docker image from a Dockerfile? Describe the process of building, tagging, and pushing an image to a container registry.",
      "answer": "To create a Docker image from a Dockerfile, you use the `docker build` command. This reads the instructions in the Dockerfile and creates a new image.\n\n1. **Building**: Use `docker build -t <tag> .` to build the image.\n2. **Tagging**: Use `docker tag <old-tag> <new-tag>` to add a tag to the image.\n3. **Pushing**: Use `docker push <registry>/<namespace>/<repository>:<tag>` to push the image to a registry like Docker Hub.\n\nExample: `docker build -t myapp:v1 . && docker tag myapp:v1 myregistry/myapp:v1 && docker push myregistry/myapp:v1`."
    },
    {
      "question": "What is the difference between a Docker image and a Docker container? Explain how containers are instantiated from images and their lifecycle.",
      "answer": "A Docker image is a read-only template containing the application code, runtime, libraries, and configuration files. A container is an active instance of a Docker image that runs in a specific environment.\n\nWhen you run `docker run <image>`, Docker creates a container from the image. The lifecycle of a container includes: created, running, paused, stopped, and removed states. You can start, pause, stop, or remove containers using various Docker commands."
    },
    {
      "question": "How does Docker networking work by default? Describe the bridge network and how containers communicate with each other and the host system.",
      "answer": "Docker provides a default bridge network where containers are isolated by default. Containers on the same bridge network can communicate with each other using their container names as hostnames.\n\nCommunication with the host system is possible through port mapping. By default, containers can reach the host via `host.docker.internal`. Communication between containers and the host is facilitated by the bridge network's NAT configuration."
    },
    {
      "question": "What are Docker volumes and why are they important for data persistence? Compare named volumes, bind mounts, and tmpfs mounts with examples.",
      "answer": "Docker volumes are persistent data storage mechanisms that persist beyond the lifecycle of a container. Named volumes are managed by Docker and have a specific name, while bind mounts are directories on the host system. Tmpfs mounts are stored in memory only.\n\nNamed volumes: `docker volume create myvolume`\nBind mounts: `-v /host/path:/container/path`\nTmpfs: `--mount type=tmpfs,destination=/tmp`"
    },
    {
      "question": "Explain the purpose of common Dockerfile instructions like FROM, RUN, COPY, and CMD. How do you optimize a Dockerfile for smaller image sizes?",
      "answer": "FROM: Sets the base image. RUN: Executes commands and creates layers. COPY: Copies files from host to container. CMD: Sets the default command when a container starts.\n\nTo optimize, minimize layers by combining RUN commands with `&&`, use .dockerignore, and choose lightweight base images."
    },
    {
      "question": "What are multi-stage builds in Docker and why are they useful? Provide an example of building a Go application with multi-stage Dockerfile.",
      "answer": "Multi-stage builds allow you to use multiple FROM instructions in one Dockerfile, creating a build stage and a runtime stage. This is useful for reducing the final image size by excluding build dependencies.\n\nExample: Use a Go builder image to compile code, then copy the binary to a minimal runtime image like alpine for deployment."
    },
    {
      "question": "How does Docker Compose simplify multi-container applications? Write a basic docker-compose.yml file for a web application with database.",
      "answer": "Docker Compose allows you to define and run multi-container applications using a single YAML file, simplifying orchestration. Example:\n\n```\nversion: '3'\n\nservices:\n  web:\n    build: .\n    ports:\n      - \"8000:80\"\n  db:\n    image: postgres\n    environment:\n      POSTGRES_PASSWORD: password\n```\n\nThis file defines a web service and a database service, allowing you to start both with `docker-compose up`."
    },
    {
      "question": "What is a container registry and how do you authenticate with private registries? Explain the process of pulling and pushing images to different registries.",
      "answer": "A container registry is a service that stores and distributes container images. Docker Hub is a public registry, while tools like AWS ECR, Azure ACR, or Harbor offer private registries.\n\nTo authenticate with private registries, use `docker login <registry>`. Then, you can pull images with `docker pull <registry>/<image>:<tag>` and push with `docker push <registry>/<image>:<tag>`."
    },
    {
      "question": "What security best practices should you follow when running Docker containers? Discuss user namespaces, read-only filesystems, and capability dropping.",
      "answer": "Best practices include: running containers as non-root users, using read-only filesystems for sensitive data, dropping unnecessary capabilities with `--cap-drop`, and enabling user namespaces to isolate containers from the host.\n\nUser namespaces map container users to different IDs on the host, improving security. Read-only filesystems prevent unauthorized modifications. Capability dropping limits what processes can do inside the container."
    },
    {
      "question": "What is the Open Container Initiative (OCI) and what problem does it solve? Describe the two main specifications: Image Format and Runtime Specification.",
      "answer": "OCI is an open governance structure for the container ecosystem. It solves compatibility and interoperability issues by defining industry standards.\n\nThe Image Format specification defines how container images are structured, including layers and metadata. The Runtime Specification defines how to execute a container image, standardizing behavior across different runtimes like Docker and Podman."
    },
    {
      "question": "Explain the OCI Image Format specification and its key components. How does it ensure interoperability between different container tools and platforms?",
      "answer": "OCI Image Format defines the structure of an image, including the manifest, config, and layer data. It ensures interoperability by providing a common format that different tools can read and write, guaranteeing that images built with one tool can be used by any compliant runtime."
    },
    {
      "question": "What does the OCI Runtime Specification define and why is it important? Describe how it standardizes container runtime behavior across implementations.",
      "answer": "OCI Runtime Specification defines the interface and behavior for running containers. It standardizes how container images are executed, including how to handle filesystems, networks, and process management. This ensures that containers run consistently across different tools and platforms."
    },
    {
      "question": "What is Podman and how does it differ from Docker in terms of architecture? Explain the daemonless approach and its advantages for container management.",
      "answer": "Podman is a Docker-compatible container management tool that operates without a daemon. It directly manages containers through the OCI runtime, unlike Docker which uses a client-server model with a daemon process.\n\nThe daemonless approach provides better performance, simpler deployment, and improved security by eliminating a central point of failure."
    },
    {
      "question": "Compare basic Podman commands with their Docker equivalents. How do you run, stop, and manage containers using Podman CLI?",
      "answer": "Basic commands: `docker run` vs `podman run`, `docker ps` vs `podman ps`, `docker stop` vs `podman stop`. Podman's CLI is largely compatible with Docker, allowing easy migration. You manage containers using standard lifecycle commands."
    },
    {
      "question": "What does rootless container execution mean in Podman? Explain the security benefits and potential limitations of running containers without root privileges.",
      "answer": "Rootless execution means containers run as a non-root user on the host. Benefits include improved security by limiting access to system resources. Limitations may include restricted access to certain host features and more complex networking configurations."
    },
    {
      "question": "How does Podman implement pod functionality similar to Kubernetes pods? Describe how to create and manage multi-container pods with Podman.",
      "answer": "Podman implements pod functionality using a shared namespace for multiple containers, similar to Kubernetes pods. You create a pod with `podman pod create`, then add containers to it with `podman run --pod <pod-name>`."
    }
  ]
}
