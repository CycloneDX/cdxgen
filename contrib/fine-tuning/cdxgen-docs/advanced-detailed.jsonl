{"messages": [{"role": "user", "content": "How do I exclude a specific project type, like 'js', from an SBOM scan with cdxgen?"}, {"role": "assistant", "content": "To exclude a specific project type from the Bill of Materials (BOM) generation process, you can use the `--exclude-type` argument. This command-line flag allows you to specify one or more project types that you want cdxgen to ignore during its scan. For instance, if you want to generate an SBOM for all project types present in your directory except for JavaScript (`js`), you would execute the cdxgen command with the following argument: `cdxgen --exclude-type js`.\n\nThis feature is highly useful for projects that are polyglot in nature, where you might want to focus the SBOM on a primary language or exclude secondary or test-related frameworks. You can find a full list of supported project types in the official CycloneDX documentation, which can help you fine-tune your SBOM generation to your precise needs."}]}
{"messages": [{"role": "user", "content": "Is it possible to exclude multiple project types, such as 'github' and 'dotnet', in a single cdxgen command?"}, {"role": "assistant", "content": "Yes, you can absolutely exclude multiple project types in a single cdxgen command. The `--exclude-type` argument can be used multiple times to specify each project type you wish to exclude. The tool will process all instances of this flag and remove the corresponding types from the scan.\n\nFor example, to generate an SBOM that excludes both GitHub actions (`github`) and .NET projects (`dotnet`), you would structure your command as follows: `cdxgen --exclude-type github --exclude-type dotnet`. This provides a flexible way to tailor the scope of your SBOM generation, ensuring that only the relevant components are included in the final output, which is especially helpful in complex repositories with diverse technologies."}]}
{"messages": [{"role": "user", "content": "How can I prevent cdxgen from scanning specific files or directories?"}, {"role": "assistant", "content": "You can prevent cdxgen from scanning certain files and directories by using the `--exclude` argument, which accepts a glob pattern to match the paths you want to ignore. This is particularly useful for excluding test directories, documentation, or any other non-essential files from your Software Bill of Materials (SBOM). The argument can be repeated to provide multiple exclusion patterns.\n\nFor example, to exclude a directory named `quickstarts` and all of its contents, regardless of where it appears in the project structure, you would use the following command: `cdxgen --exclude \"**/quickstarts/**\"`. The double asterisks (`**`) are a glob pattern that matches directories at any depth, making this a powerful and flexible way to control the scope of your SBOM."}]}
{"messages": [{"role": "user", "content": "Does the `--exclude` argument in cdxgen support brace expansion for defining multiple patterns?"}, {"role": "assistant", "content": "Yes, cdxgen supports brace expansion within the glob patterns provided to the `--exclude` argument. This feature allows you to define multiple, similar exclusion patterns in a more concise and readable way. Brace expansion will generate all possible string combinations from the comma-separated list inside the braces.\n\nFor instance, if you wanted to exclude both `openshift-maven-plugin` and `kubernetes-maven-plugin` directories from your scan, instead of writing two separate `--exclude` arguments, you could use brace expansion like this: `--exclude \"**/{openshift,kubernetes}-maven-plugin/**\"`. This single argument expands into two patterns (`**/openshift-maven-plugin/**` and `**/kubernetes-maven-plugin/**`), effectively excluding both directories from the SBOM generation process."}]}
{"messages": [{"role": "user", "content": "Can I filter out dependencies in a Java Maven project using its own configuration features with cdxgen?"}, {"role": "assistant", "content": "Yes, you can leverage Maven's native dependency filtering capabilities when generating an SBOM with cdxgen. This is achieved by passing specific arguments to the underlying Maven command through an environment variable. cdxgen recognizes the `MVN_ARGS` environment variable and will pass its contents directly to the `mvn dependency:tree` command it runs internally.\n\nFor example, to exclude all SNAPSHOT dependencies from your Java project's SBOM, you can use Maven's `Dexcludes` parameter. Before running cdxgen, you would set the `MVN_ARGS` environment variable like this: `export MVN_ARGS=\"-Dexcludes=:::*-SNAPSHOT\"`. When you then run cdxgen, it will use these arguments, causing Maven to filter out the snapshot dependencies before the dependency tree is even generated, resulting in a cleaner SBOM."}]}
{"messages": [{"role": "user", "content": "How do I use environment variables to filter dependencies for a Gradle project in cdxgen?"}, {"role": "assistant", "content": "Similar to Maven, you can influence the dependency resolution process for Gradle projects in cdxgen by using a specific environment variable. The `GRADLE_ARGS` environment variable allows you to pass additional arguments directly to the Gradle command that cdxgen executes to determine the project's dependencies.\n\nFor example, if you want to generate an SBOM that only includes dependencies from the `runtimeClasspath` configuration, you can set the `GRADLE_ARGS` environment variable accordingly. You would run `export GRADLE_ARGS=\"--configuration runtimeClasspath\"` in your shell before executing the `cdxgen` command. This tells cdxgen to instruct Gradle to build the dependency tree for that specific configuration, giving you more granular control over the components included in your final BOM."}]}
{"messages": [{"role": "user", "content": "What is the `--required-only` filter in cdxgen and how does it work?"}, {"role": "assistant", "content": "The `--required-only` flag is a filtering option in cdxgen that allows you to create a Software Bill of Materials (SBOM) containing only components with the `scope` attribute set to `required`. These are typically considered the direct dependencies of your project, as opposed to transitive dependencies (dependencies of your dependencies) or optional/development dependencies.\n\nWhen you use this flag, cdxgen analyzes the full dependency graph and then prunes it, retaining only the packages that are explicitly listed as required in your project's manifest file (like `pom.xml` or `package.json`). For example: `cdxgen -t java -o /tmp/bom.json -p --required-only`. This is particularly useful for use cases where you are primarily concerned with the components you have directly chosen to include. This feature is supported for several languages, including Java (Maven), Node.js, Go, and PHP."}]}
{"messages": [{"role": "user", "content": "Which languages support the `--required-only` filter in cdxgen?"}, {"role": "assistant", "content": "The `--required-only` filter, which narrows down the SBOM to include only components with a `required` scope, is supported for a specific set of languages and package managers. This functionality relies on the ability of cdxgen to reliably distinguish direct dependencies from transitive or optional ones based on the information provided by the ecosystem's tooling.\n\nCurrently, the languages and ecosystems that support the `--required-only` flag are Java with Maven, Node.js, Go, and PHP. When you use this flag with a supported project type, cdxgen will accurately identify and include only the direct dependencies in the final BOM. For other languages, this flag may not have an effect, as the concept of a 'required' scope might not be explicitly available or implemented in the respective cdxgen parser."}]}
{"messages": [{"role": "user", "content": "How can I filter SBOM components based on a string in their PURL using cdxgen?"}, {"role": "assistant", "content": "To filter components in your SBOM based on a matching string within their Package URL (purl) or their properties, you can use the `--filter` argument. This argument performs a case-insensitive search for the provided string in the component's purl and in the `value` of any `components.properties`. Since the purl includes the namespace or group ID of a component, this argument is an effective way to filter by namespace as well.\n\nFor example, if you want to generate a BOM for a Java project but only want to see components that are related to the `springframework` organization, you could use the command: `cdxgen -t java -o /tmp/bom.json -p --filter org.springframework`. This will scan the entire dependency tree and include only those components where `org.springframework` appears in the purl, effectively filtering for that specific group."}]}
{"messages": [{"role": "user", "content": "Can I use the `--filter` argument to select components from specific Gradle profiles?"}, {"role": "assistant", "content": "Yes, the `--filter` argument is versatile and can be used to filter components based on properties added by the build tool, such as Gradle profiles or configurations. When cdxgen processes a Gradle project, it can include the configuration name (like `debugAndroidTestCompileClasspath`) as a property for each component. You can then use the `--filter` argument to select only the components associated with specific configurations.\n\nFor instance, to generate an SBOM that only includes components from the `debugAndroidTestCompileClasspath` and `debugRuntimeClasspath` Gradle configurations, you would use the `--filter` argument twice: `cdxgen -t gradle -o /tmp/bom.json -p --filter debugAndroidTestCompileClasspath --filter debugRuntimeClasspath`. This command will result in a BOM containing only the dependencies from those two specified configurations."}]}
{"messages": [{"role": "user", "content": "What is the difference between the `--filter` and `--only` arguments in cdxgen?"}, {"role": "assistant", "content": "The `--filter` and `--only` arguments in cdxgen both serve to reduce the number of components in the final SBOM, but they operate differently. The `--filter` argument is a broad, case-insensitive filter that includes a component if the specified string is found in its purl OR in its properties. This can be used, for example, to include all components from a certain namespace or all components belonging to a specific build profile.\n\nIn contrast, the `--only` argument is more restrictive. It includes only those components where the specified string is found within their purl. This makes it ideal for generating SBOMs that contain exclusively first-party components or components from a single, specific vendor. For example, `--only org.springframework` would create a BOM with nothing but Spring Framework packages, whereas `--filter org.springframework` might also include other packages if they have a property containing that string."}]}
{"messages": [{"role": "user", "content": "How do I generate an SBOM that contains only my organization's 'first-party' components?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) that exclusively contains your own first-party components, you can use the `--only` argument. This flag instructs cdxgen to include only those components whose Package URL (purl) contains a specific string you provide. Typically, this string would be your organization's namespace or group ID, which is part of the purl for components you publish.\n\nFor example, if your company's packages are all under the `com.mycompany` namespace, you would run the command: `cdxgen -t java -o /tmp/bom.json -p --only com.mycompany`. This will produce an SBOM that lists only the components matching that namespace, effectively filtering out all third-party and open-source dependencies and providing a clear inventory of your proprietary software components."}]}
{"messages": [{"role": "user", "content": "How can I filter out low-confidence components from my C/C++ SBOM?"}, {"role": "assistant", "content": "You can filter components based on the confidence of their identification by using the `--min-confidence` argument. This feature is particularly useful for C/C++ projects, where component identification can sometimes be ambiguous and result in low-confidence matches. The argument takes a decimal value between 0 and 1, representing the minimum confidence score a component must have to be included in the final BOM.\n\nc-dxgen determines a component's confidence by looking at the `evidence.identity` field for an entry where `field=purl` and finding the maximum `confidence` value associated with it. To filter out all components with zero confidence, which can be common in C/C++ scans, you can set a small minimum value. For example: `cdxgen -t c . --min-confidence 0.1`. Be aware that this could potentially filter out valid components that were simply hard to identify, so it should be used with an understanding of your project's context."}]}
{"messages": [{"role": "user", "content": "What does the `--technique` argument do in cdxgen?"}, {"role": "assistant", "content": "The `--technique` argument allows you to control which analysis techniques cdxgen is permitted to use when generating a Bill of Materials. By default, cdxgen uses an `auto` mode where it employs a variety of techniques (like source code analysis, manifest analysis, binary analysis, etc.) to discover components. This argument gives you the ability to restrict the scan to a specific subset of these techniques.\n\nFor example, if you only want to rely on package manager manifests and ignore other discovery methods, you could run the command: `cdxgen -t c . --technique manifest-analysis`. You can also specify multiple allowed techniques by repeating the argument, such as `--technique manifest-analysis --technique source-code-analysis`. It is important to note that this is currently implemented as a post-processing filter, meaning cdxgen still performs all analyses and then filters the results, so using this argument is unlikely to provide a performance benefit."}]}
{"messages": [{"role": "user", "content": "What are 'automatic compositions' in cdxgen and when are they used?"}, {"role": "assistant", "content": "Automatic compositions refer to a feature in cdxgen where it automatically modifies the `compositions.aggregate` property in the generated CycloneDX BOM. This property is used to indicate the completeness of the component list. cdxgen will automatically set this property whenever you use any of the filtering arguments, such as `--filter`, `--only`, `--required-only`, or `--exclude`.\n\nWhen a filter is applied, the resulting SBOM is, by definition, not a complete representation of all dependencies. To reflect this, cdxgen sets the `compositions.aggregate` value to `incomplete`. If you use the `--only` flag, which is often used to isolate first-party components, cdxgen will set the value to `incomplete_first_party_only`. This ensures that any tool or person consuming the SBOM is aware that the list of components has been intentionally filtered and may not be exhaustive."}]}
{"messages": [{"role": "user", "content": "How can I disable the automatic setting of the 'compositions.aggregate' property in cdxgen?"}, {"role": "assistant", "content": "If you are using filtering options but do not want cdxgen to automatically modify the `compositions.aggregate` property in your SBOM, you can disable this behavior. To do so, you need to pass the `--no-auto-compositions` flag in your command.\n\nThis flag tells cdxgen to skip the step where it would normally set `compositions.aggregate` to `incomplete` or `incomplete_first_party_only` when filters are active. You might use this option if you are performing filtering for a specific internal purpose and you have a different mechanism for communicating the completeness of the BOM, or if you intend to manually set the composition properties later. For example: `cdxgen --filter some.package --no-auto-compositions ...`."}]}
{"messages": [{"role": "user", "content": "Can I configure cdxgen using a file instead of command-line arguments?"}, {"role": "assistant", "content": "Yes, you can configure cdxgen using configuration files, which is a convenient way to manage complex configurations and avoid long command-line strings. This is especially useful for standardizing SBOM generation settings across different projects or environments. cdxgen supports configuration files in both JSON and YAML formats.\n\nThe tool looks for specific file names in the directory where it is run. For JSON format, it will look for `.cdxgenrc` or `.cdxgen.json`. For YAML format, it will look for `.cdxgen.yml` or `.cdxgen.yaml`. You can place any of the command-line arguments into these files. For example, a `.cdxgen.yml` file could contain `type: java` and `output: bom.json` to set the project type and output file name."}]}
{"messages": [{"role": "user", "content": "What is the order of precedence for configuration options in cdxgen?"}, {"role": "assistant", "content": "cdxgen uses a clear hierarchy to determine which configuration value to use when a setting is defined in multiple places. This ensures predictable behavior and allows you to override general settings with more specific ones. The order of precedence is as follows: Command-line arguments have the highest priority, followed by Environment variables, and finally Configuration files.\n\nThis means that a value you pass directly on the command line (e.g., `--output bom-cli.json`) will always take precedence over a value set in an environment variable (e.g., `export CDXGEN_OUTPUT=bom-env.json`) or in a configuration file (e.g., `output: bom-file.json` in `.cdxgen.yml`). Similarly, an environment variable will override a value from a configuration file. Among configuration files, JSON files (`.cdxgenrc`, `.cdxgen.json`) are read before YAML files (`.cdxgen.yml`, `.cdxgen.yaml`)."}]}
{"messages": [{"role": "user", "content": "How can I use environment variables to configure cdxgen?"}, {"role": "assistant", "content": "You can configure cdxgen using environment variables for any of its command-line arguments. This provides a flexible way to set up your environment for SBOM generation, especially in CI/CD pipelines where setting environment variables is common practice. To convert a command-line argument to an environment variable, you simply prefix the argument name with `CDXGEN_` and use uppercase letters.\n\nFor example, the command-line argument `--project-name foo` can be replaced by setting an environment variable: `export CDXGEN_PROJECT_NAME=foo`. Similarly, `--type java` becomes `export CDXGEN_TYPE=java`. These environment variables will be automatically picked up by cdxgen when it runs. It's important to remember that environment variables will override any settings found in configuration files but will be overridden by settings passed directly on the command line."}]}
{"messages": [{"role": "user", "content": "What is Evinse mode and how is it activated in cdxgen?"}, {"role": "assistant", "content": "Evinse (Evinse Verification Is Nearly SBOM Evidence) refers to a powerful feature within cdxgen for generating a more comprehensive type of SBOM that includes detailed evidence of component usage. This is sometimes referred to as a SaaSBOM (Software as a Service BOM). Instead of just listing dependencies, an evidence-based SBOM can show where and how a component is used in the source code, providing proof of its presence through code analysis.\n\nStarting with cdxgen version 9.9.x, this advanced capability is integrated directly into the main tool and can be activated using the `--evidence` argument. When you run `cdxgen --evidence .`, it invokes the underlying `evinse` tool (which is powered by the `atom` code analysis engine) to perform a deep analysis of the source code and enrich the generated SBOM with occurrence and callstack evidence for the discovered components."}]}
{"messages": [{"role": "user", "content": "What are the prerequisites for using the evinse tool to generate evidence for an SBOM?"}, {"role": "assistant", "content": "To use the `evinse` tool for generating an SBOM with detailed component evidence, you need to have a few prerequisites in place. First and foremost, you must have Java version 21 or higher installed on your system, as the underlying analysis engine, `atom`, is a Java application. Second, you need the complete source code of the application you wish to analyze.\n\nFinally, `evinse` does not generate the initial list of components itself; it enriches an existing SBOM. Therefore, you must first have an input SBOM in CycloneDX format (version 1.5 or newer). Typically, you would use cdxgen itself to generate this initial SBOM from your project's source code. Once these three things—Java >21, the application source code, and a base CycloneDX SBOM—are ready, you can run `evinse` to analyze the code and add the evidence details to a new output SBOM file."}]}
{"messages": [{"role": "user", "content": "How do I generate reachability-based call stack evidence using evinse?"}, {"role": "assistant", "content": "Generating reachability-based call stack evidence with `evinse` provides deep insight into how your application actually invokes code from external libraries. This technique, known as Forward-Reachability, traces data flows from entry points (sources) in your code to calls into third-party library functions (sinks). To use this feature, there are two key prerequisites.\n\nFirst, the input SBOM must have been generated by cdxgen using the `--deep` flag (this applies to Java, jar, and Python types). The deep mode gathers extra information necessary for the analysis. Second, you must run the command from within the application's root directory. The command itself combines the cdxgen and evinse steps: `cdxgen -t java --deep -o bom.json --evidence .`. The `--evidence` flag triggers the `evinse` tool, which will then automatically perform the reachability analysis and embed the call stack evidence into the final SBOM."}]}
{"messages": [{"role": "user", "content": "When should I use data flow-based call stack evidence instead of reachability-based?"}, {"role": "assistant", "content": "You should consider using data flow-based call stack evidence when the standard reachability analysis is insufficient or unreliable. Standard Forward-Reachability traces from known entry points (sources) to library calls (sinks). However, this can fail if the project being analyzed is a library or module that doesn't have its own entry points, or if complex wrapper libraries obscure the direct call paths.\n\nIn these scenarios, data flow-based slicing, which uses a Reverse-Reachability algorithm, can be more effective. It starts from the library calls (sinks) and works backward to find any code paths that lead to them. This is a more exhaustive and resource-intensive operation, but it can uncover call stacks that forward reachability might miss. To use this method, you would pass the `--with-data-flow` flag to evinse, for example: `evinse -i bom.json -o bom.evinse.json --with-data-flow <path to app>`."}]}
{"messages": [{"role": "user", "content": "How can I improve the performance of evinse when generating evidence?"}, {"role": "assistant", "content": "The evidence generation process, especially for data flow-based call stacks, can be time-consuming. To improve performance on subsequent runs, `evinse` allows you to cache the results of its code slicing analysis. The key is to save the generated slices to files so they can be reused later without needing to re-analyze the entire codebase.\n\nYou can achieve this by using the `--usages-slices-file`, `--data-flow-slices-file`, and `--reachables-slices-file` arguments to specify output files for the different types of analysis. For example, on the first run, you might use: `evinse ... --usages-slices-file usages.json --with-data-flow --data-flow-slices-file data-flow.json <path>`. On subsequent runs for the same codebase, `evinse` will detect these files and use the cached slices, significantly speeding up the process."}]}
{"messages": [{"role": "user", "content": "Can I generate an SBOM directly from my local Maven or Gradle cache?"}, {"role": "assistant", "content": "Yes, cdxgen has a powerful feature that allows you to generate a Software Bill of Materials (SBOM) by scanning your local Maven (`.m2`) or Gradle (`.gradle/caches`) cache directories. This is useful for cataloging all the Java dependencies that have been downloaded on your machine, or for analyzing applications with very complex build processes where running a standard build might be difficult.\n\nWhen you point cdxgen at a cache directory, it will parse the artifacts it finds and generate a comprehensive SBOM. A significant bonus of this mode is that the resulting SBOM will be enriched with a property called `Namespaces` for each component. This property contains a list of the Java class names found within that component's JAR file, providing a much deeper level of detail than a standard SBOM."}]}
{"messages": [{"role": "user", "content": "After generating an SBOM from my Maven cache, how can I find out which dependencies are actually used by my application?"}, {"role": "assistant", "content": "Generating an SBOM from your Maven cache will give you a list of every dependency you've ever downloaded, but it won't tell you which ones are relevant to a specific project. To bridge this gap, you can use the `evinse` tool. The process involves two steps: first, generate the SBOM from the cache, and second, run `evinse` to find evidence of usage within your specific application's source code.\n\nAfter creating the cache-based BOM (e.g., `bom-from-cache.json`), you would compile your application and then run `evinse`, providing the cache-BOM as input and your application's path as the target for analysis: `evinse -i bom-from-cache.json -o bom.evinse.json <application path>`. Evinse will scan your application's code and compare it against the components in the input BOM. It will then populate the `component.evidence` field for any component it finds being used. Components without evidence can be considered either transitive or completely unused in that specific project."}]}
{"messages": [{"role": "user", "content": "My Java project uses both Maven and Gradle. How does cdxgen decide which to use?"}, {"role": "assistant", "content": "When cdxgen detects a Java project that contains configuration files for both Maven (`pom.xml`) and Gradle (`build.gradle`), it has to choose one build system to analyze for dependencies. By default, cdxgen will prioritize Maven over Gradle. This means that if a `pom.xml` file is present in the project root, it will be used to generate the dependency tree, and the Gradle configuration will be ignored.\n\nThis default behavior is designed to provide a consistent outcome in mixed-project scenarios. However, if your project primarily uses Gradle and the `pom.xml` is for a secondary purpose, you will need to override this default. You can do this by explicitly telling cdxgen which project type to use with the `-t` or `--type` flag. To force it to use Gradle, you would run `cdxgen -t gradle`."}]}
{"messages": [{"role": "user", "content": "How can I force cdxgen to use Gradle in a mixed Java project that also has a pom.xml file?"}, {"role": "assistant", "content": "In a Java project that contains build files for both Maven (`pom.xml`) and Gradle (`build.gradle`), cdxgen defaults to using Maven for dependency analysis. If you want to force cdxgen to use Gradle instead, you must explicitly specify the project type using the `-t` (or `--type`) command-line argument.\n\nTo ensure Gradle is used for SBOM generation, you would execute the command with the `gradle` type specified, like this: `cdxgen -t gradle`. This overrides the default selection logic and directs cdxgen to parse the `build.gradle` file and use the Gradle toolchain to resolve the project's dependencies. Similarly, if you had a Scala project using SBT, you would use `-t scala` to ensure the correct build tool is invoked."}]}
{"messages": [{"role": "user", "content": "Is it possible to generate an SBOM for a Linux container image while working on a Windows machine?"}, {"role": "assistant", "content": "Yes, cdxgen supports generating a Software Bill of Materials (SBOM) for Linux-based container images even when you are running on a Windows operating system. This cross-platform capability requires a specific setup to work correctly, involving Docker for Desktop and ensuring the right permissions are in place.\n\nThe key steps are: first, ensure you have `cdxgen-plugins-bin` version 1.4.0 or newer installed globally via npm. Second, you must configure Docker for Desktop to expose its daemon on a TCP port without TLS. Third, and critically, you must run your terminal (e.g., PowerShell) as an administrator. This is because extracting container layers can involve creating symbolic links, which requires elevated privileges on Windows. Once this setup is complete, you can run cdxgen with the docker type, for example: `cdxgen -t docker -o bom.json my-linux-image:latest`."}]}
{"messages": [{"role": "user", "content": "When should I consider using Atom in 'Java mode' separately from cdxgen?"}, {"role": "assistant", "content": "You should consider using Atom, the underlying analysis engine for `evinse`, in its standalone 'Java mode' when you are working with extremely large codebases. The integrated `evinse` tool within cdxgen is sufficient for most projects, but for projects exceeding a million lines of code, the resource requirements (especially memory) can become very high. Running Atom as a separate process allows you to allocate significantly more memory to the analysis task than might be available in the default Node.js environment where cdxgen runs.\n\nFor example, analyzing the Linux kernel source code with Atom can require a minimum of 128GB of RAM. To handle such a case, you would download the `atom.zip` release, and invoke it directly from the command line, specifying a large Java heap size (e.g., `./atom -J-Xmx16g ...`). After Atom completes its slicing operation and generates a slices file, you can then feed this file back into cdxgen using the `--usages-slices-file` argument to generate the final SBOM."}]}
{"messages": [{"role": "user", "content": "The component namespaces in my evinse-generated SBOM seem outdated. How can I fix this?"}, {"role": "assistant", "content": "If you suspect that the component namespaces cached by `evinse` are outdated or incorrect, the most effective solution is to force it to recreate its cache. The `evinse` tool uses a local SQLite database file named `.atomdb` to store information it has gathered about components, such as the class names within a JAR file. Deleting this file will cause `evinse` to rebuild the cache from scratch on its next run.\n\nThe location of the `.atomdb` file varies by operating system. On Linux, it's typically at `~/.local/share/.atomdb`. On Windows, you'll find it at `~/AppData/Local/.atomdb`, and on macOS, it's located at `~/Library/Application Support/.atomdb`. You can also override this default location by setting the `ATOM_DB` environment variable. By deleting this file, you ensure that the next analysis will be based on fresh data."}]}
{"messages": [{"role": "user", "content": "How can I customize the author metadata in the BOM generated by cdxgen?"}, {"role": "assistant", "content": "You can customize the author information in the `metadata.authors` section of your CycloneDX BOM by using the `--author` command-line argument. This allows you to specify the name of the person or organization that created the component being described by the SBOM. If the author's name contains spaces, you must enclose it in double quotes.\n\nFurthermore, the `--author` argument can be repeated to list multiple authors. This is useful for projects with multiple significant contributors or when attributing work to different foundations or companies. For example, to list both the OWASP Foundation and the Apache Foundation as authors, you would use the following command structure: `cdxgen --author \"OWASP Foundation\" --author \"Apache Foundation\" -t java ...`. The resulting BOM will contain an `authors` array with an entry for each name you provided."}]}
{"messages": [{"role": "user", "content": "How do I set up command-line completion for cdxgen in my zsh or bash shell?"}, {"role": "assistant", "content": "To make using cdxgen and its related tools more efficient, you can enable command-line completion, which provides suggestions for commands and arguments as you type. The cdxgen executable has a built-in command to generate the necessary completion script for your shell. You simply need to run the tool with `completion` as the argument and redirect the output to your shell's configuration file.\n\nFor a zsh shell, you would run the command: `cdxgen completion >> ~/.zshrc`. For a bash shell, the command would be `cdxgen completion >> ~/.bashrc`. After appending the script to your configuration file, you will need to restart your shell or source the file (e.g., `source ~/.zshrc`) for the changes to take effect. You can do the same for the `evinse` tool by running `evinse completion >> ~/.zshrc`."}]}
{"messages": [{"role": "user", "content": "What are BOM Profiles in cdxgen and what is the 'appsec' profile for?"}, {"role": "assistant", "content": "BOM Profiles in cdxgen are pre-configured sets of options designed to generate a Bill of Materials that is optimized for a specific use case or purpose. Instead of manually setting multiple flags, you can select a profile that automatically enables the relevant configurations. The default profile is `generic`, which provides a standard SBOM.\n\nThe `appsec` profile is specifically tailored for Application Security and vulnerability management. When you use this profile, cdxgen automatically enables deep mode scanning. Deep mode gathers more detailed information about dependencies, which is crucial for security tools that need to perform accurate vulnerability matching. This profile streamlines the process of creating a high-fidelity SBOM that can be effectively consumed by security scanning and analysis platforms."}]}
{"messages": [{"role": "user", "content": "What is the 'research' BOM profile in cdxgen?"}, {"role": "assistant", "content": "The `research` BOM profile is a specialized configuration in cdxgen designed for security researchers or anyone needing the most comprehensive and detailed SBOM possible. This profile enables a combination of advanced features to maximize the data collected during the scan.\n\nWhen you select the `research` profile, it automatically enables both deep mode (`--deep`) and evidence mode (`--evidence`). This means the generated BOM will not only have a detailed dependency graph but will also be enriched with evidence of how those components are used in the code. Additionally, for JavaScript/TypeScript projects, this profile disables the default behavior of ignoring certain directories (like `node_modules`), forcing a more exhaustive scan. The result is an extremely detailed SBOM, perfect for in-depth analysis and security research."}]}
{"messages": [{"role": "user", "content": "How does cdxgen handle BOM lifecycle phases like 'pre-build' or 'post-build'?"}, {"role": "assistant", "content": "cdxgen aligns its SBOM generation with the lifecycle phases defined in the CycloneDX specification, such as `build`, `pre-build`, and `post-build`. By default, when scanning application source code, cdxgen attempts to generate a BOM for the `build` lifecycle phase, which typically involves resolving and installing dependencies. For container images, the default is the `post-build` phase.\n\nYou can control this behavior. To generate a `pre-build` BOM, which represents the state of dependencies before compilation or installation, you can use the `--no-install-deps` argument with certain languages like Python. This prevents cdxgen from installing packages and instead relies solely on the manifest file. Conversely, you can explicitly request a `post-build` BOM by using the `--lifecycle post-build` argument. This is useful for analyzing compiled artifacts like Android APKs, .NET binaries, or Go binaries, where the dependencies are already bundled or linked."}]}
{"messages": [{"role": "user", "content": "My project uses an older version of the .NET SDK. How can I generate an SBOM for it using cdxgen?"}, {"role": "assistant", "content": "Generating a complete SBOM for .NET projects, especially older ones, often requires the `dotnet restore` command to be run successfully, which in turn requires the correct .NET SDK version. While the default cdxgen container image bundles a recent SDK (e.g., version 8.0), it may not be compatible with your legacy project. To address this, the CycloneDX team provides custom container images that bundle specific, older versions of the SDK.\n\nFor example, if your project requires .NET Core 3.1 or .NET 6.0, you can use a specialized image like `ghcr.io/cyclonedx/cdxgen-dotnet:v12`. You would invoke Docker with this image instead of the default one: `docker run ... ghcr.io/cyclonedx/cdxgen-dotnet:v12 -r /app -o bom.json -t dotnet`. For even older projects targeting the .NET Framework (e.g., 4.6/4.7), a Windows build environment is required. A practical workaround is to commit the `project.assets.json` file generated on a Windows machine to your repository, which allows cdxgen on Linux to then parse the dependency information without needing to run `dotnet restore`."}]}
{"messages": [{"role": "user", "content": "How do I generate an SBOM for a legacy Java project that requires Java 11?"}, {"role": "assistant", "content": "To generate an SBOM for a legacy Java project that specifically requires an older JDK version like Java 11, you have a couple of options with cdxgen. The standard cdxgen environment might use a newer JDK, which could cause build or dependency resolution failures with your project. The recommended approach is to use a custom container image that comes pre-packaged with the required Java version.\n\nThe CycloneDX project provides several Java-specific images. For a project requiring Java 11, you could use the `ghcr.io/cyclonedx/cdxgen-java11:v12` image. Alternatively, if you are running cdxgen CLI directly on a machine where you have multiple JDKs managed by a tool like `sdkman`, you can use the type argument `-t java11`. This command, `cdxgen -t java11`, signals to cdxgen that it should attempt to use a Java 11 environment to process the project. This relies on `sdkman` being installed and correctly configured to find and switch to the specified Java version."}]}
{"messages": [{"role": "user", "content": "What is Nydus and how does it relate to cdxgen container images?"}, {"role": "assistant", "content": "Nydus is a next-generation container image format developed to improve upon the standard OCI (Open Container Initiative) specification. Its main goals are to significantly improve container startup times, reduce the amount of storage space and network bandwidth consumed by images, and enhance data integrity. It achieves this through techniques like lazy pulling and on-demand loading of image data.\n\nTo allow users to benefit from these performance improvements, the cdxgen project provides its container images in the Nydus format in addition to the standard OCI format. These images can be identified by the `-nydus` suffix in their tag, for example: `ghcr.io/cyclonedx/cdxgen:master-nydus`. When used with a container runtime that supports the Nydus snapshotter, like `nerdctl`, you can experience faster cdxgen startup times, which is particularly beneficial in CI/CD environments where new containers are frequently created."}]}
{"messages": [{"role": "user", "content": "How can I export a cdxgen SBOM as a binary protobuf file?"}, {"role": "assistant", "content": "In addition to the standard JSON output, cdxgen provides the capability to export the generated Bill of Materials (BOM) in a binary protobuf (Protocol Buffers) format. Protobuf is a binary serialization format that is often more compact and efficient to parse than JSON, making it suitable for high-performance systems or for reducing storage and transmission overhead.\n\nTo enable this export format, you need to use the `--export-proto` argument. You will also typically specify the output file name for the binary BOM using the `--proto-bin-file` argument. It is important to note that this feature currently only supports exporting BOMs that conform to version 1.5 of the CycloneDX specification. An example command would be: `cdxgen ... --export-proto --proto-bin-file bom.cdx.bin`."}]}
{"messages": [{"role": "user", "content": "What is the '--include-formulation' argument used for in cdxgen?"}, {"role": "assistant", "content": "The `--include-formulation` argument is an advanced feature in cdxgen that enriches the generated SBOM with detailed information about the build environment and source code state. When this flag is used, cdxgen collects extensive metadata and includes it in a `formulation` section within the BOM. This section provides a comprehensive snapshot of how the software was created.\n\nThe information collected includes git metadata, such as the remote origin URL, the current branch, and a list of all files in the git tree with their corresponding hashes. It also captures the versions of build tools detected on the system, such as Java, Python, Node.js, gcc, dotnet, and rustc. This level of detail is extremely valuable for traceability and reproducibility, as it documents the precise context in which the SBOM was generated."}]}
{"messages": [{"role": "user", "content": "How can I generate a Cryptography Bill of Materials (CBOM) with cdxgen?"}, {"role": "assistant", "content": "You can generate a Cryptography Bill of Materials (CBOM) using cdxgen by leveraging a convenient alias command: `cbom`. A CBOM is a specialized type of SBOM that focuses on identifying cryptographic assets and algorithms used within a piece of software. This is crucial for security audits, compliance with crypto policies, and post-quantum readiness assessments.\n\nThe `cbom` alias simplifies the process by automatically setting several flags required for a comprehensive CBOM. When you run `cbom -t java`, it is equivalent to running `cdxgen -t java --include-crypto --include-formulation --evidence --spec-version 1.6`. These flags instruct cdxgen to include cryptographic details, add build formulation data, gather evidence of usage, and use the appropriate CycloneDX specification version (1.6) which has enhanced support for cryptography. This feature is currently supported for Java and Python projects."}]}
{"messages": [{"role": "user", "content": "Why are there so many different cdxgen container images available?"}, {"role": "assistant", "content": "The cdxgen project provides a wide variety of container images to cater to the diverse needs of different programming languages, frameworks, and build environments. A single, all-in-one image would be enormous and inefficient. Instead, specialized images are created that include the specific build tools and development libraries required for a given ecosystem. This ensures that cdxgen can perform its tasks, like automatically restoring dependencies, without requiring the user to pre-install these tools.\n\nFor example, to accurately generate an SBOM for a .NET 8 project, the container needs the .NET 8 SDK. Therefore, an image like `ghcr.io/cyclonedx/cdxgen-dotnet8:v12` is provided. Similarly, there are images with specific versions of Java (8, 11, 17, 21), Python (3.6, 3.9, 3.10, etc.), Ruby, Go, and more. This approach allows users to select a lean, optimized image that perfectly matches their project's technology stack, leading to more reliable and efficient SBOM generation."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `ghcr.io/cyclonedx/cdxgen-secure:master` container image?"}, {"role": "assistant", "content": "The `ghcr.io/cyclonedx/cdxgen-secure:master` container image is a version of the all-in-one cdxgen image that is configured to run with enhanced security by default. Modern runtimes like Node.js are introducing permission models to restrict a program's access to the filesystem, network, and other system resources, helping to mitigate the impact of potential supply chain attacks.\n\nThe `cdxgen-secure:master` image is built with the Node.js permissions model enabled by default. This means that when you run cdxgen using this image, its operations are more restricted, providing an additional layer of security. This is in contrast to the standard `ghcr.io/cyclonedx/cdxgen:master` image, where the permission model is opt-in. The secure image is intended for users in high-security environments who want to apply the principle of least privilege to their SBOM generation process."}]}
{"messages": [{"role": "user", "content": "I am working on a macOS machine with Rancher Desktop. Is this setup supported for running cdxgen?"}, {"role": "assistant", "content": "Yes, using Rancher Desktop on macOS is a supported environment for running cdxgen. Rancher Desktop is a container management application that can use `nerdctl` as its command-line interface, providing an alternative to Docker Desktop. The cdxgen documentation explicitly mentions that Rancher Desktop on macOS with `nerdctl` is supported by default.\n\nThis means you can pull and run the cdxgen container images using `nerdctl` commands in your terminal on macOS, just as you would with `docker` on other platforms. This support ensures that macOS users who prefer Rancher Desktop for their container workflow can seamlessly integrate cdxgen for SBOM generation without compatibility issues."}]}
{"messages": [{"role": "user", "content": "How do I exclude a directory and its subdirectories using a glob pattern in cdxgen?"}, {"role": "assistant", "content": "To exclude a specific directory and all of its subdirectories and files from an SBOM scan, you should use the `--exclude` argument with a glob pattern that matches recursively. The key to recursive matching in a glob pattern is the double-asterisk (`**`).\n\nFor example, if you have a directory named `test-data` in your project and you want to ensure that neither this directory nor any of its contents are included in the SBOM, you would use the following pattern: `\"**/test-data/**\"`. The initial `**/` matches the `test-data` directory at any depth within your project structure, and the trailing `/**` ensures that all files and subdirectories within `test-data` are also matched and excluded. This provides a comprehensive way to ignore specific parts of your repository."}]}
{"messages": [{"role": "user", "content": "What happens if I use a filter like `--filter` or `--only` in cdxgen?"}, {"role": "assistant", "content": "When you use a filtering argument like `--filter` or `--only` with cdxgen, you are instructing the tool to produce an incomplete or partial Software Bill of Materials (SBOM). These flags are designed to help you create a focused BOM that includes only a subset of the project's total components, based on the criteria you specify.\n\nAs a result of this filtering, cdxgen automatically signals that the BOM is not a complete representation of all dependencies. It does this by setting the `compositions.aggregate` property in the CycloneDX metadata. For most filters, this property will be set to `incomplete`. If you use the `--only` flag, which is often used for isolating first-party components, the property will be set to `incomplete_first_party_only`. This is a critical feature that ensures consumers of the SBOM are aware that it has been intentionally curated and is not exhaustive."}]}
{"messages": [{"role": "user", "content": "Show me an example of a JSON configuration file for cdxgen."}, {"role": "assistant", "content": "You can configure cdxgen using a JSON file named `.cdxgenrc` or `.cdxgen.json` in your project's root directory. This file allows you to specify any of the command-line arguments in a structured JSON format, which can be easier to manage and version control than long command strings. The keys in the JSON object correspond to the long-form argument names.\n\nHere is an example of a simple `.cdxgenrc` file that sets the project type to `java`, directs the output to a file named `bom.json`, and enables printing the BOM as a table to the console:\n```json\n{\n  \"type\": \"java\",\n  \"print\": true,\n  \"output\": \"bom.json\"\n}\n```\nWhen you run `cdxgen` in the same directory as this file, it will automatically apply these settings."}]}
{"messages": [{"role": "user", "content": "Show me an example of a YAML configuration file for cdxgen."}, {"role": "assistant", "content": "You can use a YAML file to configure cdxgen's behavior, which some users find more readable than JSON. cdxgen will automatically detect and use configuration files named `.cdxgen.yml` or `.cdxgen.yaml` in the directory it is run from. The keys in the YAML file correspond to the long-form command-line arguments.\n\nHere is an example of a `.cdxgen.yml` file that configures cdxgen to scan a `java` project, print the output as a table, save the BOM to `bom.json`, and include only components from the `org.springframework` namespace:\n```yaml\n# Set the project type to Java\ntype: java\n\n# Print the BOM as a table and tree to the console\nprint: true\n\n# Set the output file name for the SBOM\noutput: bom.json\n\n# Only include components whose purl contains this string\nonly: org.springframework\n```\nThis approach helps maintain a clean and documented configuration for your SBOM generation process."}]}
{"messages": [{"role": "user", "content": "What kind of evidence does `evinse` generate by default, and how do I get more detailed evidence?"}, {"role": "assistant", "content": "By default, when you use `evinse` (or the `--evidence` flag in cdxgen), it generates occurrence evidence. This type of evidence identifies where components (e.g., classes from a third-party library) are mentioned or used within your application's source code. It essentially confirms the presence of a component by finding direct references to it, which is done by creating usages slices.\n\nTo get more detailed evidence, such as call stacks, you need to explicitly enable more advanced analysis techniques. You can generate call stack evidence, which shows the complete path from your code to a function in an external library, by passing either the `--with-reachables` or `--with-data-flow` flag to `evinse`. These flags trigger much deeper code analysis to trace execution paths, providing stronger proof of how a dependency is actively being used, not just that it is present."}]}
{"messages": [{"role": "user", "content": "Can `evinse` analyze JavaScript and Python projects for evidence?"}, {"role": "assistant", "content": "Yes, the `evinse` tool is not limited to Java and can be used to generate component evidence for several other languages, including JavaScript, TypeScript, and Python. The core functionality of analyzing source code to find proof of component usage is supported across these ecosystems. You need to specify the correct language using the `-l` or `--language` argument.\n\nFor example, to analyze a JavaScript project and generate call stack evidence using the reachability method, you would run a command like: `evinse -i bom.json -o bom.evinse.json -l js --with-reachables .`. Similarly, for a Python project, you would use `-l python`. This multi-language support makes `evinse` a versatile tool for creating high-assurance SBOMs across different parts of your technology stack."}]}
{"messages": [{"role": "user", "content": "What is the Lima VM and how does it relate to cdxgen?"}, {"role": "assistant", "content": "Lima is a tool that provides Linux virtual machines on macOS, essentially offering a way to run a Linux environment with minimal overhead. It's often used as a backend for container management tools like Rancher Desktop and `nerdctl`. The cdxgen documentation mentions Lima to inform users about its compatibility with these environments.\n\nThe `ADVANCED.md` file contains a dedicated section titled Lima VM usage which links to a more detailed README file in the project's repository. This indicates that the cdxgen team has considered and documented the process for users who are running cdxgen within a Lima-based VM setup on their macOS machines. Essentially, if your container environment on macOS is powered by Lima, cdxgen is expected to work correctly within it."}]}
{"messages": [{"role": "user", "content": "What does the `cbom` alias do when generating a Cryptography Bill of Materials?"}, {"role": "assistant", "content": "The `cbom` alias is a convenient shortcut provided by cdxgen to simplify the generation of a Cryptography Bill of Materials. Instead of requiring you to remember and type out multiple command-line flags, the alias bundles them together to produce a comprehensive CBOM with a single command. It's designed to provide a rich, detailed output suitable for cryptographic analysis.\n\nWhen you use the `cbom` alias, it automatically sets the following four options for you. First, `--include-crypto` is set to `true` to enable the discovery of cryptographic algorithms and assets. Second, `--include-formulation` is set to `true` to add detailed build and environment metadata. Third, `--evidence` is set to `true` to collect proof of component usage. Finally, `--spec-version` is set to `1.6`, as this version of the CycloneDX specification includes dedicated support for cryptographic information."}]}
{"messages": [{"role": "user", "content": "How do I ensure I'm using a specific, stable version of a cdxgen container image?"}, {"role": "assistant", "content": "To ensure you are using a specific, stable version of a cdxgen container image, you should avoid using floating tags like `master` or `latest`. Instead, you should specify a fixed version tag or, for maximum immutability, a sha256 digest hash. The cdxgen documentation provides a table of available images, many of which include a versioned tag like `:v12`.\n\nFor fine-grained control and to guarantee that you are always using the exact same image, you should replace a tag like `:v12` with a specific release version tag (e.g., `:9.9.5`) or the image's sha256 hash. You can find the specific tags and digests on the container registry page, such as on GitHub Container Registry (ghcr.io). For example, instead of `ghcr.io/cyclonedx/cdxgen-java11:v12`, you might use `ghcr.io/cyclonedx/cdxgen-java11:9.9.5` or `ghcr.io/cyclonedx/cdxgen-java11@sha256:...`. This practice is crucial for creating reproducible builds in a CI/CD pipeline."}]}
{"messages": [{"role": "user", "content": "I need to generate an SBOM for a project using Ruby 2.6. Is there a cdxgen container image for this?"}, {"role": "assistant", "content": "Yes, the cdxgen project provides specialized container images for various versions of Ruby to accommodate projects with specific runtime requirements. For a project that needs Ruby 2.6.x, you can use the `ghcr.io/cyclonedx/cdxgen-debian-ruby26:v12` container image.\n\nThis image comes with the necessary Ruby 2.6 environment and build tools pre-installed. A notable feature of this and other Ruby images is that they support automatic installation of a specific patch version of Ruby. For example, if you need to ensure Ruby 2.6.1 is used, you can pass the argument `-t ruby2.6.1` to cdxgen when running it inside this container. The image will then attempt to install and use that precise version for the dependency analysis, ensuring the highest level of accuracy for your project's SBOM."}]}
{"messages": [{"role": "user", "content": "How can I get a list of supported analysis techniques in cdxgen?"}, {"role": "assistant", "content": "The documentation for cdxgen's advanced features lists the supported analysis techniques that you can specify with the `--technique` argument. This argument gives you control over the methods cdxgen uses to discover software components, which can be useful for tailoring the scan to your specific needs or for experimentation.\n\nThe list of supported techniques includes: `auto` (the default, which enables all applicable techniques), `source-code-analysis` (analyzing source files directly), `binary-analysis` (inspecting compiled artifacts), `manifest-analysis` (parsing package manager files like pom.xml or package.json), `hash-comparison` (matching file hashes against known component databases), `instrumentation` (observing dependencies at runtime), and `filename` (identifying components based on file names). You can select one or more of these to restrict the scope of the analysis."}]}
{"messages": [{"role": "user", "content": "I need to generate an SBOM for a container image. What is the default lifecycle phase cdxgen uses?"}, {"role": "assistant", "content": "When cdxgen generates a Software Bill of Materials (SBOM) for a container image, it defaults to assigning the `post-build` lifecycle phase to the metadata. This is the logical choice because a container image is a finished artifact that exists after all the build, compilation, and packaging steps have been completed.\n\nThe `post-build` phase, as defined by the CycloneDX specification, signifies that the BOM describes the composition of the software in its final, deployable state. This is distinct from the `build` phase, which is the default for application source code scans, as that typically represents the state of the software and its dependencies during the compilation process. By correctly setting the lifecycle phase, cdxgen ensures the resulting SBOM accurately communicates the context in which it was created."}]}
{"messages": [{"role": "user", "content": "I'm generating an SBOM for a C project and see many components with zero confidence. What does this mean and how can I handle it?"}, {"role": "assistant", "content": "In C and C++ projects, identifying third-party components can be challenging because there isn't always a standard package manager or manifest file. cdxgen may use techniques like filename or source code analysis, which can sometimes result in component matches with very low or zero confidence. A zero-confidence component means the tool has made a guess, but it has no strong evidence to support the identification.\n\nTo handle this and clean up your SBOM, you can use the `--min-confidence` filter. This argument allows you to set a threshold for the confidence score, excluding any components that fall below it. For example, running `cdxgen -t c . --min-confidence 0.1` will filter out all the zero-confidence components. However, you should use this option with caution, as it might also remove a correctly identified component that simply lacked strong evidence, so it's best to review the results to ensure you are not losing important information."}]}
{"messages": [{"role": "user", "content": "Does using the `--technique` filter to limit analysis methods improve cdxgen's performance?"}, {"role": "assistant", "content": "No, using the `--technique` argument to limit the analysis methods is unlikely to yield any performance benefits at this time. The documentation explicitly states that this capability is currently implemented as a filter during the post-processing stage of SBOM generation.\n\nThis means that cdxgen still performs all of its available analysis techniques (source-code, manifest, binary, etc.) to gather a complete set of potential components. After all the data is collected, it then applies the filter based on your `--technique` argument to decide which components to include in the final BOM. Because the analysis work is still being done upfront, there is no reduction in processing time or resource usage. The feature is primarily for controlling the content of the final report, not for optimizing the scan itself."}]}
{"messages": [{"role": "user", "content": "What information is included in the 'formulation' section of a BOM when using '--include-formulation'?"}, {"role": "assistant", "content": "When you use the `--include-formulation` flag, cdxgen adds a rich `formulation` section to the SBOM that captures the precise state of the build environment and source code. This section is designed to make the SBOM generation process highly traceable and reproducible. It contains two main parts: components representing the build environment and workflows representing the source retrieval.\n\nThe `components` part of the formulation includes git metadata, listing every file in the repository tree along with its git hash. It also identifies the versions of critical build tools found on the system, such as `dotnet`, `rustc`, and `go`, creating platform components for them. The `workflows` part documents how the source code was obtained, typically including the git remote URL (e.g., `git@github.com:HooliCorp/java-sec-code.git`) and relevant CI environment variables like the branch name."}]}
{"messages": [{"role": "user", "content": "My Dotnet project uses .Net Framework 4.7. How can I generate an accurate SBOM?"}, {"role": "assistant", "content": "Generating an accurate SBOM for projects targeting legacy frameworks like .NET Framework 4.6 or 4.7 presents a challenge because the build and restore process requires a Windows operating system. The standard Linux-based cdxgen containers cannot execute the necessary MSBuild targets to correctly resolve all dependencies for these projects.\n\nThe recommended solution is to perform the dependency resolution step on a Windows machine where the correct .NET Framework SDK is installed. On this machine, run `dotnet restore` or build the project. This will generate a `project.assets.json` file (and potentially lock files) that contains the complete and accurate dependency graph. The workaround is to then commit this `project.assets.json` file to your source code repository. Once that file is available, you can run cdxgen from a Linux environment or container as usual. It will find and parse the pre-existing assets file, allowing it to generate a correct SBOM without needing a Windows environment."}]}
{"messages": [{"role": "user", "content": "What is the `Namespaces` property that gets added when generating an SBOM from a Java cache?"}, {"role": "assistant", "content": "When you generate a Software Bill of Materials (SBOM) from a Java package cache (like Maven's `.m2` directory or Gradle's cache), cdxgen provides a valuable piece of enrichment data: the `Namespaces` property. For each Java component (JAR file) found in the cache, cdxgen inspects the contents of the JAR and extracts a list of all the Java class names contained within it.\n\nThis list of class names is then added as a custom property named `Namespaces` to that component's entry in the SBOM. This is a significant enhancement because it goes beyond just naming the component; it provides a detailed inventory of the code constructs (classes) that the component provides. This information can be extremely useful for advanced use cases, such as finding evidence of usage, where you need to know if your application is calling specific classes from a library."}]}
{"messages": [{"role": "user", "content": "My project is built with Swift. Is there a specific container image I should use for cdxgen?"}, {"role": "assistant", "content": "Yes, for projects built with Swift, it is recommended to use the specialized container image provided by the cdxgen project to ensure all necessary tools are available. The appropriate image is `ghcr.io/cyclonedx/cdxgen-debian-swift:v12`. This image is based on Debian and comes pre-installed with the Swift compiler and build tools, specifically a recent version like Swift 6.\n\nUsing this dedicated image is important because generating an SBOM for a Swift project often involves interacting with the Swift Package Manager (SwiftPM) to resolve dependencies. The `cdxgen-debian-swift` image ensures that the correct toolchain is present within the container's environment, allowing cdxgen to accurately parse the `Package.swift` file and construct the complete dependency graph for your application. This avoids potential errors that could occur if you tried to run the scan in a generic container that lacks the Swift SDK."}]}
{"messages": [{"role": "user", "content": "Can I use brace expansion to exclude multiple unrelated directories in cdxgen?"}, {"role": "assistant", "content": "Yes, brace expansion is a powerful feature supported by the `--exclude` argument in cdxgen that you can use to concisely specify multiple exclusion patterns, even for unrelated directories. The syntax `{a,b,c}` expands into separate items `a`, `b`, and `c`, allowing you to combine several distinct patterns into a single argument.\n\nFor example, if you wanted to exclude a `node_modules` directory, a `test` directory, and a `docs` directory, you could use three separate `--exclude` flags. However, using brace expansion is more efficient: `--exclude \"**/{node_modules,test,docs}/**\"`. This single argument expands to `**/node_modules/**`, `**/test/**`, and `**/docs/**`, effectively excluding all three directory trees from the scan in a clean and readable way."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `operational` BOM profile in cdxgen?"}, {"role": "assistant", "content": "The `operational` BOM profile in cdxgen is specifically designed for generating an Operational Bill of Materials, commonly known as an OBOM. An OBOM describes the software components present in a running system or operational environment, as opposed to a source code repository or a build artifact. This type of BOM is crucial for operations teams, site reliability engineers, and security incident responders.\n\nWhen you select the `operational` profile, cdxgen automatically sets the `projectType` metadata field in the SBOM to `os`. This clearly signals to any consuming tool that the BOM represents the software installed on an operating system. This profile helps standardize the creation of OBOMs, which are essential for tasks like monitoring for new vulnerabilities in deployed software, managing configurations, and understanding the software landscape of production servers."}]}
{"messages": [{"role": "user", "content": "How do I use the `license-compliance` BOM profile?"}, {"role": "assistant", "content": "The `license-compliance` BOM profile in cdxgen is designed to create a Bill of Materials that is optimized for license management and compliance use cases. The primary function of this profile is to ensure that detailed license information is gathered for each component during the SBOM generation process. It does this by activating a specific configuration that might not be enabled by default.\n\nWhen you use the `license-compliance` profile, it automatically sets the `FETCH_LICENSE` environment variable. This tells cdxgen to make a more concerted effort to find and include license texts and identifiers (like SPDX IDs) for all discovered dependencies. The resulting SBOM is much richer in license data, making it highly suitable for consumption by automated license compliance tools or for manual review by legal teams to ensure adherence to open-source license obligations."}]}
{"messages": [{"role": "user", "content": "Can I generate an SBOM for a Go binary file instead of source code?"}, {"role": "assistant", "content": "Yes, cdxgen is capable of generating a Software Bill of Materials (SBOM) directly from a compiled Go binary file. This is considered a `post-build` analysis because it inspects the final artifact rather than the source code. This capability is extremely useful for analyzing software for which you don't have the source, or for verifying the contents of a binary before deployment.\n\nTo perform this type of scan, you need to explicitly tell cdxgen that you are analyzing a `post-build` artifact. You would use the `-t go` argument to specify the type and the `--lifecycle post-build` argument to set the correct context. The command would look like this: `cdxgen -t go --lifecycle post-build -o bom.json <path to go binaries>`. cdxgen will then inspect the binary to extract dependency information that Go includes during the build process."}]}
{"messages": [{"role": "user", "content": "How can I check what version of `cdxgen-plugins-bin` I have installed?"}, {"role": "assistant", "content": "To check the installed version of the `cdxgen-plugins-bin` package, you can use the npm (Node Package Manager) command line tool. This package is typically installed globally to provide supporting binaries for cdxgen's various analysis capabilities. The command to list globally installed npm packages and filter for the one you're interested in is the most direct way to find the version.\n\nOpen your terminal and run the following command: `npm list -g @cyclonedx/cdxgen-plugins-bin`. This command tells npm to `list` the details of the specified package (`@cyclonedx/cdxgen-plugins-bin`) from your global (`-g`) installations. The output will show you the installation path and the version number of the package, for example, `@cyclonedx/cdxgen-plugins-bin@1.4.2`. This is useful for troubleshooting, especially for features like generating container SBOMs on Windows, which requires a minimum version of this package."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen container image for Deno runtime?"}, {"role": "assistant", "content": "Yes, the cdxgen project offers a container image that uses the Deno runtime instead of the standard Node.js runtime. This image is tagged as `ghcr.io/cyclonedx/cdxgen-deno:master`. Deno is a modern runtime for JavaScript and TypeScript that is known for its security-first approach, including a permissions model that is enabled by default.\n\nThis `cdxgen-deno` image provides an alternative for users who prefer the Deno ecosystem or want to leverage its security features for their SBOM generation process. It is presented as one of the main all-in-one container images alongside the default Node.js-based images. By using this image, you can run cdxgen in an environment where file, network, and environment access must be explicitly granted, aligning with modern security best practices."}]}
{"messages": [{"role": "user", "content": "What is the purpose of `--skip-maven-collector` when using evinse?"}, {"role": "assistant", "content": "The `--skip-maven-collector` flag is a performance optimization for the `evinse` tool, particularly when you are analyzing a Java project and have already generated a comprehensive SBOM from the Maven cache. The first time you run `evinse`, it may scan the Maven and Gradle caches to collect information about all available JARs, and it stores this information in a local SQLite database (`.atomdb`). This initial collection can be time-consuming.\n\nOn subsequent runs against the same or similar projects, the data in the `.atomdb` cache is likely still up-to-date. By passing the `--skip-maven-collector` flag, you are telling `evinse` to not re-scan the Maven/Gradle caches and to rely instead on the data it has already stored in its database. This can significantly speed up the startup and analysis process for reruns, as it avoids the redundant work of collecting jar information."}]}
{"messages": [{"role": "user", "content": "What does `--with-deep-jar-collector` do in evinse?"}, {"role": "assistant", "content": "The `--with-deep-jar-collector` flag is an option in the `evinse` tool that enables a more exhaustive search for JAR files within the Maven cache directory. By default, `evinse` might perform a standard collection of JARs, but this flag triggers a deeper, more comprehensive scan. This is particularly useful when you are trying to improve the recall for generating call stack evidence.\n\nImproved recall means the tool is more likely to find all possible connections between your application code and the libraries it uses. A more complete collection of all available JARs from the cache provides the analysis engine with more potential sinks (library functions) to consider, increasing the chances of successfully tracing a call stack. This option can be used to ensure the `evinse` analysis has access to the widest possible set of library code, though it may increase the initial collection time."}]}
{"messages": [{"role": "user", "content": "What happens if I specify `--platform=linux/amd64` when running a cdxgen container?"}, {"role": "assistant", "content": "Specifying the `--platform=linux/amd64` flag when running a Docker or nerdctl command tells the container runtime to pull and run the image variant built for the `linux/amd64` architecture. This is particularly useful when you are working on a machine with a different architecture, such as an ARM-based Apple Silicon Mac (which has an `arm64` architecture).\n\nMany software tools and packages, especially within the Node.js ecosystem (`npm install`), have better compatibility or are only available for the `amd64` (also known as x86_64) architecture. The cdxgen documentation specifically recommends using this flag for some of its container images (e.g., for .NET Core or Node.js 20) to avoid potential `npm install` errors or other compatibility issues that can arise when running on a non-amd64 host. It essentially forces the use of an emulation layer (like Rosetta 2 on Macs) to run the `amd64` version of the container, which often leads to a more stable and successful execution."}]}
{"messages": [{"role": "user", "content": "How can I generate an SBOM for a PHP project using a specific version like 8.3?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) for a PHP project that requires a specific version like PHP 8.3, the most reliable method is to use a dedicated cdxgen container image that comes with that version pre-installed. The cdxgen project maintains images for various PHP versions to ensure compatibility and correct dependency resolution.\n\nFor PHP 8.3, you would use the `ghcr.io/cyclonedx/cdxgen-debian-php83:v12` container image. By running cdxgen within this container, you guarantee that the `composer` commands it executes to analyze your project's dependencies are run using the correct PHP 8.3 runtime. This avoids any potential issues that could arise from version mismatches if your project's dependencies have strict PHP version constraints. The command would look something like `docker run --rm -v $(pwd):/app ghcr.io/cyclonedx/cdxgen-debian-php83:v12 -t php /app`."}]}
{"messages": [{"role": "user", "content": "My Python project requires version 3.12. Is there a recommended cdxgen image?"}, {"role": "assistant", "content": "Yes, for Python projects that have specific version requirements, cdxgen provides a set of version-specific container images. If your project requires Python 3.12, the recommended image to use is `ghcr.io/cyclonedx/cdxgen-python312:v12`. This ensures that when cdxgen analyzes your project, it uses a Python 3.12 environment.\n\nUsing the correct version is critical for Python projects because dependency resolution with tools like `pip` is highly dependent on the Python version. The `requirements.txt` or `pyproject.toml` file may contain version specifiers that are only compatible with Python 3.12. Running the analysis in the `cdxgen-python312` container guarantees that the dependency tree is resolved correctly, leading to an accurate SBOM that reflects the real dependencies of your project as it would run with its target interpreter."}]}
{"messages": [{"role": "user", "content": "I need to run cdxgen for a very large C project. What's the best approach?"}, {"role": "assistant", "content": "For very large C projects, especially those with millions of lines of code, the standard integrated `evinse` process within cdxgen might struggle due to memory limitations. The recommended approach for such scenarios is to use the underlying analysis engine, Atom, in its standalone Java mode. This allows you to allocate a substantial amount of memory directly to the resource-intensive code slicing operation.\n\nThe process involves a few steps. First, download the latest `atom.zip` release and unzip it. Then, from within the `bin` directory of the unzipped folder, you run the Atom tool directly, specifying a large Java heap size with the `-J-Xmx` flag (e.g., `-J-Xmx16g` for 16GB, or more for larger projects). You instruct it to perform a `usages` slice for the `c` language and save the output to a slices file: `./atom -J-Xmx16g usages -o app.atom --slice-outfile usages.json -l c <path_to_repo>`. Finally, you run cdxgen and feed it the generated slices file using the `--usages-slices-file` argument: `cdxgen -o bom.json -t c --usages-slices-file usages.json <path_to_repo>`."}]}
{"messages": [{"role": "user", "content": "How do I analyze a legacy .Net Core 3.1 project with cdxgen?"}, {"role": "assistant", "content": "To analyze a legacy project built with .NET Core 3.1, you should use a cdxgen container image that includes the appropriate SDK version, as the default image may have a newer, incompatible version. The cdxgen documentation recommends the `ghcr.io/cyclonedx/cdxgen-debian-dotnet6:v12` image for this purpose, as it includes support for multiple older .NET versions, including .NET Core 2.1, 3.1, and .NET 5.0.\n\nAn additional important consideration, especially if you are running on an ARM-based machine like an Apple Silicon Mac, is to specify the platform. The documentation suggests invoking the container with the `--platform=linux/amd64` flag. This ensures better compatibility for the .NET tools, which are often optimized for the amd64 architecture. Your full command would look like: `docker run --platform=linux/amd64 --rm -v $(pwd):/app ghcr.io/cyclonedx/cdxgen-debian-dotnet6:v12 -t dotnet /app`."}]}
{"messages": [{"role": "user", "content": "Can cdxgen generate an SBOM for a Rust project?"}, {"role": "assistant", "content": "Yes, cdxgen can generate a Software Bill of Materials (SBOM) for Rust projects. To ensure the best results, it is recommended to use one of the specialized container images that include the Rust toolchain (like `rustc` and `cargo`). The documentation lists `ghcr.io/cyclonedx/cdxgen-debian-rust:v12` and `ghcr.io/cyclonedx/cdxgen-debian-rust1:v12` as suitable images.\n\nThese images contain the necessary tools for cdxgen to interact with Cargo, Rust's package manager and build system. cdxgen will typically parse the `Cargo.lock` file to determine the exact versions of all dependencies in the dependency graph, providing a highly accurate SBOM. Furthermore, if you use the `--include-formulation` flag, cdxgen can even capture the version of the `rustc` compiler itself as a platform component in the BOM, adding valuable build context."}]}
{"messages": [{"role": "user", "content": "I have a complex Java application with both maven and sbt builds. How do I force cdxgen to use Scala SBT?"}, {"role": "assistant", "content": "When cdxgen encounters a project with multiple build systems, such as a Java project containing `pom.xml` (Maven), `build.gradle` (Gradle), and `build.sbt` (SBT for Scala), it follows a default priority order to decide which system to use. In this case, it would likely default to Maven. To override this and force cdxgen to use the Scala Build Tool (SBT), you must explicitly specify the project type.\n\nYou can do this using the `-t` or `--type` command-line argument. To direct cdxgen to use SBT, you would run your command with the flag `-t scala`. For example: `cdxgen -t scala -o bom.json .`. This command tells cdxgen to ignore the Maven and Gradle files and instead use the SBT definition to resolve dependencies and construct the Software Bill of Materials for your Scala components."}]}
{"messages": [{"role": "user", "content": "What is the benefit of using a Nydus image for cdxgen in a GitHub Action workflow?"}, {"role": "assistant", "content": "Using a Nydus-formatted container image for cdxgen in a GitHub Actions workflow can provide significant performance benefits, primarily by reducing the time it takes to pull the image and start the container. Nydus employs a lazy-pulling mechanism, meaning it only downloads the parts of the image that are immediately necessary to start the application, rather than downloading the entire image upfront.\n\nThe cdxgen documentation provides an example `nydus-demo.yml` workflow to demonstrate this. In a CI/CD context like GitHub Actions, where runners are often ephemeral and need to pull images for every job, the time saved can be substantial. By using a Nydus snapshotter with a Nydus image (e.g., `ghcr.io/cyclonedx/cdxgen:master-nydus`), your cdxgen step will start faster, leading to quicker overall workflow execution times. This efficiency is a key advantage of adopting the Nydus format."}]}
{"messages": [{"role": "user", "content": "What does the `bom-ref` attribute in the formulation section of a BOM represent?"}, {"role": "assistant", "content": "The `bom-ref` attribute found within various objects in a CycloneDX Bill of Materials serves as a unique identifier for that specific element within the BOM document itself. It allows other parts of the BOM to reference that element unambiguously. When you see `bom-ref` in the `formulation` section, it is providing a unique handle for that specific formulation block.\n\nFor example, the top-level formulation object has its own `bom-ref`, like `\"bom-ref\": \"f8324846-fad6-4927-a8e7-49379f57489b\"`. This allows this entire block of build and source information to be referenced if needed. Similarly, inside the `workflows` array, each workflow object also has its own `bom-ref`. This internal linking mechanism is a core part of the CycloneDX specification, enabling the creation of complex relationships between elements, such as linking a component directly to the workflow that built it."}]}
{"messages": [{"role": "user", "content": "What does `--no-install-deps` do, and for which language is it mentioned?"}, {"role": "assistant", "content": "The `--no-install-deps` argument is a flag in cdxgen that modifies its behavior by preventing it from attempting to install a project's dependencies. By default, for many languages, cdxgen may try to run a package manager's install command (like `pip install` or `npm install`) to ensure it has an accurate dependency tree. This flag disables that feature.\n\nThe main use case for `--no-install-deps` is to generate a `pre-build` Bill of Materials. A `pre-build` BOM represents the dependencies as they are declared in the manifest files (like `requirements.txt`), before they are actually installed and resolved into a concrete set of packages. The documentation specifically mentions Python as an example language where this is possible. Using this flag with a Python project will result in an SBOM based purely on the manifest, which reflects the `pre-build` state of the software."}]}
{"messages": [{"role": "user", "content": "How do I analyze an Android application from its APK files?"}, {"role": "assistant", "content": "You can generate a Software Bill of Materials (SBOM) for an Android application directly from its compiled APK files using cdxgen. This is a form of `post-build` analysis, as you are inspecting the final packaged artifact rather than the source code. This is useful for security analysis of mobile apps or for inventorying the components in a final release.\n\nTo perform this analysis, you need to specify the project type as `android` and the lifecycle phase as `post-build`. The command would look like this: `cdxgen -t android --lifecycle post-build -o bom.json <path to apks>`. You would replace `<path to apks>` with the directory containing the APK file(s) you want to analyze. cdxgen will then unpack the APK and inspect its contents to identify the bundled libraries and components."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen container image that uses the Alpine Linux distribution?"}, {"role": "assistant", "content": "Yes, the cdxgen project provides several container images that are based on Alpine Linux. Alpine is a popular choice for container base images because it is extremely lightweight, which results in smaller image sizes and a reduced attack surface. These images are identifiable by the `-alpine` suffix in their tags.\n\nFor example, the documentation lists several Alpine-based images for different language stacks, such as `ghcr.io/cyclonedx/cdxgen-alpine-java21:v12` for Java 21, `ghcr.io/cyclonedx/cdxgen-alpine-node24:v12` for Node.js 24, and `ghcr.io/cyclonedx/cdxgen-alpine-golang123:v12` for Golang 1.23. Using an Alpine-based image can lead to faster image pulls and lower resource consumption, making them an excellent choice for efficient CI/CD pipelines, provided your project's build dependencies are compatible with the Alpine environment."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to generate an SBOM for a project using Golang version 1.24?"}, {"role": "assistant", "content": "Yes, you can generate a Software Bill of Materials for a Golang project using version 1.24, and cdxgen provides specific container images to support this. To ensure the correct toolchain is used for analyzing your Go modules, it is recommended to use one of the images built for this Go version.\n\nThe documentation lists several options for Golang 1.24, including Debian-based and Alpine-based images. For example, you can use `ghcr.io/cyclonedx/cdxgen-debian-golang124:v12` or its Alpine equivalent, `ghcr.io/cyclonedx/cdxgen-alpine-golang124:v12`. Using one of these images guarantees that cdxgen will use the Go 1.24 toolchain to inspect your `go.mod` and `go.sum` files, resulting in an accurate dependency graph that reflects the specific version of Go your project is built with."}]}
{"messages": [{"role": "user", "content": "Why would I need to run 'Docker for Desktop' as an administrator on Windows for cdxgen?"}, {"role": "assistant", "content": "The requirement to run 'Docker for Desktop' as an administrator on Windows when generating a container SBOM with cdxgen is tied to specific configuration and permission needs. The primary reason mentioned in the documentation is for the setting 'Exposing daemon on TCP without TLS' to be turned on, which often requires administrative privileges to configure network settings.\n\nAdditionally, the process of analyzing a container image involves extracting its layers onto the local filesystem. These layers can contain various file types, including symbolic links (symlinks), which are common in Linux-based images. On Windows, creating and handling symlinks properly requires elevated permissions. Therefore, running both Docker Desktop and your command-line terminal (like PowerShell) as an administrator ensures that cdxgen has the necessary rights to both communicate with the Docker daemon and correctly extract all file system elements from the container layers without failing on permission errors."}]}
{"messages": [{"role": "user", "content": "How do I exclude the 'test' directory from my cdxgen scan?"}, {"role": "assistant", "content": "To exclude a directory named 'test' from your cdxgen scan, you should use the `--exclude` argument with a glob pattern that matches the directory at any location within your project. This is a common requirement, as test directories often contain development-only dependencies that you may not want to include in your production SBOM.\n\nThe most robust way to do this is with the pattern `\"**/test/**\"`. The `**/` at the beginning ensures that the 'test' directory is found whether it's at the root of your project or nested deep inside another directory. The `/**` at the end ensures that all files and subdirectories within the 'test' directory are also excluded. A complete example command mentioned in the documentation for scanning the cdxgen repo itself is: `cdxgen -t php -t js -t jar -t ruby --exclude \"**/test/**\" -o bom.json`."}]}
{"messages": [{"role": "user", "content": "Can I specify a minimum confidence for component identification?"}, {"role": "assistant", "content": "Yes, you can specify a minimum confidence level for components to be included in your SBOM by using the `--min-confidence` argument. This feature allows you to filter out component identifications that cdxgen considers to be low-quality or highly speculative. The argument accepts a decimal value between 0 (no confidence) and 1 (full confidence).\n\ncdxgen calculates the confidence for a component's Package URL (purl) based on the evidence it finds. If the calculated confidence for a component is less than the value you provide, that component will be excluded from the final BOM. For example, `cdxgen --min-confidence 0.5` would only include components where the tool is at least 50% confident in its identification. This is particularly useful for C/C++ projects where component discovery can be less precise, helping to reduce noise from low-confidence guesses."}]}
{"messages": [{"role": "user", "content": "How does the `--only` filter differ from the `--filter` option in cdxgen?"}, {"role": "assistant", "content": "The `--only` and `--filter` options in cdxgen both reduce the number of components in the final SBOM, but they have distinct mechanisms and use cases. The `--filter` argument is a broader, more general-purpose filter. It includes a component if the provided string matches (case-insensitively) any part of the component's Package URL (purl) OR any of its associated properties. This makes it useful for selecting components by namespace or by a custom property like a build profile.\n\nIn contrast, the `--only` argument is more restrictive and specific. It will only include components if the provided string is found within their purl; it does not check other properties. This makes the `--only` flag the ideal tool for isolating a specific set of components, such as creating a BOM that contains exclusively first-party components from your own organization's namespace. For example, `--only com.mycompany` would strictly include components with that namespace in their purl."}]}
{"messages": [{"role": "user", "content": "What is 'Reverse-Reachability' and when is it used by evinse?"}, {"role": "assistant", "content": "Reverse-Reachability is an advanced code analysis algorithm used by the `evinse` tool to compute call stack evidence. It is employed when you use the data flow-based slicing method, which is activated with the `--with-data-flow` flag. Unlike the default Forward-Reachability method that traces paths from application entry points (sources) to library calls (sinks), Reverse-Reachability works in the opposite direction.\n\nThis method is used in situations where forward tracing is unreliable. For example, if the code being analyzed is a library without any defined entry points, or if complex abstraction layers hide the direct call paths. In these cases, Reverse-Reachability starts at the known library calls (sinks) and traces backward through the code to find any possible execution paths that could have led to that call. While this is a more time and resource-consuming operation, it can successfully uncover call stacks in complex scenarios where the standard approach would fail."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `.atomdb` file used by evinse?"}, {"role": "assistant", "content": "The `.atomdb` file is a SQLite database that the `evinse` tool uses as a local cache. Its primary purpose is to store persistent information about software components that `evinse` has analyzed, which helps to significantly speed up subsequent runs. When `evinse` analyzes a Java JAR file, for instance, it will extract and store the list of all class names (namespaces) found within that JAR in the `.atomdb` database.\n\nOn the next run, if `evinse` encounters the same JAR file, it can quickly retrieve the list of class names from the cache instead of having to unpack and re-analyze the entire JAR. This caching mechanism is crucial for performance, especially when dealing with large projects or generating SBOMs from extensive local caches like the `.m2` directory. If this cache becomes outdated, you can simply delete the `.atomdb` file to force `evinse` to recreate it with fresh data."}]}
{"messages": [{"role": "user", "content": "How do I add multiple authors to my BOM's metadata?"}, {"role": "assistant", "content": "To add multiple authors to the metadata of the Bill of Materials (BOM) you are generating, you simply need to use the `--author` command-line argument multiple times, once for each author you wish to add. The cdxgen tool will collect all the values provided and create an array of authors in the `metadata.authors` section of the final CycloneDX JSON file.\n\nIt is important to remember to enclose any author names that contain spaces in double quotes to ensure they are treated as a single argument by your shell. For instance, to specify both the 'OWASP Foundation', and the 'Apache Foundation', as authors, your command would include the following arguments: `cdxgen --author \"OWASP Foundation\" --author \"Apache Foundation\" ...`. This will result in a BOM that correctly attributes the work to both organizations."}]}
{"messages": [{"role": "user", "content": "Can cdxgen help with generating an OBOM (Operational Bill of Materials)?"}, {"role": "assistant", "content": "Yes, cdxgen can help you generate an Operational Bill of Materials (OBOM) through the use of its BOM Profiles feature. An OBOM is used to describe the software components running in an operational environment, like a production server. To create one, you can use the `operational` profile.\n\nWhen you specify the `operational` profile, cdxgen automatically configures the output to be suitable for an OBOM. The main action it takes is setting the `projectType` field in the SBOM's metadata to `os`. This clearly marks the BOM as a description of the software installed on an operating system, distinguishing it from a typical source-code or build-time BOM. This helps downstream tools correctly interpret the context and purpose of the Bill of Materials."}]}
{"messages": [{"role": "user", "content": "My Java project is old and uses Java 8. What is the best way to generate an SBOM for it?"}, {"role": "assistant", "content": "For older Java projects that have specific JDK version requirements, such as Java 8, the most reliable way to generate an SBOM is to use a cdxgen container image that is purpose-built for that version. This ensures that the Maven or Gradle commands executed by cdxgen are run with a compatible Java runtime, avoiding potential build and dependency resolution failures.\n\nThe cdxgen project provides the `ghcr.io/cyclonedx/cdxgen-temurin-java8:v12` container image specifically for this purpose. This image comes with a Java 8 JDK (from the Eclipse Temurin project) pre-installed. By running your cdxgen scan within this container, you create an environment that matches your project's requirements, leading to the most accurate and complete SBOM possible for your legacy application."}]}
{"messages": [{"role": "user", "content": "What is the `cdxgen-deno` container image?"}, {"role": "assistant", "content": "The `ghcr.io/cyclonedx/cdxgen-deno:master` container image is a specific version of the all-in-one cdxgen image that is built to run on the Deno runtime instead of the more traditional Node.js runtime. Deno is a modern and secure runtime for JavaScript and TypeScript that offers features like a built-in permission model, which restricts what a program can access by default.\n\nThis image is provided for users who prefer the Deno ecosystem or want to take advantage of its security-by-default posture for their software supply chain tooling. By using the `cdxgen-deno` image, the SBOM generation process itself runs within a more sandboxed environment, aligning with modern security principles of least privilege. It stands as an alternative to the standard and secure Node.js-based images."}]}
{"messages": [{"role": "user", "content": "What happens when I use the `--annotate` flag with evinse?"}, {"role": "assistant", "content": "The `--annotate` flag is an option available in the `evinse` tool that allows you to include even more detailed information in your final evidence-based SBOM. When this boolean flag is enabled, `evinse` will take the raw contents of the code slices generated by the `atom` engine and embed them directly into the SBOM as annotations.\n\nThese slices contain snippets of source code and detailed data flow information that constitute the raw evidence for component usage. Including them as annotations provides the highest possible level of transparency and auditability, as the consumer of the SBOM can see the exact code that led to the evidence claim. This can be very useful for deep security analysis or debugging, but it will also significantly increase the size of the resulting BOM file."}]}
{"messages": [{"role": "user", "content": "What is the `data-flow-slices-file` argument in evinse used for?"}, {"role": "assistant", "content": "The `--data-flow-slices-file` argument in the `evinse` tool is used for performance tuning by caching the results of a data flow analysis. When you run `evinse` with the `--with-data-flow` option, it performs a resource-intensive analysis to find call stacks. This analysis produces an intermediate result called a data-flow slices file.\n\nBy using the `--data-flow-slices-file` argument, you can specify a path to save this intermediate result, for example: `--data-flow-slices-file data-flow.json`. On subsequent runs, if `evinse` finds this file, it will use the cached data instead of re-running the entire complex analysis from scratch. This dramatically improves performance for re-runs on the same codebase, as the most time-consuming part of the process can be skipped."}]}
{"messages": [{"role": "user", "content": "Can cdxgen analyze a project using Ruby 1.8?"}, {"role": "assistant", "content": "Analyzing a very old Ruby project that uses version 1.8.x presents a significant challenge for modern tooling. The cdxgen documentation indicates that while there is a base image available, `ghcr.io/cyclonedx/debian-ruby18:master`, its capabilities are limited. This image is provided primarily to support running `bundle install` for such legacy projects.\n\nHowever, there is no full-featured cdxgen equivalent that runs in a Ruby 1.8.x environment. This means that while you might be able to resolve dependencies, more advanced cdxgen features are explicitly noted as unsupported for this version. Specifically, using `--deep` mode and the `research` profile will not work. The support for such an old version is best-effort and focuses on the most basic dependency listing."}]}
{"messages": [{"role": "user", "content": "What is the difference between the `cdxgen-java11-slim` and `cdxgen-java11` images?"}, {"role": "assistant", "content": "The cdxgen project often provides both a standard and a `slim` version for its container images, including for Java 11. The primary difference between the `ghcr.io/cyclonedx/cdxgen-java11:v12` and `ghcr.io/cyclonedx/cdxgen-java11-slim:v12` images is their size and the number of tools included.\n\nThe standard image is more comprehensive and includes a wider range of build tools and development libraries. This makes it more likely to work out-of-the-box with complex projects that have many system-level dependencies. The `slim` image, on the other hand, is a stripped-down version that includes only the essential tools needed for cdxgen and basic Java builds. It has a smaller footprint, making it quicker to pull and more efficient to store. The `slim` version is a good choice if you have a straightforward project and want to optimize for image size, but the standard version is a safer bet for complex or unusual build requirements."}]}
{"messages": [{"role": "user", "content": "Where can I find the cdxgen container image for .NET 9?"}, {"role": "assistant", "content": "For users who want to work with the latest preview versions of the .NET SDK, the cdxgen project provides forward-looking container images. To generate an SBOM for a project targeting .NET 9, you can use one of the dedicated images listed in the documentation.\n\nThere are several options available for .NET 9, including `ghcr.io/cyclonedx/cdxgen-debian-dotnet9:v12` (Debian-based), `ghcr.io/cyclonedx/cdxgen-alpine-dotnet9:v12` (Alpine-based), and `ghcr.io/cyclonedx/cdxgen-dotnet9:v12` (a default image, amd64 only). Using one of these ensures that your SBOM generation environment has the correct .NET 9 SDK, which is necessary for projects that rely on new features or target the new runtime."}]}
{"messages": [{"role": "user", "content": "What does the `--with-reachables` flag do in evinse?"}, {"role": "assistant", "content": "The `--with-reachables` flag in the `evinse` tool is used to enable the generation of call stack evidence based on a Forward-Reachability analysis. When this flag is used, `evinse` performs an analysis that traces data flows from known entry points in your application (sources) to points where your code calls functions in external libraries (sinks).\n\nTo use this feature effectively, the input SBOM must have been generated with cdxgen's `--deep` mode (for Java and Python), as this mode collects the necessary metadata for the analysis. The result is an enriched SBOM where component evidence includes not just proof of occurrence, but also the specific call paths demonstrating how the library is actively used. This provides a much stronger form of evidence than simply observing that a library is present in the build."}]}
{"messages": [{"role": "user", "content": "My evinse run is very slow. How can I use cached usages slices?"}, {"role": "assistant", "content": "If your `evinse` runs are slow, you can significantly improve their performance by caching and reusing the usages slices file. The `usages` analysis, which finds where components are used in the code, is one of the core operations of evinse. By saving its results, you can avoid re-running it every time.\n\nTo do this, you use the `--usages-slices-file` argument. On your first run, you would specify a path to save the output, for example: `evinse ... --usages-slices-file usages.json <path_to_app>`. This command will perform the analysis and write the results to `usages.json`. On all subsequent runs for the same code, you simply include the same argument. `evinse` will detect that the `usages.json` file already exists and will load the cached slices from it instead of performing the analysis again, leading to a much faster execution."}]}
{"messages": [{"role": "user", "content": "Can I get command completion for the `evinse` tool in my shell?"}, {"role": "assistant", "content": "Yes, just like the main `cdxgen` tool, the `evinse` tool also has a built-in capability to generate a command-line completion script for your shell. This makes it much easier and faster to use, as your shell will be able to auto-complete the various commands and flags that `evinse` offers.\n\nTo enable it, you need to run `evinse` with the `completion` argument and append the output to your shell's configuration file. For example, if you are using the zsh shell, you would run `evinse completion >> ~/.zshrc`. If you are using bash, you would run `evinse completion >> ~/.bashrc`. After updating the file, you'll need to restart your shell or source the configuration file for the changes to take effect."}]}
{"messages": [{"role": "user", "content": "What does it mean if the `compositions.aggregate` property is 'incomplete_first_party_only'?"}, {"role": "assistant", "content": "When the `compositions.aggregate` property in a CycloneDX BOM is set to `incomplete_first_party_only`, it is a specific signal to the consumer of the SBOM about its contents. This value indicates that the list of components in the BOM is not complete and has been intentionally filtered to include only first-party components—that is, components developed by the organization that produced the software.\n\ncdxgen automatically sets this value when you use the `--only` filter, as this filter is the primary mechanism for isolating components from a specific namespace (typically your own). This is a crucial piece of metadata because it prevents any misunderstanding. It makes it clear that the absence of a third-party library in the BOM doesn't mean it isn't a dependency; it simply means it was outside the scope of this particular, filtered SBOM."}]}
{"messages": [{"role": "user", "content": "How do I generate an SBOM for a project using the latest version of Node.js, like version 24?"}, {"role": "assistant", "content": "To generate an SBOM for a project that is built with a very recent version of Node.js like version 24, you should use a cdxgen container image that is specifically equipped with this runtime. This ensures that the `npm` or `yarn` commands that cdxgen runs to determine dependencies are executed in an environment that matches your project's requirements.\n\nThe documentation indicates that the default all-in-one image, `ghcr.io/cyclonedx/cdxgen:master`, includes the Node.js 24 runtime. Additionally, there is an Alpine-based alternative, `ghcr.io/cyclonedx/cdxgen-alpine-node24:v12`. By using one of these images, you can be confident that cdxgen will be able to correctly handle any new features or syntax in your `package.json` and `package-lock.json` files that are specific to the Node.js 24 ecosystem."}]}
{"messages": [{"role": "user", "content": "What are the supported values for the `--technique` argument?"}, {"role": "assistant", "content": "The `--technique` argument in cdxgen allows you to specify which methods the tool should use for component discovery. The documentation lists a range of supported values that you can use to customize your scan. The default value is `auto`, which enables the standard, multi-faceted discovery process.\n\nThe specific techniques you can choose from are: `source-code-analysis` (direct inspection of source files), `binary-analysis` (examining compiled code), `manifest-analysis` (parsing package manager files like `pom.xml`), `hash-comparison` (matching file hashes against known component databases), `instrumentation` (observing runtime dependencies), and `filename` (guessing components based on their filenames). You can provide the `--technique` argument multiple times to allow a combination of specific techniques, for example `--technique manifest-analysis --technique hash-comparison`."}]}
{"messages": [{"role": "user", "content": "Where is the evinse cache database located on a Windows machine?"}, {"role": "assistant", "content": "On a Windows operating system, the `evinse` tool stores its cache database, the `.atomdb` file, in the standard location for local application data. This follows the conventional directory structure for user-specific application files on the platform. You can find this SQLite database file in your user's `AppData` folder.\n\nThe exact default path is `C:\\Users\\<YourUsername>\\AppData\\Local\\.atomdb`, which can also be accessed using the environment variable shorthand `%LOCALAPPDATA%\\.atomdb`. If you ever encounter issues with stale or incorrect cached data, you can navigate to this directory and delete the `.atomdb` file. `evinse` will then automatically recreate it with fresh data on its next run. You can also override this location by setting the `ATOM_DB` environment variable."}]}
{"messages": [{"role": "user", "content": "Where is the evinse cache database located on a Linux machine?"}, {"role": "assistant", "content": "On a Linux system, the `.atomdb` cache file used by `evinse` is stored in a location that follows the XDG Base Directory Specification for user-specific data files. This ensures that application data is stored in a standardized and predictable place. The default location for this SQLite database is within your home directory.\n\nYou will find the file at the following path: `~/.local/share/.atomdb`. The `~` symbol represents your home directory (e.g., `/home/prabhu`). If you need to clear the cache to resolve issues with outdated namespace information, you can safely delete this file. `evinse` will regenerate it on its next execution. This default path can also be changed by setting the `ATOM_DB` environment variable before running the tool."}]}
{"messages": [{"role": "user", "content": "Can cdxgen create an SBOM for a Scala project?"}, {"role": "assistant", "content": "Yes, cdxgen is capable of generating a Software Bill of Materials (SBOM) for Scala projects that are built using the Scala Build Tool (SBT). To do this correctly, you need to explicitly tell cdxgen to use the Scala/SBT analysis type, especially if other build files like `pom.xml` might also be present in your project.\n\nYou would use the `-t` or `--type` argument with the value `scala`. For example, the command `cdxgen -t scala` instructs the tool to look for an SBT build definition (`build.sbt`) and use it to resolve the project's dependencies. This ensures that the specific dependencies and versions defined for your Scala project are accurately captured in the final SBOM."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support generating an SBOM for a Ruby on Rails project?"}, {"role": "assistant", "content": "Yes, cdxgen supports generating a Software Bill of Materials (SBOM) for Ruby projects, which includes those built with the Ruby on Rails framework. The dependency management in most Ruby projects is handled by Bundler, which uses a `Gemfile` and `Gemfile.lock` to define and lock dependencies. cdxgen is designed to parse these files to build an accurate dependency graph.\n\nTo ensure the best results, especially if your project requires a specific Ruby version, it is recommended to use one of the Ruby-specific cdxgen container images, such as `ghcr.io/cyclonedx/cdxgen-debian-ruby33:v12`. These images come with the necessary Ruby runtime and Bundler toolchain, allowing cdxgen to correctly resolve all the gems your Rails application depends on. You would typically run the command with `-t ruby` to specify the project type."}]}
{"messages": [{"role": "user", "content": "How do I specify a path to the application when using evinse?"}, {"role": "assistant", "content": "When using the `evinse` tool to generate evidence, you need to provide it with the path to the application source code you want to analyze. This is a required positional argument that comes after all the options and flags. The tool needs this path to locate the source files for its slicing and analysis operations.\n\nFor example, if you are generating evidence for a Java project located in the current directory, the command might look like this: `evinse -i bom.json -o bom.evinse.json .`. In this case, the `.` at the end of the command is the path to the application, signifying the current working directory. If your project was in a different directory, say `~/projects/my-java-app`, you would provide that full path as the final argument."}]}
{"messages": [{"role": "user", "content": "What is the format of the `compositions.workflows` section in a BOM?"}, {"role": "assistant", "content": "The `compositions.workflows` section, which can be included in a BOM by using the `--include-formulation` flag, describes the process used to obtain the source code. It is an array of workflow objects, where each object details a step in the process, such as cloning a git repository. Each workflow object has its own unique `bom-ref` and a `uid`.\n\nThe key information is contained within the `inputs` array. An input object typically specifies a `source`, which for a git repository would contain a `ref` with the git URL (e.g., `git@github.com:HooliCorp/java-sec-code.git`). It can also include `environmentVars`, which is an array of key-value pairs for environment variables that were present during the workflow, such as `GIT_BRANCH` and its value. Finally, the `taskTypes` array describes the kind of task performed, with `clone` being a common value."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to create a bill of materials for my operating system?"}, {"role": "assistant", "content": "Yes, you can use cdxgen to create a Bill of Materials for an operating system, which is commonly referred to as an Operational Bill of Materials (OBOM). This type of BOM inventories the software packages and components installed and running in an operational environment. cdxgen facilitates this through a specific BOM profile.\n\nTo generate an OBOM, you should use the `operational` profile. When this profile is selected, cdxgen sets the `projectType` field in the SBOM's metadata to `os`. This tag is a clear indicator to anyone or any tool consuming the BOM that it describes the software landscape of an operating system, rather than the dependencies of a single application's source code. This is critical for use cases like vulnerability monitoring of production servers."}]}
{"messages": [{"role": "user", "content": "Can cdxgen generate an SBOM for a .NET project from its binaries?"}, {"role": "assistant", "content": "Yes, cdxgen has the capability to generate a Software Bill of Materials (SBOM) by analyzing compiled .NET binaries (like .dll and .exe files). This is a `post-build` analysis, meaning it examines the final artifacts after the build process is complete. This method is useful when you don't have access to the source code or when you want to verify the contents of a distributed binary.\n\nTo use this feature, you must explicitly tell cdxgen that you are performing a `post-build` scan. You would use the `-t dotnet` argument to specify the project type and add the `--lifecycle post-build` flag. A typical command would look like: `cdxgen -t dotnet --lifecycle post-build -o bom.json <path to dotnet binaries>`. cdxgen will then inspect the binaries to identify embedded dependencies and metadata to construct the SBOM."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen container image that includes the Golang 1.23 toolchain?"}, {"role": "assistant", "content": "Yes, for projects that are built using Golang version 1.23, the cdxgen project provides specific container images that include the corresponding toolchain. Using the correct image is important for ensuring that `go mod` commands behave as expected and that the dependency graph is resolved accurately.\n\nThe documentation lists both Debian-based and Alpine-based images for this version. You can choose `ghcr.io/cyclonedx/cdxgen-debian-golang123:v12` for a Debian environment, or `ghcr.io/cyclonedx/cdxgen-alpine-golang123:v12` for a more lightweight Alpine environment. By running your cdxgen scan within one of these containers, you guarantee that the Go 1.23 tools are used to analyze your project's modules."}]}
{"messages": [{"role": "user", "content": "My project has a `pom.xml` and a `build.gradle` file. Which one will cdxgen use?"}, {"role": "assistant", "content": "When cdxgen scans a project directory and finds build files for multiple Java-based build systems, such as a `pom.xml` for Maven and a `build.gradle` for Gradle, it follows a predefined order of precedence to decide which one to use. Under the default settings, cdxgen will prioritize Maven over Gradle.\n\nThis means that in your case, cdxgen will detect the `pom.xml` file and proceed to use Maven to analyze the project's dependencies. The `build.gradle` file will be ignored. If your project is actually managed by Gradle and you want cdxgen to use it, you must override this default behavior by explicitly specifying the project type with the `-t gradle` flag."}]}
{"messages": [{"role": "user", "content": "How do I get a list of class names for a JAR in my SBOM?"}, {"role": "assistant", "content": "To get a list of class names (namespaces) for a Java JAR file included in your SBOM, you should use the cdxgen feature that generates an SBOM from a local package cache (like Maven's `.m2` directory). When you run cdxgen in this mode, it performs a deeper inspection of the JAR files it finds.\n\nAs a bonus of this cache-scanning mode, for each JAR component it adds to the SBOM, cdxgen will also add a custom property called `Namespaces`. The value of this property is an array containing the fully qualified names of all the Java classes found inside that JAR file. This provides a very detailed view of the component's contents, which is not typically available in a standard SBOM generated from a `pom.xml` file."}]}
{"messages": [{"role": "user", "content": "Can I analyze a project requiring Python 3.6?"}, {"role": "assistant", "content": "Yes, you can analyze a project that requires the legacy Python 3.6 version, as cdxgen provides a container image specifically for this purpose: `ghcr.io/cyclonedx/cdxgen-python36:v12`. Using this image is essential because many modern Python tools and libraries are no longer compatible with Python 3.6.\n\nHowever, it is important to be aware of a limitation mentioned in the documentation for this specific version. While the image allows for basic dependency discovery, it does not support generating a full dependency tree. This means the resulting SBOM will likely be a flat list of dependencies without the hierarchical relationships showing which dependency brought in which transitive dependency. This is a constraint related to the capabilities of the dependency analysis tools available for that older Python version."}]}
{"messages": [{"role": "user", "content": "What is the protobuf binary export option for?"}, {"role": "assistant", "content": "The protobuf binary export option in cdxgen allows you to serialize the generated Software Bill of Materials (SBOM) into the Protocol Buffers (protobuf) format instead of the default JSON format. Protobuf is a binary data format developed by Google that is known for being highly efficient in terms of both size and processing speed compared to text-based formats like JSON or XML.\n\nThis feature is intended for use cases where performance and efficiency are critical. For example, if you are transmitting SBOMs over a network with limited bandwidth, or if you are processing a very large number of SBOMs in an automated system, the smaller size and faster parsing of the protobuf format can be a significant advantage. To use it, you would add the `--export-proto` flag to your command. Note that this mode only supports CycloneDX specification version 1.5."}]}
{"messages": [{"role": "user", "content": "What is the `force` option in the evinse tool?"}, {"role": "assistant", "content": "The `--force` option in the `evinse` command-line tool is a boolean flag that, when used, forces the creation of the underlying `atom` analysis database. The `atom` engine, which powers evinse, uses a database (typically the `.atomdb` SQLite file) to cache information and analysis results. By default, it may reuse an existing database to speed up operations.\n\nUsing the `--force` flag tells `evinse` to ignore any existing database and create a new one from scratch. This can be useful in several situations. For example, if you suspect the cached data has become corrupted or is out of sync with your source code after significant changes, forcing a recreation of the database ensures that the analysis is performed on a clean slate with the most current information. It's a way to guarantee a fresh analysis, though it may take longer than a run that utilizes the cache."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen image for PHP 8.4?"}, {"role": "assistant", "content": "Yes, the cdxgen project provides container images for users who need to work with upcoming or recent versions of PHP, including PHP 8.4. To generate an SBOM for a project that targets this version, you can use one of the dedicated container images to ensure the correct runtime environment.\n\nThe documentation lists two options for PHP 8.4: a Debian-based image, `ghcr.io/cyclonedx/cdxgen-debian-php84:v12`, and an Alpine-based image, `ghcr.io/cyclonedx/cdxgen-alpine-php84:v12`. Using one of these images ensures that when cdxgen runs `composer` to resolve your project's dependencies, it does so with the PHP 8.4 interpreter, which is crucial for compatibility if your project or its dependencies require features or syntax specific to this version."}]}
{"messages": [{"role": "user", "content": "How can I analyze my project for cryptographic components?"}, {"role": "assistant", "content": "To analyze your project for cryptographic components and generate a specialized Cryptography Bill of Materials (CBOM), you can use the `cbom` alias provided by cdxgen. This command is a shortcut designed specifically for this purpose and is currently supported for Java and Python projects.\n\nWhen you run a command like `cbom -t java .`, the alias automatically enables a set of advanced options to create a rich and detailed CBOM. It turns on `--include-crypto` to identify cryptographic algorithms and libraries, `--include-formulation` to capture detailed build metadata, `--evidence` to find proof of usage, and sets the CycloneDX specification to version 1.6, which has formal support for describing cryptographic assets. This provides a powerful, one-command solution for detailed cryptographic analysis."}]}
{"messages": [{"role": "user", "content": "What is the `uid` in a workflow object within the formulation section?"}, {"role": "assistant", "content": "The `uid` (Unique Identifier) in a workflow object, found within the `formulation` section of a CycloneDX BOM, is a globally unique identifier for that specific workflow instance. While the `bom-ref` is a unique identifier within the context of the BOM document itself, the `uid` is intended to be unique across all BOMs and all systems.\n\nThis `uid`, often represented as a UUID (e.g., `\"uid\": \"c451097b-5c74-49db-ada7-81bd77cdb390\"`), provides a stable and universally unique reference for the specific execution of the workflow that generated the BOM. This is valuable for external systems that might be tracking or correlating build and CI/CD processes. It allows for unambiguous identification of the exact build run that produced the software artifact described by the BOM, enhancing traceability and auditability across different tools and platforms."}]}
{"messages": [{"role": "user", "content": "How do I ensure that cdxgen uses Ruby version 3.3.1 for its scan?"}, {"role": "assistant", "content": "To ensure that cdxgen uses a very specific version of Ruby, like 3.3.1, for its scan, you should use a combination of the correct container image and a specific type argument. The cdxgen Ruby container images are designed to support the automatic installation of specific patch versions within their major/minor version family.\n\nFirst, you would use the appropriate container image for the Ruby 3.3.x series, which is `ghcr.io/cyclonedx/cdxgen-debian-ruby33:v12`. Then, within your `docker run` command, you would pass the `-t` or `--type` argument to cdxgen with the exact version you need: `-t ruby3.3.1`. When cdxgen starts within the container, it will recognize this specific version request and attempt to install and use Ruby 3.3.1 for the duration of the scan, providing the highest possible accuracy for dependency resolution."}]}
{"messages": [{"role": "user", "content": "What does the `print` option do in a cdxgen configuration file?"}, {"role": "assistant", "content": "The `print` option in a cdxgen configuration file (like `.cdxgen.yml` or `.cdxgen.json`) corresponds to the `--print` command-line flag. When this option is set to `true`, it instructs cdxgen to display the generated Software Bill of Materials (SBOM) on the standard output (your console) in a human-readable format after the JSON BOM file has been created.\n\nThe output typically includes a summary table of the components found and a hierarchical dependency tree. This provides a quick and convenient way to visually inspect the results of the scan without having to open and parse the generated JSON file. For example, including `print: true` in your `.cdxgen.yml` is equivalent to adding `--print` to your command-line execution."}]}
{"messages": [{"role": "user", "content": "My cdxgen command is very long. How can I simplify it?"}, {"role": "assistant", "content": "If your cdxgen command has become very long and difficult to manage due to numerous arguments, the best way to simplify it is by using a configuration file. cdxgen supports configuration files in both YAML (`.cdxgen.yml` or `.cdxgen.yaml`) and JSON (`.cdxgenrc` or `.cdxgen.json`) formats. You can move all of your command-line arguments into this file, making your execution command much cleaner.\n\nFor example, instead of running `cdxgen -t java --output bom.json --only org.springframework --print`, you could create a `.cdxgen.yml` file with the following content:\n```yaml\ntype: java\noutput: bom.json\nonly: org.springframework\nprint: true\n```\nWith this file in your directory, you can simply run the `cdxgen` command with no arguments, and it will automatically pick up all the settings. This approach is excellent for reusability, consistency, and version controlling your SBOM generation settings alongside your project code."}]}
{"messages": [{"role": "user", "content": "How do I exclude files matching a glob pattern from the SBOM?"}, {"role": "assistant", "content": "To exclude files or directories that match a specific glob pattern from your Software Bill of Materials (SBOM), you should use the `--exclude` command-line argument. This argument is highly flexible and allows you to define patterns to ignore parts of your project that are not relevant to the final SBOM, such as documentation, test assets, or build artifacts.\n\nFor instance, if you want to exclude all files with a `.md` extension from your scan, you could use the pattern `\"**/*.md\"`. The `**` ensures the pattern is applied recursively throughout your entire project directory. You can use the `--exclude` argument multiple times to specify several different patterns. This is a powerful feature for fine-tuning the scope of your cdxgen scan and ensuring the resulting BOM is clean and focused."}]}
{"messages": [{"role": "user", "content": "What is the confidence value in an SBOM component, and how is it determined?"}, {"role": "assistant", "content": "The `confidence` value associated with a component in a CycloneDX SBOM represents the level of certainty that cdxgen has in its identification of that component, specifically regarding its Package URL (purl). This value is a decimal between 0 (no confidence) and 1 (complete confidence) and is found within the `evidence.identity` section of a component.\n\ncdxgen determines this value by evaluating the strength of the evidence it used to identify the component. For example, finding a component in a high-trust source like a `package-lock.json` file would result in a high confidence score. Conversely, identifying a component based only on a heuristic like a filename might result in a very low confidence score. The tool looks for the maximum confidence value associated with the `purl` field in the evidence to assign an overall confidence score to the component's identification. This score helps consumers of the SBOM gauge the reliability of the data."}]}
{"messages": [{"role": "user", "content": "Can cdxgen run inside a Lima VM on macOS?"}, {"role": "assistant", "content": "Yes, cdxgen is supported for use within a Lima VM (Linux virtual machine) on macOS. Lima is a tool that provides a Linux environment on macOS, and it is often used as the underlying technology for container engines like Rancher Desktop. The cdxgen documentation explicitly acknowledges this usage pattern.\n\nThe documentation refers to a dedicated `README.md` file within the repository for more details on Lima VM usage. This indicates that running cdxgen in this environment is a recognized and supported scenario. This is good news for developers on macOS who use Lima or Rancher Desktop for their containerized workflows, as they can integrate cdxgen for SBOM generation without expecting compatibility issues."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the 'taskTypes' array in the formulation workflow?"}, {"role": "assistant", "content": "The `taskTypes` array within a workflow object in the `formulation` section of an SBOM is used to describe the nature of the task that was performed during that workflow step. It provides a standardized way to classify the action, making the workflow more understandable to automated tools.\n\nThe documentation provides an example where the `taskTypes` array contains the single value `\"clone\"`. This clearly indicates that the workflow step involved cloning a source code repository, which corresponds to the git URL provided in the `inputs` section of the same workflow object. Other potential task types could include `build`, `test`, or `deploy`, allowing for a detailed and machine-readable description of the CI/CD process that led to the software artifact."}]}
{"messages": [{"role": "user", "content": "How do I create a BOM with only direct dependencies for my Node.js project?"}, {"role": "assistant", "content": "To create a Software Bill of Materials (SBOM) for your Node.js project that includes only the direct dependencies (the packages listed in your `package.json`), you can use the `--required-only` flag. This flag filters the dependency graph, removing all transitive dependencies (dependencies of your dependencies) from the final BOM.\n\nNode.js is one of the languages for which this feature is supported. When you run cdxgen with this flag, it analyzes the complete dependency tree but then includes only the components that have a `scope` of `required`. The command would be: `cdxgen -t nodejs --required-only -o bom.json .`. This is very useful for use cases where you are only concerned with the packages you have explicitly chosen to add to your project."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to get transitive dependencies for a legacy dotnet project?"}, {"role": "assistant", "content": "Yes, you can obtain a complete dependency tree, including transitive dependencies, for a legacy .NET project using cdxgen. However, it requires a crucial step: the `dotnet restore` command must be executed successfully. This command downloads all the necessary packages and generates the `project.assets.json` file, which cdxgen parses to build the full dependency graph.\n\nBecause legacy projects often require specific, older versions of the .NET SDK, the key is to run cdxgen in an environment that has the correct SDK installed. The cdxgen project provides special container images for this purpose, such as `ghcr.io/cyclonedx/cdxgen-dotnet:v12` for .NET Core 3.1 or .NET 6.0. By running the scan inside the appropriate container, you ensure that `dotnet restore` can run successfully, allowing cdxgen to discover and include all transitive dependencies in the final SBOM."}]}
{"messages": [{"role": "user", "content": "What are the benefits of using a `--deep` mode when generating an SBOM for a Java project?"}, {"role": "assistant", "content": "Using the `--deep` mode when generating an SBOM for a Java project provides a much more detailed and accurate dependency graph, which is especially important for advanced analysis like evidence generation. While a standard scan might rely solely on the `pom.xml` or `build.gradle` file, the deep mode often goes further, for instance by ensuring all dependencies are resolved and available for inspection.\n\nThe documentation highlights that `--deep` mode is a necessary prerequisite for generating reachability-based call stack evidence with `evinse`. This is because the deep scan gathers additional metadata and ensures the dependency artifacts (JAR files) are present, which the `atom` analysis engine needs to perform its detailed slicing and data flow tracing. While it may take slightly longer, the `--deep` flag produces a higher-fidelity SBOM suitable for security and compliance use cases."}]}
{"messages": [{"role": "user", "content": "How do I exclude both SNAPSHOT and test dependencies in a Maven project?"}, {"role": "assistant", "content": "To exclude both SNAPSHOT dependencies and test-scoped dependencies from your Maven project's SBOM, you can leverage the `MVN_ARGS` environment variable to pass multiple filtering arguments to the underlying Maven command. Maven's `dependency:tree` command supports excluding dependencies by scope and by version pattern.\n\nYou would set the `MVN_ARGS` variable to include both an `excludes` pattern for SNAPSHOTs and the `includeScope` parameter to limit the scope. For example: `export MVN_ARGS=\"-Dexcludes=:::*-SNAPSHOT -DincludeScope=runtime\"`. The `-Dexcludes=:::*-SNAPSHOT` part filters out any dependency with a version ending in `-SNAPSHOT`. The `-DincludeScope=runtime` part tells Maven to only include dependencies that are needed at runtime, which implicitly excludes `test`, `provided`, and `system` scoped dependencies. When you run cdxgen with this environment variable set, the resulting SBOM will be much cleaner and focused on production artifacts."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support projects using Java 17?"}, {"role": "assistant", "content": "Yes, cdxgen supports projects built with Java 17. To ensure proper analysis and dependency resolution, it's recommended to use an environment that has the Java 17 JDK. The cdxgen project provides specific container images for this purpose, making it easy to create a compatible build environment.\n\nYou can use the `ghcr.io/cyclonedx/cdxgen-java17:v12` or the `ghcr.io/cyclonedx/cdxgen-java17-slim:v12` container image. Alternatively, if you are running the cdxgen CLI on a machine with `sdkman` installed, you can use the type argument `-t java17`. This signals to cdxgen that it should use a Java 17 JDK for the analysis. This is crucial for projects that use Java 17 language features or depend on libraries compiled for that version."}]}
{"messages": [{"role": "user", "content": "I'm using a Mac with an M1 chip. What should I be aware of when running cdxgen containers?"}, {"role": "assistant", "content": "When using a Mac with an M1/M2/M3 chip (which has an ARM64 architecture), you should be aware of potential compatibility issues when running container images that are primarily built for the x86-64 (amd64) architecture. While Docker Desktop's Rosetta 2 emulation is very effective, some tools, particularly those involving native code compilation like in the npm ecosystem, can be sensitive to the underlying architecture.\n\nThe cdxgen documentation frequently recommends using the `--platform=linux/amd64` flag when running certain containers, even on an ARM64 Mac. This flag explicitly tells the container runtime to pull and run the `amd64` version of the image using emulation. This can often resolve subtle bugs or failures, particularly with `npm install` steps, by providing a more stable and widely compatible execution environment. For example, this is recommended for some of the .NET and older Node.js images."}]}
{"messages": [{"role": "user", "content": "What is the protobuf specification version supported by cdxgen?"}, {"role": "assistant", "content": "When you choose to export your Software Bill of Materials (SBOM) from cdxgen as a binary protobuf file using the `--export-proto` flag, there is a specific version of the CycloneDX specification that is supported. According to the documentation, this feature is limited to generating BOMs that adhere to version 1.5 of the CycloneDX specification.\n\nThis is an important constraint to be aware of. If your use case requires features from a newer version of the specification, such as the enhanced cryptography support in version 1.6, you would need to use the standard JSON output format instead. The protobuf export is optimized for the structure and fields available in the 1.5 spec."}]}
{"messages": [{"role": "user", "content": "Can I see an example of the `formulation` data for a platform component?"}, {"role": "assistant", "content": "Yes, the `formulation` section that can be included in a BOM with the `--include-formulation` flag also captures information about the build platforms and tools discovered on the system. It represents these as components of type `platform`. This provides a snapshot of the toolchain used to build the software.\n\nHere is an example from the documentation showing a platform component for `dotnet`:\n```json\n{\n  \"type\": \"platform\",\n  \"name\": \"dotnet\",\n  \"version\": \"8.0.101\",\n  \"description\": \"Microsoft.AspNetCore.App 6.0.26 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\\\\nMicrosoft.AspNetCore.App 8.0.1 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\\\\nMicrosoft.NETCore.App 6.0.26 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\\\\nMicrosoft.NETCore.App 8.0.1 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\"\n}\n```\nThis shows the main SDK version (`8.0.101`) and a detailed description listing all the installed runtimes and shared frameworks. Similar entries would be created for other detected tools like `rustc` and `go`."}]}
{"messages": [{"role": "user", "content": "How do I exclude the 'kubernetes-maven-plugin' directory from my scan?"}, {"role": "assistant", "content": "To exclude a specific directory like `kubernetes-maven-plugin` from your cdxgen scan, you should use the `--exclude` argument with a glob pattern that will match this directory wherever it appears in your project. This is useful for ignoring build-tool-specific directories that aren't part of your application's distributable code.\n\nThe most effective pattern for this would be `\"**\/kubernetes-maven-plugin/**\"`. The `**` at the beginning and end of the pattern ensures that the directory is matched regardless of its depth in the project structure and that all of its contents are also excluded. You could also use brace expansion to exclude it along with similar plugins, for example: `--exclude \"**\/{openshift,kubernetes}-maven-plugin/**\"`, which is a more concise way to exclude both plugins in one argument."}]}
{"messages": [{"role": "user", "content": "What is the default behavior of cdxgen when no lifecycle is specified for an application scan?"}, {"role": "assistant", "content": "When you run cdxgen to scan application source code and do not specify a lifecycle phase, it defaults to generating a Bill of Materials for the `build` lifecycle phase. The `build` phase, as defined in the CycloneDX specification, is intended to represent the composition of the software and its dependencies at the time of compilation or assembly.\n\nThis is the most logical default for source code analysis because the primary goal is typically to understand the dependencies that are pulled in and used during the build process. This is in contrast to container image scans, where the default is `post-build` because the image is a final artifact, or scans using `--no-install-deps`, which can produce a `pre-build` BOM."}]}
{"messages": [{"role": "user", "content": "Is there a way to generate a `pre-build` BOM for a Python project?"}, {"role": "assistant", "content": "Yes, you can generate a `pre-build` Bill of Materials (BOM) for a Python project using cdxgen. A `pre-build` BOM describes the dependencies as they are declared in your manifest files (like `requirements.txt`) before they are actually installed and resolved. This can be useful for understanding the intended dependencies of a project.\n\nTo achieve this, you need to use the `--no-install-deps` argument. This flag prevents cdxgen from running `pip install` to create a concrete environment. Instead, it will rely solely on parsing the manifest file to list the declared dependencies. By disabling the package installation feature, you are effectively capturing the state of the project before the build process resolves the full dependency tree, which corresponds to the `pre-build` lifecycle phase."}]}
{"messages": [{"role": "user", "content": "How can I check the version of the go toolchain captured by `--include-formulation`?"}, {"role": "assistant", "content": "When you use the `--include-formulation` flag, cdxgen captures information about the build environment, including the versions of detected toolchains. To check the version of the Go toolchain that was captured, you would need to inspect the generated JSON BOM file and look for a specific entry in the `formulation` section.\n\nInside the `formulation[0].components` array, you should look for a component object where `\"type\": \"platform\"` and `\"name\": \"go\"`. The `version` field of this object will contain the string reported by the `go version` command on the system where cdxgen was run. For example, it might look like this: `\"version\": \"go version go1.21.6 linux/amd64\"`. This provides a precise record of the toolchain used for the build."}]}
{"messages": [{"role": "user", "content": "Can cdxgen produce an SBOM for a project with no lock file?"}, {"role": "assistant", "content": "Yes, cdxgen can often produce a Software Bill of Materials (SBOM) even for projects that do not have a lock file (like `package-lock.json` or `pom.xml`). However, the accuracy and completeness of the SBOM may be reduced. Without a lock file, which provides a definitive, reproducible list of exact dependency versions, cdxgen has to rely on other methods.\n\nFor many ecosystems (like Node.js or Python), cdxgen will attempt to install the dependencies based on the primary manifest file (e.g., `package.json` or `requirements.txt`). This will create a dependency tree based on the latest compatible versions available at that moment, which might not be the same as what a different developer or a CI system would get. The resulting SBOM will reflect this dynamically resolved tree. Therefore, while possible, it is always recommended to have and use lock files to generate the most accurate and reproducible SBOM."}]}
{"messages": [{"role": "user", "content": "What is the default profile for cdxgen if I don't specify one?"}, {"role": "assistant", "content": "If you do not specify a BOM profile when running cdxgen, it will use the `generic` profile by default. The `generic` profile is designed to provide a standard, well-rounded Software Bill of Materials without enabling any specialized, use-case-specific configurations.\n\nThis default behavior ensures that users get a sensible and useful SBOM out-of-the-box without needing to know about the advanced profile options. The `generic` profile does not enable features like `deep` mode or `evidence` mode automatically. If you need a BOM tailored for a specific purpose, such as application security (`appsec`), research (`research`), or license compliance, you would need to explicitly select that profile in your command or configuration file."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen on an Android project with both Java and Kotlin code?"}, {"role": "assistant", "content": "Yes, cdxgen can be used to generate a Software Bill of Materials (SBOM) for a typical Android project that contains both Java and Kotlin code. Modern Android development almost always involves this mix, and the dependency management for both languages is handled by the same build system, which is Gradle.\n\nWhen you run cdxgen on an Android project (typically by specifying `-t gradle` or letting it auto-detect), it will invoke Gradle to determine the project's dependencies. Gradle resolves dependencies for both Java and Kotlin code from repositories like Maven Central and Google's Maven Repository. Therefore, cdxgen will capture all the libraries (both Java and Kotlin-based) that your Android application depends on, providing a unified and complete SBOM for the entire project."}]}
{"messages": [{"role": "user", "content": "How do I exclude a directory using a regular expression with cdxgen?"}, {"role": "assistant", "content": "The `--exclude` argument in cdxgen uses glob patterns, not regular expressions, to match files and directories for exclusion. While glob patterns are very powerful and can handle most common use cases, they have a different syntax and capabilities than regular expressions. There is no direct way to provide a standard regular expression to the `--exclude` flag.\n\nGlob patterns are designed for matching file paths and use wildcards like `*` (matches any characters except a path separator), `?` (matches a single character), and `**` (matches zero or more directories). For most exclusion needs, such as ignoring build folders, test directories, or documentation files, glob patterns are sufficient and often more intuitive than regular expressions. For example, to exclude all `.log` files, you would use `\"**/*.log\"`, not a regex pattern."}]}
{"messages": [{"role": "user", "content": "How can I verify the integrity of the downloaded atom.zip release?"}, {"role": "assistant", "content": "The provided `ADVANCED.md` document does not contain specific instructions on how to verify the integrity of the downloaded `atom.zip` release file. However, standard best practices for verifying downloaded software releases should be followed. Typically, a project will publish checksums (like SHA-256 or SHA-512 hashes) and/or PGP signatures alongside their release files on the releases page.\n\nTo verify the integrity, you would navigate to the Atom releases page on GitHub (https://github.com/AppThreat/atom/releases). Look for a file containing the checksums (often named `checksums.txt` or similar). After downloading `atom.zip`, you would calculate its SHA-256 hash on your local machine (e.g., using `shasum -a 256 atom.zip` on macOS/Linux or `certutil -hashfile atom.zip SHA256` on Windows) and compare the result with the hash published by the project. If they match, you can be confident that the file has not been corrupted or tampered with during download."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `--input` or `-i` option in evinse?"}, {"role": "assistant", "content": "The `--input` (or its shorthand `-i`) option in the `evinse` tool is used to specify the path to the input Software Bill of Materials (SBOM) file that you want to enrich with evidence. The `evinse` tool's primary function is not to create an SBOM from scratch, but rather to take an existing BOM and add detailed evidence of component usage to it.\n\nBy default, `evinse` looks for a file named `bom.json` in the current directory. However, if your input SBOM has a different name or is located in a different directory, you must use the `--input` option to point `evinse` to the correct file. For example: `evinse -i /path/to/my-project-bom.json -o bom.evinse.json .`. This command tells evinse to read the component list from `/path/to/my-project-bom.json` before starting its analysis."}]}
{"messages": [{"role": "user", "content": "How do I specify the output file for the SBOM generated by evinse?"}, {"role": "assistant", "content": "To specify the name and location of the output SBOM file generated by the `evinse` tool, you should use the `--output` (or its shorthand `-o`) option. This file will be a new SBOM that contains all the information from the input BOM, plus the new `evidence` sections that `evinse` generates from its code analysis.\n\nBy default, `evinse` will write its output to a file named `bom.evinse.json` in the current directory. If you want to use a different name or save it to a different location, you must provide the path with the `--output` flag. For example, the command `evinse -i bom.json -o /tmp/evidence-bom.json .` will perform the analysis and save the final, enriched BOM to the `/tmp` directory with the name `evidence-bom.json`."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen with a project that uses both npm and yarn?"}, {"role": "assistant", "content": "Yes, cdxgen can handle JavaScript projects that may have artifacts from both `npm` and `yarn`, such as having both a `package-lock.json` and a `yarn.lock` file. In such cases, cdxgen has a priority system to decide which lock file to use to ensure a deterministic build of the dependency tree. Typically, cdxgen will prioritize one lock file over the other based on its implementation logic (often prioritizing `package-lock.json` if both are present, but this can vary).\n\nFor the most accurate and predictable results, it is a best practice for a project to be standardized on a single package manager and have only one lock file. If both are present, it might be a sign of an inconsistent development environment. cdxgen will produce an SBOM, but it will be based on the dependency tree from only one of the lock files, which might not be the one you primarily use. You can ensure consistency by removing the unused lock file from your project."}]}
{"messages": [{"role": "user", "content": "I see `bom-ref` and `uid` in the workflow object. What is the key difference?"}, {"role": "assistant", "content": "The `bom-ref` and `uid` attributes in a workflow object serve different purposes related to identification. The key difference lies in their scope. The `bom-ref` is a locally scoped identifier. Its only purpose is to be unique *within* the current BOM document, allowing other elements inside the same BOM to reference this specific workflow object. It's an internal pointer.\n\nThe `uid`, on the other hand, is a globally scoped identifier. It is intended to be unique across all BOMs, systems, and time. It is often a UUID and provides a stable, universal handle for a specific instance of a build or workflow execution. While `bom-ref` is for internal document linking, `uid` is for external correlation and tracking across a wider ecosystem of tools and processes."}]}
{"messages": [{"role": "user", "content": "Will running `evinse` modify my input BOM file?"}, {"role": "assistant", "content": "No, running the `evinse` tool will not modify your input BOM file. The tool is designed to work in a non-destructive way. It reads the component information from the input file specified with the `--input` flag (or the default `bom.json`), performs its code analysis, and then writes the enriched data to a new output file.\n\nThe output file is specified with the `--output` flag, and it defaults to `bom.evinse.json`. This clear separation of input and output ensures that your original SBOM remains untouched, allowing you to compare the before and after versions or re-run the evidence generation process without risk of corrupting your source data. It's a safe and standard practice for command-line tools that transform data."}]}
{"messages": [{"role": "user", "content": "How can I prevent the `quickstarts` and `plugin` directories from being scanned?"}, {"role": "assistant", "content": "To prevent both the `quickstarts` directory and a `plugin` directory from being scanned by cdxgen, you can use the `--exclude` argument multiple times or use brace expansion for a more concise command. The `--exclude` argument accepts a glob pattern to identify the paths to ignore.\n\nUsing multiple arguments, your command would look like this: `cdxgen --exclude \"**/quickstarts/**\" --exclude \"**/plugin/**\"`. This is clear and explicit. Alternatively, you can use brace expansion to combine these into a single argument: `cdxgen --exclude \"**/{quickstarts,plugin}/**\"`. This single argument will be expanded by the shell or the tool into the two separate patterns, achieving the same result of excluding both directory trees from the SBOM generation process."}]}
{"messages": [{"role": "user", "content": "What happens if my `sdkman` is not set up correctly when I run `cdxgen -t java11`?"}, {"role": "assistant", "content": "If you run `cdxgen -t java11` and your `sdkman` installation is not set up correctly, the command will likely fail. The ability for cdxgen to use a specific Java version via the type argument (like `java11` or `java17`) is dependent on having `sdkman` properly installed and configured in your shell environment. `sdkman` is a tool for managing parallel versions of multiple Software Development Kits, including Java.\n\nWhen you use `-t java11`, cdxgen attempts to use `sdkman` to switch to a Java 11 environment to run its analysis. If `sdkman` is not found, not in your system's PATH, or if it doesn't have a Java 11 JDK installed, cdxgen will not be able to find the required toolchain. This will typically result in an error message indicating that the Java command could not be found or that the build failed, and the SBOM generation will be aborted. For this feature to work, a functional `sdkman` setup with the desired Java version installed is a prerequisite."}]}
{"messages": [{"role": "user", "content": "What is `cdxgen-plugins-bin` and why is it needed?"}, {"role": "assistant", "content": "The `@cyclonedx/cdxgen-plugins-bin` is an npm package that provides a set of pre-compiled, platform-specific binary tools that cdxgen uses for some of its advanced features. cdxgen itself is a Node.js application, but for certain tasks, it relies on external helper applications written in other languages like Go for better performance or to access system-level capabilities.\n\nThis package is needed to support features that go beyond standard JavaScript-based analysis. A key example mentioned in the documentation is the generation of SBOMs for container images. The logic for pulling, inspecting, and extracting container layers is handled by a binary included in this package. By bundling these necessary binaries into a separate, easy-to-install npm package, cdxgen can maintain a modular architecture while still providing powerful, cross-platform capabilities."}]}
{"messages": [{"role": "user", "content": "What does the `db-path` option in evinse do?"}, {"role": "assistant", "content": "The `--db-path` option in the `evinse` tool allows you to specify a custom location for its cache database file, `.atomdb`. By default, `evinse` creates this SQLite database in a standard, user-specific data directory (e.g., `~/.local/share/.atomdb` on Linux). This option gives you control over where this potentially large and important file is stored.\n\nThere are several reasons you might want to use `--db-path`. You might want to store the cache on a faster drive to improve performance, or place it in a project-specific directory to keep all related artifacts together. It's also useful in CI/CD environments where you might want to cache the database file between job runs to speed up the process, and you need to specify an exact path within the CI system's cache directory. The path can also be set using the `ATOM_DB` environment variable."}]}
{"messages": [{"role": "user", "content": "What does it mean that the `technique` filter is implemented during 'post-processing'?"}, {"role": "assistant", "content": "When the documentation states that the `--technique` filter is implemented during 'post-processing', it means that the filtering logic is applied *after* all the initial component discovery has already taken place. cdxgen does not prevent the unused analysis techniques from running; instead, it runs all of them, gathers all the potential components they find, and then, as a final step, it filters this complete list to keep only the components that were discovered by the techniques you specified.\n\nThis has a significant implication for performance. Because all the analysis work is still performed upfront, using this filter will not make your cdxgen scan run any faster. Its purpose is not to optimize the scan by skipping work, but rather to control the content of the final report. You would use it to generate a BOM that, for policy or research reasons, must only contain components vouched for by a specific discovery method, such as `manifest-analysis`."}]}
{"messages": [{"role": "user", "content": "My SBOM is huge. How can I create a smaller one with only essential dependencies?"}, {"role": "assistant", "content": "If your generated SBOM is very large, it's likely because it includes all transitive dependencies, development dependencies, and optional dependencies. To create a smaller, more focused SBOM with only the essential components, you can use the `--required-only` filter. This flag instructs cdxgen to include only components that are considered direct, required dependencies of your project.\n\nThis is often the most effective way to reduce the size of the BOM while retaining the most critical information. The command `cdxgen --required-only` will prune the dependency tree, leaving only the packages you have explicitly defined as necessary in your project's manifest (like `pom.xml` or `package.json`). This feature is supported for several major languages, including Java (Maven), Node.js, Go, and PHP, and is ideal for creating a concise overview of your project's primary dependencies."}]}
{"messages": [{"role": "user", "content": "How do I create a JSON file with my cdxgen configuration?"}, {"role": "assistant", "content": "To create a JSON file with your cdxgen configuration, you need to create a file named either `.cdxgenrc` or `.cdxgen.json` in the root directory of your project. Inside this file, you will create a JSON object where the keys are the long-form names of the cdxgen command-line arguments, and the values are the settings you want to apply.\n\nFor example, if you want to configure cdxgen to scan a `java` project, save the output to `my-bom.json`, and also print a summary to the console, your `.cdxgen.json` file would look like this:\n```json\n{\n  \"type\": \"java\",\n  \"output\": \"my-bom.json\",\n  \"print\": true\n}\n```\nWhen you run the `cdxgen` command in this directory, it will automatically detect and apply these settings without you needing to type them on the command line."}]}
{"messages": [{"role": "user", "content": "Can cdxgen detect the version of the Rust compiler used?"}, {"role": "assistant", "content": "Yes, cdxgen can detect the version of the Rust compiler (`rustc`) used in the build environment, provided you enable the correct option. To capture this kind of metadata, you need to use the `--include-formulation` flag when you run your cdxgen command.\n\nWhen this flag is active, cdxgen will execute commands to identify the versions of various build tools on the system. For a Rust environment, it will capture the output of `rustc --version` and `cargo --version`. This information is then added to the `formulation` section of the BOM as a component of type `platform`. This provides a valuable, auditable record of the exact toolchain that was used, which is crucial for reproducible builds and security analysis."}]}
{"messages": [{"role": "user", "content": "How can I check the version of the dotnet SDK in the default cdxgen container?"}, {"role": "assistant", "content": "The `ADVANCED.md` documentation provides information about the version of the .NET SDK bundled in the official cdxgen container image. It states that the default `ghcr.io/cyclonedx/cdxgen` image bundles version 8.0 of the SDK. This is important information for users trying to generate SBOMs for .NET projects, as the project's target framework must be compatible with the SDK version available in the container.\n\nIf you need to verify this yourself or check a different image, you could run a command inside the container to print the version. For example: `docker run --rm -it ghcr.io/cyclonedx/cdxgen dotnet --version`. This would execute the `dotnet --version` command inside the container and print the result, confirming the exact SDK version it contains."}]}
{"messages": [{"role": "user", "content": "My company uses nerdctl. Can I use the Nydus image with it?"}, {"role": "assistant", "content": "Yes, you can absolutely use the Nydus-formatted cdxgen container images with `nerdctl`. In fact, `nerdctl` is one of the container runtimes that has good support for Nydus. To make it work, your `nerdctl` installation must be configured to use the Nydus snapshotter, which is the component responsible for handling the lazy-loading of Nydus images.\n\nThe documentation provides a direct example of how to invoke a Nydus image using `nerdctl`: `sudo nerdctl --snapshotter nydus run ... ghcr.io/cyclonedx/cdxgen:master-nydus ...`. The key part of this command is the `--snapshotter nydus` flag, which explicitly tells `nerdctl` to use the Nydus system for running the container. This setup allows you to take full advantage of the performance benefits of Nydus, such as faster container startup times."}]}
{"messages": [{"role": "user", "content": "What is the `version` field for a file component in the `formulation` section?"}, {"role": "assistant", "content": "In the `formulation` section of a BOM generated with the `--include-formulation` flag, you will find entries for each file in the source repository. These are represented as components of type `file`. For these components, the `version` field has a specific meaning: it stores the git object hash (SHA-1) of that file for the specific commit being analyzed.\n\nFor example, an entry might look like this: `{\"type\": \"file\", \"name\": \"pom.xml\", \"version\": \"8da3449df64e6eb1d63ca3ca5fbd123a374d738e\"}`. Here, the `version` is the git hash of the `pom.xml` file. This provides an extremely precise and tamper-proof way to record the exact state of every source file at the moment the SBOM was created. It makes the build completely reproducible and auditable, as you can verify that the source files have not changed."}]}
{"messages": [{"role": "user", "content": "Why might a cdxgen scan of a Ruby project fail?"}, {"role": "assistant", "content": "A cdxgen scan of a Ruby project might fail for several reasons, but a very common one is an incompatibility between the Ruby version required by the project and the Ruby version available in the cdxgen execution environment. Ruby projects often specify a required Ruby version in their `Gemfile` or `.ruby-version` file. If the `ruby` command in the environment is a different version, the `bundle install` command that cdxgen runs internally may fail.\n\nTo prevent this, it is highly recommended to use a cdxgen container image that matches your project's Ruby version. For example, if your project needs Ruby 3.3.x, you should use the `ghcr.io/cyclonedx/cdxgen-debian-ruby33:v12` image. Furthermore, these images support automatic installation of specific patch versions (e.g., by using `-t ruby3.3.1`), which provides even greater compatibility and reduces the chances of a version-mismatch failure."}]}
{"messages": [{"role": "user", "content": "How do I generate an SBOM for just the 'runtimeClasspath' configuration in Gradle?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) that only includes dependencies from the `runtimeClasspath` configuration in a Gradle project, you can use the `GRADLE_ARGS` environment variable. This variable allows you to pass specific command-line arguments to the Gradle process that cdxgen invokes.\n\nBefore running cdxgen, you would set the environment variable in your shell like this: `export GRADLE_ARGS=\"--configuration runtimeClasspath\"`. The `--configuration` argument is a standard Gradle flag that tells it to resolve the dependency graph for a specific configuration. When you then run `cdxgen`, it will pass this argument to Gradle, resulting in a dependency tree and a final SBOM that contains only the dependencies needed for the application's runtime, excluding compile-time or test-only dependencies."}]}
{"messages": [{"role": "user", "content": "What is `cdxgen-secure` and how is it different from the default image?"}, {"role": "assistant", "content": "The `ghcr.io/cyclonedx/cdxgen-secure:master` image is a variant of the main cdxgen container that is configured to be more secure by default. The key difference lies in its use of the Node.js permissions model. While the standard `cdxgen:master` image has the permissions model available as an opt-in feature, the `cdxgen-secure` image has it enabled by default.\n\nThis means that when you run `cdxgen-secure`, the Node.js process is sandboxed and has restricted access to the filesystem, network, and other system resources. This aligns with the principle of least privilege and helps mitigate risks from potential vulnerabilities in the tool or its dependencies. It is the recommended choice for users in high-security environments who want to run their supply chain tooling with an extra layer of protection."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen on a project without an internet connection?"}, {"role": "assistant", "content": "Using cdxgen on a project without an internet connection can be challenging and may result in an incomplete SBOM. By default, cdxgen often needs to connect to the internet to perform several tasks, such as downloading package metadata from registries (like npm, PyPI, or Maven Central) or even installing dependencies to resolve a full dependency tree.\n\nTo make it work offline, you would need to ensure that all dependencies are already cached locally. For a Java project, this would mean having a complete `.m2` or Gradle cache. For Node.js, it would mean having a complete `node_modules` directory and a lockfile. You might also need to configure package managers to work in an offline mode. Some cdxgen features, like fetching license texts, would also fail. While it can work in a limited fashion, for a complete and accurate SBOM, an internet connection is generally required."}]}
{"messages": [{"role": "user", "content": "What does the 'incomplete' value for 'compositions.aggregate' signify?"}, {"role": "assistant", "content": "When the `compositions.aggregate` property in a CycloneDX BOM is set to `incomplete`, it serves as a clear warning to any person or tool that consumes the BOM. It signifies that the list of components contained within the SBOM is not a full and complete representation of all the software components in the product. The list has been intentionally or unintentionally truncated.\n\nc-dxgen automatically sets this value whenever you use one of its filtering features, such as `--exclude`, `--filter`, or `--required-only`. Since these filters remove components from the final list, the resulting BOM is, by definition, incomplete. This metadata is crucial for proper interpretation, preventing a user from incorrectly assuming that a component not listed in the BOM is not present in the software."}]}
{"messages": [{"role": "user", "content": "How can I find the most up-to-date cdxgen container image?"}, {"role": "assistant", "content": "To find the most up-to-date cdxgen container image, you should look for images with tags like `master` or `latest` on the official container registry, which is GitHub Container Registry (ghcr.io). For example, the `ghcr.io/cyclonedx/cdxgen:master` tag typically points to the all-in-one image built from the latest commit on the main branch of the source code repository.\n\nWhile these tags give you the newest version, for reproducible builds in a production or CI/CD environment, it is strongly recommended to use a specific version tag (e.g., `9.9.5`) or a sha256 digest instead. You can browse the available tags and their publication dates on the GitHub Packages page for the cdxgen repository (https://github.com/CycloneDX/cdxgen/pkgs/container/cdxgen) to find the latest stable release version."}]}
{"messages": [{"role": "user", "content": "I have a project using .Net 10 preview. Can cdxgen handle this?"}, {"role": "assistant", "content": "Yes, cdxgen provides support for even the most recent preview versions of the .NET SDK, including .NET 10. To handle projects targeting such a new version, the project maintains a specific container image that bundles the corresponding preview SDK. This ensures that the `dotnet restore` and build analysis steps will succeed.\n\nThe documentation lists the `ghcr.io/cyclonedx/cdxgen-debian-dotnet10:v12` as the preview image for .NET 10. By running your cdxgen scan inside this container, you provide the correct environment with the necessary tools to understand the project structure and dependencies of an application built against the .NET 10 preview, allowing you to generate an accurate SBOM well before the official release."}]}
{"messages": [{"role": "user", "content": "Why is it important to run the PowerShell terminal as administrator on Windows for container scans?"}, {"role": "assistant", "content": "It is important to run your PowerShell terminal as an administrator on Windows when generating container SBOMs with cdxgen due to file system permission requirements. The process of analyzing a container image involves cdxgen extracting the image's layers to a temporary location on your local disk. Linux-based container images frequently contain symbolic links (symlinks).\n\nOn the Windows operating system, the creation of symbolic links is a privileged operation that requires administrative rights. If you run PowerShell in a standard user session, the extraction process will fail when it encounters a symlink because the cdxgen process will not have the necessary permissions to create it. Running the terminal as an administrator elevates the privileges of the cdxgen process, allowing it to correctly handle symlinks and successfully extract all the container layers for a complete analysis."}]}
{"messages": [{"role": "user", "content": "Can I filter components by their group ID in a Java project?"}, {"role": "assistant", "content": "Yes, you can effectively filter components by their group ID in a Java project using the `--filter` argument. The Package URL (purl) for a Maven component follows the format `pkg:maven/<groupId>/<artifactId>@<version>`. Since the `groupId` is part of the purl string, you can use `--filter` to match it.\n\nFor example, to create an SBOM that only includes components from the `org.apache.logging` group, you would run your command with the flag: `cdxgen --filter org.apache.logging`. cdxgen will perform a case-insensitive search for this string in the purl of every dependency. Any component whose purl contains `org.apache.logging` (which would match the group ID) will be included in the final BOM. This provides a simple and effective way to filter by namespace or group."}]}
{"messages": [{"role": "user", "content": "Can I get a software bill of materials for my Python project?"}, {"role": "assistant", "content": "Yes, you can absolutely get a Software Bill of Materials (SBOM) for your Python project using cdxgen. Python is a well-supported language, and cdxgen can generate a detailed list of your project's dependencies by analyzing its package manifest files, such as `requirements.txt`, `Pipfile.lock`, or `pyproject.toml`.\n\nTo ensure the highest accuracy, especially for projects with specific Python version requirements, it's recommended to use a cdxgen container image that matches your project's Python version (e.g., `ghcr.io/cyclonedx/cdxgen-python311:v12` for Python 3.11). You would run a command like `cdxgen -t python -o bom.json .`. This will invoke `pip` (or other relevant tools) to resolve the full dependency tree, including transitive dependencies, and create a comprehensive SBOM in CycloneDX format."}]}
{"messages": [{"role": "user", "content": "What is the difference between a `slim` image and a non-slim image for cdxgen?"}, {"role": "assistant", "content": "The main difference between a `slim` cdxgen container image and its corresponding non-slim counterpart lies in their size and the number of included tools and libraries. The `slim` images are designed to be more lightweight and have a smaller disk footprint. They achieve this by being based on a minimal base image (like a slim Debian or Alpine) and including only the essential dependencies required for cdxgen to function for that specific language.\n\nThe non-slim images are more comprehensive. They are larger because they include a wider array of build tools, compilers, and development libraries. This makes them a safer, more robust choice for complex projects that might have unusual build steps or system-level dependencies. You would choose a `slim` image to optimize for speed and size in a CI/CD pipeline, provided your project's build is simple enough to work in that minimal environment. Otherwise, the standard, non-slim image is the more versatile option."}]}
{"messages": [{"role": "user", "content": "How do I use cdxgen to list only the packages from the 'org.springframework' group?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) that lists only packages belonging to the `org.springframework` group, you should use the `--only` filter. This filter is specifically designed to create a focused BOM containing only components whose Package URL (purl) matches a given string. Since the group ID is part of the purl for Maven packages, this is the perfect tool for the job.\n\nThe command you would use is: `cdxgen -t java -o /tmp/bom.json --only org.springframework`. This instructs cdxgen to scan the entire dependency graph but to only include components in the final BOM if the string `org.springframework` is present in their purl. This will effectively isolate all Spring Framework and related Spring project dependencies into a single, clean report, while also automatically marking the BOM as `incomplete_first_party_only` to reflect the filtering."}]}
{"messages": [{"role": "user", "content": "How can I check what command-line arguments are available for the `evinse` tool?"}, {"role": "assistant", "content": "To see a complete and detailed list of all the available command-line arguments and options for the `evinse` tool, you can use the built-in help flag. This is a standard feature of most command-line applications and provides the most accurate and up-to-date information directly from the tool itself.\n\nSimply open your terminal and run the `evinse` command with the `-h` or `--help` flag: `evinse -h`. This will print a formatted help message to your console, listing all the available options (like `-i`, `-o`, `--with-data-flow`), their shorthand versions, a brief description of what each one does, and any default values. This is the best way to explore the tool's capabilities and understand how to use its various features."}]}
{"messages": [{"role": "user", "content": "What is 'Forward-Reachability' analysis in evinse?"}, {"role": "assistant", "content": "Forward-Reachability is the name of the code analysis technique used by `evinse` when you generate reachability-based call stack evidence (using the `--with-reachables` flag). It's a type of static analysis that traces the potential flow of data and execution through an application in a forward direction. The analysis starts from the application's entry points, which are considered sources of data and control flow.\n\nFrom these sources, the analysis engine traces all possible paths the code execution can take. It follows function calls and data assignments through your application's code until it reaches a call to a function within an external, third-party library. These external library calls are considered sinks. The resulting path from a source to a sink constitutes the call stack evidence, proving that your application can, in fact, reach and execute code from that specific library."}]}
{"messages": [{"role": "user", "content": "Is it possible to use cdxgen on a project with a mix of C and C++ code?"}, {"role": "assistant", "content": "Yes, cdxgen can be used on projects that contain a mix of C and C++ source code. The tool is designed to handle polyglot projects, and its C/C++ analysis capabilities can identify components and dependencies from both languages within the same codebase. You would typically specify the project type as `-t c` or `-t cpp`, and the scanner would analyze the relevant source files (`.c`, `.h`, `.cpp`, `.hpp`, etc.).\n\nHowever, it's important to remember that component identification in C/C++ can be less precise than in languages with centralized package managers. The tool may rely on heuristics like source code comments, filenames, or embedded strings. This can sometimes lead to lower confidence scores for the identified components. Using flags like `--min-confidence` can help filter out less certain results in these mixed C/C++ projects."}]}
{"messages": [{"role": "user", "content": "What happens if I forget to run Docker as an administrator on Windows when scanning a container?"}, {"role": "assistant", "content": "If you forget to run Docker for Desktop and your terminal as an administrator on Windows before attempting to generate a container SBOM with cdxgen, the scan is very likely to fail. The process requires elevated privileges for several key operations.\n\nThe primary point of failure will be the extraction of the container image layers. Linux-based images often contain symbolic links (symlinks), and creating these on a Windows filesystem requires administrative rights. When the cdxgen process, running with standard user permissions, tries to create a symlink, the operating system will deny the request. This will cause the extraction process to halt with a permission error, and cdxgen will be unable to complete the scan and generate the SBOM."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the 'version' in a file component within the formulation section?"}, {"role": "assistant", "content": "Within the `formulation` section of a BOM, which is generated when using the `--include-formulation` flag, each file from the git repository is listed as a `file` type component. For these file components, the `version` field serves a very specific and critical purpose: it stores the git blob hash (SHA-1) of the file's content for that particular commit.\n\nThis is different from a typical software version number. Instead, it's a cryptographic hash that uniquely identifies the exact state of that file's content. For example, `\"version\": \"eba1110b5794582b53554bb1e4224b860d4e173f\"` is the precise identifier for the content of the `.gitattributes` file at the time of the scan. This provides an immutable and verifiable record, making the SBOM and the build process highly auditable and reproducible."}]}
{"messages": [{"role": "user", "content": "My Ruby project uses version 2.5.1. How can I get an accurate SBOM?"}, {"role": "assistant", "content": "To get an accurate Software Bill of Materials (SBOM) for a legacy Ruby project that requires a specific version like 2.5.1, you need to use a cdxgen environment that can replicate that exact Ruby runtime. The cdxgen project provides a dedicated container image for the Ruby 2.5.x series for this purpose: `ghcr.io/cyclonedx/cdxgen-ruby25:v12`.\n\nA key feature of this image is its ability to automatically install a specific patch version of Ruby upon request. To ensure version 2.5.1 is used, you would pass the type argument with the full version number: `-t ruby2.5.1`. When you run cdxgen with this argument inside the `cdxgen-ruby25` container, it will install and use Ruby 2.5.1 to execute `bundle install`, ensuring that your project's dependencies are resolved with full fidelity to the original environment."}]}
{"messages": [{"role": "user", "content": "I want to create a BOM for license checking. What's the best way?"}, {"role": "assistant", "content": "The best way to create a Bill of Materials (BOM) specifically for license checking and compliance is to use the `license-compliance` profile provided by cdxgen. This profile is tailored to generate a BOM that is rich in the license information required by legal teams and automated compliance tools.\n\nWhen you use this profile, either through the command line or a configuration file, it automatically enables the `FETCH_LICENSE` environment variable. This setting instructs cdxgen to make a more aggressive effort to discover and embed license information for each component. This includes not only the SPDX license identifiers but also, where possible, the full license text itself. The resulting SBOM is far more useful for license compliance tasks than a generic BOM."}]}
{"messages": [{"role": "user", "content": "What is the default output file name if I don't specify one?"}, {"role": "assistant", "content": "If you run cdxgen without specifying an output file using the `-o` or `--output` argument, and you have not set it in a configuration file or environment variable, cdxgen will typically print the generated JSON SBOM directly to the standard output (your console). It will not save the SBOM to a file named `bom.json` by default unless that default is set in a configuration.\n\nThis behavior is common for command-line tools, allowing you to easily pipe the output to other tools for further processing. For example, you could run `cdxgen | jq` to immediately parse and pretty-print the resulting JSON. If you want the SBOM to be saved to a file, you must explicitly provide the file path, for example: `cdxgen -o bom.json`."}]}
{"messages": [{"role": "user", "content": "How do I ensure cdxgen uses Java 21?"}, {"role": "assistant", "content": "To ensure that cdxgen uses a Java 21 JDK for its analysis, which might be required for modern Java applications, you should use a container image that is specifically built with Java 21. This guarantees that the build environment matches your project's requirements, leading to accurate dependency resolution.\n\nThe cdxgen documentation lists several images for Java 21, providing flexibility. You can choose a Temurin-based image (`ghcr.io/cyclonedx/cdxgen-temurin-java21:v12`) or a more lightweight Alpine-based image (`ghcr.io/cyclonedx/cdxgen-alpine-java21:v12`). By executing your cdxgen command within one of these containers, you can be confident that the correct Java 21 toolchain will be used to analyze your `pom.xml` or `build.gradle` file."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to inventory the software on a virtual machine?"}, {"role": "assistant", "content": "Yes, you can use cdxgen to inventory the software on a virtual machine (VM). This process is known as generating an Operational Bill of Materials (OBOM), which describes the software composition of a running system. You would typically run cdxgen inside the VM itself or, if possible, mount the VM's filesystem to be scanned.\n\nTo create an OBOM, it is recommended to use the `operational` profile. This profile sets the `projectType` in the resulting SBOM to `os`, which correctly identifies the BOM's context. cdxgen can then use its system-level analysis capabilities to detect installed packages (e.g., via `dpkg`, `rpm`) and other software components, providing a comprehensive inventory of the software installed on the virtual machine."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support yarn workspaces?"}, {"role": "assistant", "content": "Yes, cdxgen has support for JavaScript monorepos that are structured using Yarn Workspaces. When cdxgen detects a project with a `package.json` file containing a `workspaces` field and a `yarn.lock` file, it will correctly identify it as a monorepo and analyze it accordingly.\n\nIt will traverse the directories specified in the workspaces configuration, identify the individual packages within the monorepo, and resolve their dependencies based on the single `yarn.lock` file at the root. This results in a comprehensive SBOM that accurately represents the structure of the monorepo, including the shared dependencies and the specific dependencies of each workspace package. This is a critical feature for accurately generating SBOMs for modern, large-scale JavaScript projects."}]}
{"messages": [{"role": "user", "content": "Can I analyze a jar file directly with cdxgen?"}, {"role": "assistant", "content": "Yes, you can analyze a standalone Java Archive (JAR) file directly with cdxgen to generate a Software Bill of Materials (SBOM) for it. This is useful when you have a compiled artifact but not the original source code. cdxgen has a specific project type for this purpose.\n\nTo analyze a JAR file, you would use the `-t jar` (or `-t java`, as it often works for JARs as well) and provide the path to the JAR file. For example: `cdxgen -t jar -o bom.json my-application.jar`. cdxgen will then inspect the JAR file, looking for bundled dependencies (in the case of a fat/uber JAR), manifest information, and other clues to identify the components contained within it. The quality of the result can vary depending on how the JAR was built and how much metadata it contains."}]}
{"messages": [{"role": "user", "content": "How can I exclude all hidden files and directories?"}, {"role": "assistant", "content": "To exclude all hidden files and directories (those whose names begin with a dot, like `.git` or `.idea`) from your cdxgen scan, you can use the `--exclude` argument with a glob pattern designed to match these paths. This is a good practice for cleaning up your SBOM by removing configuration and version control directories.\n\nThe glob pattern to match hidden files and directories at any level of your project is `\"**/.*\"`. The `**/` ensures the pattern applies recursively, and `.*` matches any file or directory name that starts with a period. By adding `--exclude \"**/.*\"` to your command, you can effectively ignore all of these hidden paths, leading to a cleaner and more focused SBOM that only includes your actual source code and dependencies."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `specVersion` option in the cbom alias?"}, {"role": "assistant", "content": "When you use the `cbom` alias to generate a Cryptography Bill of Materials, it automatically sets the `--spec-version` option to `1.6`. This is a critical part of the alias's function because version 1.6 of the CycloneDX specification is the first version to include first-class, dedicated support for describing cryptographic assets.\n\nPrevious versions of the spec did not have standardized fields for things like cryptographic algorithms, protocols, or implementation details. By forcing the BOM to be generated against the 1.6 spec, the `cbom` alias ensures that the cryptographic information discovered by the `--include-crypto` flag can be stored in the correct, standardized `crypto-properties` section of the BOM. This makes the resulting CBOM machine-readable and interoperable with other tools that understand the new cryptography extensions in CycloneDX 1.6."}]}
{"messages": [{"role": "user", "content": "How can I analyze a very large Java project that takes too much memory?"}, {"role": "assistant", "content": "When analyzing a very large Java project (e.g., over a million lines of code), the evidence generation process with `evinse` can consume a significant amount of memory, potentially leading to failures. The recommended solution for this is to decouple the analysis from cdxgen and run the `atom` analysis engine in its standalone Java mode, where you can allocate more memory to it.\n\nThe process is as follows: first, download the `atom.zip` release. Then, from its `bin` directory, run the `atom` command, explicitly giving it a large amount of Java heap space using the `-J-Xmx` flag (e.g., `./atom -J-Xmx16g ...` for 16GB). Have it perform the slicing and save the results to a file (e.g., `usages.json`). Finally, run `cdxgen` as you normally would, but use the `--usages-slices-file usages.json` argument to feed the pre-computed analysis results into the SBOM generation process. This approach bypasses the memory limitations of running the analysis within the standard cdxgen process."}]}
{"messages": [{"role": "user", "content": "My project uses Go modules. How does cdxgen find the dependencies?"}, {"role": "assistant", "content": "When cdxgen analyzes a project that uses Go modules, it relies on the files that the Go toolchain uses to manage dependencies. The primary files it looks for are `go.mod` and `go.sum`. The `go.mod` file defines the module's path and lists its direct dependencies along with their required versions.\n\ncdxgen parses the `go.mod` file to understand the dependency requirements. It will then typically use the `go.sum` file, which contains the cryptographic checksums of the specific versions of all direct and indirect (transitive) dependencies, to build a complete and accurate dependency graph. By parsing these two files, cdxgen can create a high-fidelity SBOM that precisely reflects the dependency tree of your Go application, as defined by the Go modules system."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen container for a project using Node.js version 20?"}, {"role": "assistant", "content": "Yes, for projects that are built on the Node.js 20.x Long-Term Support (LTS) version, the cdxgen project provides specific container images to ensure a compatible environment. This is important as your project's dependencies may require this specific version of Node.js to install and function correctly.\n\nThe documentation lists two primary options for Node.js 20: a standard Debian-based image, `ghcr.io/cyclonedx/cdxgen-node20:v12`, and a lightweight Alpine-based image, `ghcr.io/cyclonedx/cdxgen-alpine-node20:v12`. The documentation also notes that for this version, you may have better results on ARM-based machines (like Apple Silicon Macs) by using the `--platform=linux/amd64` flag to avoid potential `npm install` errors."}]}
{"messages": [{"role": "user", "content": "What is the `bom-ref` in a component object?"}, {"role": "assistant", "content": "The `bom-ref` (BOM Reference) attribute within a component object in a CycloneDX SBOM is a unique identifier for that component *within that specific BOM document*. Its primary purpose is to serve as an internal link target, allowing other parts of the SBOM to refer to that component without ambiguity. It must be unique among all `bom-ref` values in the file.\n\nA key use case for `bom-ref` is in defining the dependency graph. The `dependencies` section of the BOM lists relationships by referencing the `bom-ref` of each component. For example, the dependency graph might state that the component with `bom-ref` 'A' depends on the component with `bom-ref` 'B'. This system of internal references is fundamental to how CycloneDX represents complex relationships between the elements in the Bill of Materials."}]}
{"messages": [{"role": "user", "content": "I want to generate an SBOM for my PHP project. What's the command?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) for your PHP project, you would use the `cdxgen` command and specify the project type as `php`. PHP projects typically manage their dependencies using Composer, which uses a `composer.json` file to declare dependencies and a `composer.lock` file to lock their specific versions. cdxgen is designed to parse these files to discover all the components your project uses.\n\nA typical command to run at the root of your PHP project would be: `cdxgen -t php -o bom.json .`. This tells cdxgen to perform a `php` type analysis on the current directory (`.`) and save the resulting CycloneDX BOM to a file named `bom.json`. For best results, especially if your project requires a specific PHP version, you should run this command inside a cdxgen container image that matches your required PHP version (e.g., `ghcr.io/cyclonedx/cdxgen-debian-php83:v12`)."}]}
{"messages": [{"role": "user", "content": "Why does cdxgen need the `.m2` or Gradle cache for some Java analyses?"}, {"role": "assistant", "content": "cdxgen can leverage the local `.m2` (Maven) or Gradle cache for several advanced Java analysis use cases. While it can generate a basic SBOM by just parsing a `pom.xml`, having access to the cache provides much richer data. The cache contains the actual JAR files for all dependencies, not just their names and versions.\n\nOne key benefit, as highlighted in the documentation, is the ability to extract the list of all class names from within each JAR and add this as a `Namespaces` property to the component in the SBOM. Furthermore, for evidence generation with `evinse`, having the JARs available in the cache is essential for the `atom` analysis engine to perform its deep code slicing and data flow tracing, as it needs to inspect the actual bytecode of the libraries."}]}
{"messages": [{"role": "user", "content": "How do I make sure my environment variables don't override my command-line arguments?"}, {"role": "assistant", "content": "You don't need to do anything special to ensure your command-line arguments take precedence over environment variables; this is the default and guaranteed behavior of cdxgen. The tool processes its configuration from different sources in a specific, hierarchical order to ensure predictability.\n\nThe order of precedence is: 1) Command-line arguments, 2) Environment variables, and 3) Configuration files. This means that a value passed directly on the command line will always be used, overriding any conflicting values set in environment variables or configuration files. For example, if you have `export CDXGEN_OUTPUT=bom-env.json` set, but you run `cdxgen --output bom-cli.json`, the final output file will be `bom-cli.json` because the command-line argument has the highest priority."}]}
{"messages": [{"role": "user", "content": "How can I exclude build artifacts from my SBOM?"}, {"role": "assistant", "content": "To exclude build artifacts, such as `target` directories in Maven projects or `dist` directories in JavaScript projects, from your SBOM scan, you should use the `--exclude` argument. This argument allows you to specify glob patterns for directories that you want cdxgen to ignore completely.\n\nFor example, to exclude the standard Maven build output directory, you would add `--exclude \"**/target/**\"` to your command. To exclude a common JavaScript build directory, you would use `--exclude \"**/dist/**\"`. You can use the argument multiple times or use brace expansion (`--exclude \"**/{target,dist}/**\"`) to exclude multiple build artifact directories. This is a crucial step in creating a clean SBOM that represents your source components, not the output of the build process itself."}]}
{"messages": [{"role": "user", "content": "I am getting an error about 'Exposing daemon on TCP without TLS' on Windows. What should I do?"}, {"role": "assistant", "content": "The error message about 'Exposing daemon on TCP without TLS' indicates that you are missing a required configuration step for generating container SBOMs on Windows using Docker for Desktop. cdxgen needs to communicate with the Docker engine, and on Windows, this often requires enabling this specific network setting.\n\nTo resolve this, you need to go into the settings of your Docker for Desktop application. Find the 'General' or a similar settings tab, and look for an option labeled 'Expose daemon on tcp://localhost:2375 without TLS'. You must enable this option. Note that this setting can have security implications, as it makes your Docker daemon accessible over the network without encryption, so it should be used with caution, particularly on untrusted networks. After enabling it, you should also ensure you are running your terminal as an administrator before re-running the cdxgen command."}]}
{"messages": [{"role": "user", "content": "Can cdxgen tell me if a dependency is unused?"}, {"role": "assistant", "content": "Yes, cdxgen, in combination with the `evinse` tool, can help you identify dependencies that are likely unused in your project. The process involves generating a comprehensive list of all dependencies (including transitive ones) and then scanning your source code for evidence of their usage. Any component for which no evidence can be found is a strong candidate for being either an unused direct dependency or a transitive dependency that is not actively called by your code.\n\nThe workflow is as follows: first, generate a complete SBOM of your project. Then, run `evinse` using this SBOM as input (e.g., `evinse -i bom.json ...`). `evinse` will analyze your code and populate the `component.evidence` field for every dependency it finds being used. After the process is complete, you can inspect the resulting `bom.evinse.json` file. Any component that does not have an `evidence` object is one that `evinse` could not find any usage for, making it potentially unused."}]}
{"messages": [{"role": "user", "content": "How do I create a BOM for a project that uses pnpm?"}, {"role": "assistant", "content": "Yes, cdxgen supports generating a Software Bill of Materials (SBOM) for JavaScript projects that use `pnpm` as their package manager. `pnpm` is known for its efficient, non-flat `node_modules` structure and its use of a `pnpm-lock.yaml` file to lock dependency versions.\n\nTo generate an SBOM for a `pnpm`-based project, you would run cdxgen at the root of the project. The tool will automatically detect the `pnpm-lock.yaml` file and use it as the source of truth for building the dependency graph. It understands the unique structure of `pnpm`'s lockfile and dependency layout. You would typically use the command `cdxgen -t nodejs -o bom.json .`, and cdxgen's Node.js analyzer will correctly handle the `pnpm` project structure."}]}
{"messages": [{"role": "user", "content": "What is the 'description' field in a platform component of the formulation?"}, {"role": "assistant", "content": "In the `formulation` section of a BOM, for a component of type `platform`, the `description` field provides additional, detailed information about the toolchain that goes beyond the simple version number. It's a free-text field that cdxgen uses to store supplementary data captured from the build environment.\n\nFor example, in the case of a `dotnet` platform component, the `description` field contains a list of all the installed .NET Core and ASP.NET Core shared frameworks and their versions, as discovered on the system. For a `rustc` component, it might include the version of `cargo` as well. This extra detail provides a much richer context about the build environment, which can be invaluable for debugging build issues or for precisely reproducing the environment in the future."}]}
{"messages": [{"role": "user", "content": "Can I use environment variables in my cdxgen YAML configuration file?"}, {"role": "assistant", "content": "No, you cannot directly use environment variables (like `${MY_VAR}`) inside your cdxgen YAML or JSON configuration file and have them be expanded or substituted by cdxgen. The configuration file parsers in cdxgen read the values literally as they are written in the file.\n\nHowever, you can achieve a similar result by leveraging the configuration precedence rules. You can set general configurations in your `.cdxgen.yml` file and then override specific values using environment variables. For example, you could have `output: bom.json` in your YAML file, but then set `export CDXGEN_OUTPUT=bom-ci.json` in your CI environment. Because environment variables have a higher priority than configuration files, the output file will be `bom-ci.json`. This allows you to combine static configuration with dynamic, environment-specific overrides."}]}
{"messages": [{"role": "user", "content": "What happens if both `.cdxgen.json` and `.cdxgen.yml` exist?"}, {"role": "assistant", "content": "If both a `.cdxgen.json` file and a `.cdxgen.yml` file exist in the same directory, cdxgen will read and apply the settings from both. However, it does so in a specific order, which determines how conflicting settings are resolved. According to the configuration value ordering, cdxgen processes JSON files first, followed by YAML files.\n\nThis means that settings from the YAML file (`.cdxgen.yml`) will override any conflicting settings from the JSON file (`.cdxgen.json`). For example, if your JSON file specifies `\"type\": \"java\"` and your YAML file specifies `type: python`, the final effective type will be `python`. It's generally a good practice to use only one configuration file format to avoid confusion, but if both are present, the YAML file's values will take precedence in case of a conflict."}]}
{"messages": [{"role": "user", "content": "How can I check the version of the `cdxgen` tool itself?"}, {"role": "assistant", "content": "To check the version of the `cdxgen` command-line tool that you have installed, you can use the `--version` flag. This is a standard argument that will cause the tool to print its version number and then exit, without performing any SBOM generation.\n\nSimply open your terminal and run the command: `cdxgen --version`. The output will be a string indicating the version number, for example, `9.9.5`. This is the quickest and most reliable way to determine exactly which version of the tool you are running, which is essential for debugging, reporting issues, or ensuring you are using a version that supports a specific feature you need."}]}
{"messages": [{"role": "user", "content": "Why is the `deep` mode optional for JavaScript evidence generation?"}, {"role": "assistant", "content": "The `--deep` mode is listed as optional for JavaScript and TypeScript applications when generating reachability-based evidence because the standard dependency analysis for JavaScript is often sufficient for `evinse`'s needs. In the JavaScript ecosystem, tools like `npm` or `yarn` create a very detailed `package-lock.json` or `yarn.lock` file and a `node_modules` directory that contains the full source code of all dependencies.\n\nThis standard setup already provides `evinse`'s analysis engine with most of the information it needs to trace function calls from the application code into the third-party libraries found in `node_modules`. In contrast, for compiled languages like Java, the `--deep` mode is more critical as it helps ensure that the compiled artifacts (JAR files) are fully resolved and available for the detailed bytecode analysis that `evinse` needs to perform."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to create an SBOM for a single file?"}, {"role": "assistant", "content": "While cdxgen is primarily designed to analyze entire projects and directories, its behavior when pointed at a single file depends on the file type and the project type specified. If you point it at a package manifest file, it will typically analyze it and resolve the dependencies for the project it belongs to.\n\nFor example, running `cdxgen -t maven pom.xml` will cause it to analyze that `pom.xml` file and generate an SBOM for the corresponding Java project. If you point it at a single source file (like `main.c`), its ability to generate a meaningful SBOM will be limited. It might identify the file itself as a component, but without the context of a full project and build system, it would be unable to determine any external dependencies. For compiled artifacts like a single JAR or Go binary, it can perform a more meaningful analysis."}]}
{"messages": [{"role": "user", "content": "What is the `evinse completion >> ~/.bashrc` command for?"}, {"role": "assistant", "content": "The command `evinse completion >> ~/.bashrc` is used to enable command-line auto-completion for the `evinse` tool within a bash shell. Let's break down what it does. The first part, `evinse completion`, executes the `evinse` tool with a special argument that makes it generate a shell script. This script contains all the logic needed for the shell to understand `evinse`'s commands and options.\n\nThe `>> ~/.bashrc` part is shell redirection. The `>>` operator appends the output of the `evinse completion` command to the end of the `.bashrc` file, which is a configuration script that bash runs every time a new interactive shell starts. By adding the completion script to your `.bashrc`, you ensure that the auto-completion functionality is loaded and available in all your future terminal sessions, making the tool easier and faster to use."}]}
{"messages": [{"role": "user", "content": "How can I generate an SBOM for a project without installing its dependencies?"}, {"role": "assistant", "content": "To generate a Software Bill of Materials (SBOM) for a project without actually installing its dependencies, you can use the `--no-install-deps` flag. This option is particularly relevant for interpreted languages like Python, where cdxgen might otherwise try to run `pip install` to get a complete dependency tree.\n\nWhen you use this flag, `cdxgen --no-install-deps`, you are telling the tool to rely solely on the information present in the project's manifest files (e.g., `requirements.txt` or `pyproject.toml`). The resulting SBOM will reflect the dependencies as they are declared, not as they are resolved and installed. This creates what is known as a `pre-build` BOM and can be much faster than a full scan, though it may be less precise if your version specifiers are loose (e.g., `requests>=2.0`)."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen image for Debian with .NET 6?"}, {"role": "assistant", "content": "Yes, there is a cdxgen container image available that is based on Debian and includes the .NET 6 SDK. This image is suitable for generating SBOMs for projects that target .NET 6 or older versions like .NET Core 2.1, 3.1, and .NET 5.0.\n\nThe specific image tag mentioned in the documentation is `ghcr.io/cyclonedx/cdxgen-debian-dotnet6:v12`. Using this image ensures that your analysis environment has the correct toolchain to successfully run `dotnet restore` and build the dependency graph for your project. The documentation also advises that for better compatibility, especially on non-amd64 architectures, you should invoke the container with the `--platform=linux/amd64` flag."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support Python 3.13?"}, {"role": "assistant", "content": "Yes, cdxgen stays current with the Python ecosystem and provides support for recent versions, including Python 3.13. To analyze a project that requires this specific version, you should use the dedicated container image designed for it.\n\nThe documentation lists the `ghcr.io/cyclonedx/cdxgen-python313:v12` image for this purpose. Running your cdxgen scan inside this container guarantees that the analysis is performed using a Python 3.13 interpreter. This is crucial for accurately resolving dependencies from your `pyproject.toml` or other manifest files, as some packages may have version constraints that are specific to Python 3.13."}]}
{"messages": [{"role": "user", "content": "How do I exclude directories based on a brace expansion pattern?"}, {"role": "assistant", "content": "To exclude multiple directories using a single, concise argument, you can take advantage of the brace expansion feature supported by the `--exclude` flag. Brace expansion allows you to generate multiple strings from a comma-separated list within curly braces `{}`. This is a powerful shell-like feature for creating patterns.\n\nFor example, let's say you want to exclude build output directories for Maven (`target`), Gradle (`build`), and JavaScript (`dist`). Instead of using three separate `--exclude` arguments, you can combine them with brace expansion like this: `--exclude \"**/{target,build,dist}/**\"`. This single argument will expand into three glob patterns (`**/target/**`, `**/build/**`, `**/dist/**`), effectively excluding all three directory trees from your scan."}]}
{"messages": [{"role": "user", "content": "What is the `output` key in a `.cdxgen.yml` file for?"}, {"role": "assistant", "content": "The `output` key in a `.cdxgen.yml` configuration file corresponds directly to the `--output` (or `-o`) command-line argument. Its purpose is to specify the path and filename for the generated Software Bill of Materials (SBOM) JSON file. It tells cdxgen where to save the final output of its analysis.\n\nFor instance, if you include the line `output: sbom-report.json` in your `.cdxgen.yml` file, cdxgen will save the generated CycloneDX BOM to a file named `sbom-report.json` in the directory where the command was run. This is a fundamental configuration option that allows you to control the destination of the primary artifact produced by the tool."}]}
{"messages": [{"role": "user", "content": "Can cdxgen analyze a project using Carthage or SwiftPM on iOS/macOS?"}, {"role": "assistant", "content": "Yes, cdxgen has support for analyzing projects for Apple platforms (like iOS and macOS) that use common dependency managers like the Swift Package Manager (SwiftPM) or Carthage. To perform this analysis accurately, it's best to use a container image that includes the necessary toolchain.\n\nThe documentation lists the `ghcr.io/cyclonedx/cdxgen-debian-swift:v12` image, which includes the Swift toolchain. This allows cdxgen to correctly parse SwiftPM's `Package.swift` and `Package.resolved` files to determine dependencies. While Carthage is not explicitly mentioned in the provided text, cdxgen's support for Swift projects often extends to recognizing `Cartfile.resolved` as well. Running the scan within the appropriate container ensures that cdxgen can invoke the correct tools to build an accurate dependency graph for your Swift-based application."}]}
{"messages": [{"role": "user", "content": "What is the `min-confidence` flag useful for?"}, {"role": "assistant", "content": "The `--min-confidence` flag is particularly useful for cleaning up the noise in an SBOM generated for a project where component identification is inherently difficult, such as a C or C++ project. In these ecosystems, cdxgen may use heuristics that can lead to speculative or low-quality matches. These are assigned a low confidence score (a value between 0 and 1).\n\nBy setting a minimum confidence threshold, for example, `cdxgen -t c . --min-confidence 0.2`, you are telling cdxgen to discard any identified component that doesn't meet at least a 20% confidence level. This helps to filter out the most speculative guesses, resulting in a cleaner, higher-quality SBOM that contains only the components that the tool has a reasonable degree of certainty about. It's a trade-off between completeness and accuracy, allowing you to tune the output to your desired level of quality."}]}
{"messages": [{"role": "user", "content": "How do I create a BOM for a project with both Java 11 and Java 17 modules?"}, {"role": "assistant", "content": "Handling a single project that contains modules requiring different Java versions (like Java 11 and Java 17) is a complex scenario. cdxgen, when run once, will use a single Java version for its analysis. Therefore, it cannot simultaneously analyze modules with conflicting JDK requirements in a single pass. The best approach would be to generate separate SBOMs for the different parts of your project.\n\nYou would need to run cdxgen multiple times, once for each Java version, targeting the specific modules. For the Java 11 modules, you would run the scan in a Java 11 environment (e.g., using the `cdxgen-java11` container or `sdkman`). For the Java 17 modules, you would run it in a Java 17 environment. Afterward, you could use a separate tool to merge the resulting SBOMs into a single, comprehensive Bill of Materials for the entire application."}]}
{"messages": [{"role": "user", "content": "Can I generate call stack evidence for a Python project?"}, {"role": "assistant", "content": "Yes, you can generate call stack evidence for a Python project using cdxgen's evidence generation capabilities. The process is similar to that for Java projects and relies on the underlying `evinse` and `atom` tools to perform the necessary static analysis. The documentation shows that reachability-based evidence is supported for Python.\n\nTo do this, you would first need to generate a base SBOM using the `--deep` flag, which is a prerequisite for this analysis in Python. Then, you would trigger the evidence generation. The combined command would look something like this: `cd <path_to_app>; cdxgen -t python --deep -o bom.json --evidence .`. The `--evidence` flag will invoke `evinse` with the correct settings to perform the reachability analysis on your Python source code and enrich the `bom.json` with the discovered call stack information."}]}
{"messages": [{"role": "user", "content": "I am working on a project using .NET 8. Which container image should I choose?"}, {"role": "assistant", "content": "For a project that is built using .NET 8, you should select a cdxgen container image that comes with the .NET 8 SDK. This ensures that the environment has the correct compiler, runtime, and tools to accurately analyze your project and its dependencies. The cdxgen documentation provides several options for this.\n\nYou can choose from `ghcr.io/cyclonedx/cdxgen-debian-dotnet8:v12` (a Debian-based image), or `ghcr.io/cyclonedx/cdxgen-dotnet8:v12` (which is amd64 only). Using one of these images guarantees that when cdxgen runs `dotnet restore`, it does so with the .NET 8 toolchain, which is essential for correctly resolving dependencies for projects targeting this framework version."}]}
{"messages": [{"role": "user", "content": "My project is a library with no entry points. Can I still get call stack evidence?"}, {"role": "assistant", "content": "Yes, you can still get call stack evidence for a library project that has no traditional entry points (like a `main` method). The standard 'Forward-Reachability', analysis (used with `--with-reachables`) would fail in this case because it needs a starting point. However, this is precisely the scenario where the data flow-based slicing method, using 'Reverse-Reachability', is designed to work.\n\nTo get evidence, you would use the `--with-data-flow` flag with `evinse`. This method works backward from the 'sinks' (the calls made to external libraries from your code) to find any possible code paths within your library that lead to them. It doesn't require a predefined entry point, making it the ideal choice for analyzing libraries, common modules, or codebases with complex, non-obvious entry points. It is more resource-intensive but can provide call stacks where the standard method cannot."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support yarn berry (v2+)?"}, {"role": "assistant", "content": "The provided `ADVANCED.md` documentation does not explicitly mention support for Yarn Berry (v2+). Yarn Berry introduced significant changes, most notably the Plug'n'Play (PnP) installation strategy, which gets rid of the `node_modules` directory and uses a `.pnp.cjs` file to map dependencies instead. It also uses an updated `yarn.lock` format.\n\nWhile cdxgen has robust support for Yarn v1 and its `yarn.lock` file, full compatibility with Yarn Berry's PnP system would require a specialized parser. You would need to check the latest release notes or run a test on a Yarn Berry project to confirm the current level of support. If it doesn't work out of the box, a potential workaround could be to configure Yarn Berry to generate a `node_modules` directory (using the `nodeLinker: node-modules` setting in `.yarnrc.yml`), which might allow cdxgen's standard Node.js analyzer to process the project."}]}
{"messages": [{"role": "user", "content": "How do I exclude a specific file by name from the SBOM?"}, {"role": "assistant", "content": "To exclude a specific file by its name, regardless of where it is located in your project, you can use the `--exclude` argument with a glob pattern that matches just that filename. This is useful for ignoring configuration files or other specific files that you don't want to appear in your SBOM.\n\nFor example, if you want to exclude a file named `config.local.js` from the scan, you would use the following command: `cdxgen --exclude \"**/config.local.js\"`. The `**/` at the beginning of the pattern is crucial; it acts as a recursive wildcard, ensuring that cdxgen will find and exclude the file whether it is in the root directory or nested deep within a subdirectory."}]}
{"messages": [{"role": "user", "content": "How can I see a summary of the SBOM in my terminal?"}, {"role": "assistant", "content": "To see a human-readable summary of the generated Software Bill of Materials (SBOM) directly in your terminal, you should use the `--print` command-line flag. When you include this flag in your `cdxgen` command, the tool will first write the full JSON SBOM to the specified output file and then print a concise summary to the standard output.\n\nThis summary typically includes a table listing the discovered components with their names, versions, and types, as well as a hierarchical dependency tree that visualizes the relationships between the components. This is an extremely useful feature for getting a quick overview of your project's composition without needing to manually inspect the verbose JSON file. You can also enable this by setting `print: true` in a `.cdxgen.yml` configuration file."}]}
{"messages": [{"role": "user", "content": "What is the `all-in-one` container image?"}, {"role": "assistant", "content": "The term `all-in-one` container image, as used in the cdxgen documentation, refers to the main, most comprehensive images like `ghcr.io/cyclonedx/cdxgen:master`. These images are designed to be general-purpose and include a wide range of tools and runtimes to support many different programming languages and project types out of the box.\n\nAn all-in-one image would typically include runtimes for Node.js, Java, Python, Go, and more, as well as the necessary build tools like Maven, Gradle, and various compilers. This makes it a convenient, single image to use for scanning diverse projects. However, the trade-off is that these images are much larger than the language-specific images (e.g., `cdxgen-python311`). The all-in-one image is great for convenience and varied use, while the specific images are better for optimized, single-language pipelines."}]}
{"messages": [{"role": "user", "content": "Is there a cdxgen image that uses an older version of Node.js?"}, {"role": "assistant", "content": "Yes, the cdxgen project provides container images that use older, Long-Term Support (LTS) versions of Node.js to ensure compatibility with legacy projects. The table of custom images lists `ghcr.io/cyclonedx/cdxgen-node20:v12` and its Alpine variant for the Node.js 20 LTS release.\n\nWhile the provided text focuses on Node.js 20 and 24, the project historically has provided images for other LTS versions (like 18, 16, etc.). If you need to analyze a project that requires an even older Node.js version, you should check the full list of available tags on the GitHub Container Registry. Using the correct versioned image is critical, as `npm install` can fail if the Node.js version is incompatible with the project's `package.json` `engines` field or its dependencies."}]}
{"messages": [{"role": "user", "content": "How do I exclude a directory only at the root of my project?"}, {"role": "assistant", "content": "To exclude a directory that is located only at the root of your project, and not directories with the same name that might be nested deeper, you need to use a glob pattern in the `--exclude` argument that is not recursive. You would simply provide the name of the directory.\n\nFor example, if you want to exclude a `build` directory that is at the top level of your project, you would use the command: `cdxgen --exclude \"build\"`. This pattern does not contain a `**`, so it will only match a directory named `build` in the current working directory (the project root). If there was another directory named `src/app/build`, this pattern would not match it, and it would be included in the scan. This gives you precise control over the scope of the exclusion."}]}
{"messages": [{"role": "user", "content": "Why is it important to commit `project.assets.json` for legacy .Net Framework projects?"}, {"role": "assistant", "content": "For legacy projects targeting the .NET Framework (e.g., 4.6, 4.7), committing the `project.assets.json` file to the repository is a critical workaround for generating an accurate SBOM in a non-Windows environment like Linux. The `project.assets.json` file is generated by the `dotnet restore` command and contains the complete, resolved dependency graph for the project. The problem is that running `dotnet restore` for these legacy projects requires the .NET Framework SDK, which is only available on Windows.\n\nBy running the restore command on a Windows development machine and committing the resulting `project.assets.json` file, you are essentially pre-computing the dependency information. When you then run cdxgen in a Linux container, it can find and parse this existing file to get the accurate dependency tree without needing to execute the impossible `restore` command. It's a practical way to bridge the gap between the Windows-only build requirement and a Linux-based CI/CD or scanning environment."}]}
{"messages": [{"role": "user", "content": "How can I force a recreation of the evinse cache database?"}, {"role": "assistant", "content": "To force a recreation of the `evinse` cache database (`.atomdb`), you have two main options. The most direct method is to simply delete the file manually. `evinse` will detect that the file is missing on its next run and will automatically create a new, empty one, forcing a fresh analysis of all components.\n\nThe location of this file depends on your operating system: it's `~/.local/share/.atomdb` on Linux, `~/AppData/Local/.atomdb` on Windows, and `~/Library/Application Support/.atomdb` on macOS. The second option is to use the `--force` flag when running the `evinse` command. This flag explicitly tells `evinse` to discard any existing database and create a new one for the current run. Both methods achieve the same result of ensuring that the analysis is not influenced by potentially stale cached data."}]}
{"messages": [{"role": "user", "content": "What is the `uid` inside a `workflows` object?"}, {"role": "assistant", "content": "The `uid` (Unique Identifier) found inside a `workflows` object in the `formulation` section of a CycloneDX BOM is a globally unique identifier for that specific workflow execution. It is designed to be a stable and universally unique reference, often implemented as a UUID (Universally Unique Identifier), like `c451097b-5c74-49db-ada7-81bd77cdb390`.\n\nThe purpose of this `uid` is to allow for unambiguous tracking and correlation of the build process across different systems and tools. For example, your CI/CD system could generate this `uid` for a specific build run. By embedding it in the BOM, you create a verifiable link between the generated software artifact and the exact CI job that produced it. This is invaluable for auditability, traceability, and troubleshooting in a complex software supply chain."}]}
{"messages": [{"role": "user", "content": "How do I specify the architecture when running a cdxgen container?"}, {"role": "assistant", "content": "To specify the architecture when running a cdxgen container, you should use the `--platform` flag in your container runtime command (e.g., `docker run` or `nerdctl run`). This flag allows you to explicitly request an image variant built for a specific hardware architecture, such as `linux/amd64` (for x86-64) or `linux/arm64` (for ARM-based systems like Apple Silicon).\n\nThis is particularly important when you are running on an ARM machine but need to use a tool or dependency that is only available or stable for the `amd64` architecture. The cdxgen documentation frequently recommends this for certain language images to ensure compatibility. For example: `docker run --platform=linux/amd64 --rm -v $(pwd):/app ghcr.io/cyclonedx/cdxgen-debian-dotnet6:v12 ...`. This command forces Docker to pull and run the `amd64` version of the image, using an emulation layer if necessary."}]}
{"messages": [{"role": "user", "content": "Can cdxgen create an SBOM from a `requirements.txt` file?"}, {"role": "assistant", "content": "Yes, cdxgen can create a very detailed Software Bill of Materials (SBOM) from a Python project's `requirements.txt` file. When you run cdxgen on a Python project, it identifies the `requirements.txt` file as the primary package manifest and uses it to determine the project's direct dependencies.\n\nBy default, cdxgen will then use `pip` to resolve and install these dependencies (often in a temporary virtual environment) to build a complete dependency tree, including all the transitive dependencies. This ensures the resulting SBOM is a comprehensive and accurate representation of all the packages needed to run the application. To get the most accurate result, it's best to run the scan in an environment (like a specific cdxgen container) that matches the Python version your project uses."}]}