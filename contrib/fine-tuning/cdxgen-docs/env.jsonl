{"messages": [{"role": "user", "content": "How can I configure cdxgen to use a private Maven repository for my Android project?"}, {"role": "assistant", "content": "To configure cdxgen for a private Android Maven repository, you need to set the `ANDROID_MAVEN_URL` environment variable. This variable should contain the URL of your private repository. All Java-based scanners within cdxgen, including those for Gradle and Maven, will then use this URL to fetch metadata for Android dependencies.\n\nFor example, if your private repository is hosted at `https://repo.mycompany.com/android`, you would set the environment variable accordingly. This ensures that cdxgen can resolve dependencies correctly within a corporate environment that restricts access to public repositories or uses a proxy for all dependency management."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `ANDROID_MAVEN_URL` environment variable in cdxgen?"}, {"role": "assistant", "content": "The `ANDROID_MAVEN_URL` environment variable is used to specify a custom URL for the Android Maven Repository. By default, cdxgen and its Java-based scanners will attempt to fetch metadata from the public Android repository. Setting this variable allows you to redirect these requests to a private or mirrored repository.\n\nThis is essential for organizations that maintain their own repositories for security, compliance, or performance reasons. When `ANDROID_MAVEN_URL` is set, tools like the Gradle and Maven scanners will use your specified URL for resolving Android-specific artifacts, ensuring the SBOM generation process works correctly within your isolated network infrastructure."}]}
{"messages": [{"role": "user", "content": "How can I stop cdxgen from parsing my `venv` and `test` directories?"}, {"role": "assistant", "content": "You can prevent cdxgen from parsing specific directories by using the `ASTGEN_IGNORE_DIRS` environment variable. This variable accepts a comma-separated list of directory names that you wish to exclude from the Abstract Syntax Tree (AST) generation process. By default, cdxgen already ignores common directories like `venv` to speed up scanning.\n\nTo add more directories, such as `test`, you would set the variable like this: `ASTGEN_IGNORE_DIRS=venv,test,dist`. This is particularly useful for excluding directories that contain development dependencies, test code, or build outputs that are not part of the final production artifact, resulting in a cleaner and more accurate SBOM."}]}
{"messages": [{"role": "user", "content": "What does the `ASTGEN_IGNORE_DIRS` variable do by default?"}, {"role": "assistant", "content": "The `ASTGEN_IGNORE_DIRS` environment variable is used to specify a list of directories that should be ignored during the abstract syntax tree (AST) generation phase of cdxgen. This is a performance optimization to avoid unnecessarily parsing directories that typically do not contain application source code or dependencies, such as virtual environments or build artifacts.\n\nBy default, this variable is pre-configured with a list of common directory names to ignore, including `venv`. This default behavior helps to speed up the scanning process out-of-the-box. You can extend this list by setting the variable with your own comma-separated values to exclude any custom directories specific to your project's structure."}]}
{"messages": [{"role": "user", "content": "How do I ignore files based on a regex pattern during cdxgen scanning?"}, {"role": "assistant", "content": "To ignore files matching a specific regular expression during the abstract syntax tree (AST) generation, you can use the `ASTGEN_IGNORE_FILE_PATTERN` environment variable. This variable allows you to define a regex that cdxgen will use to exclude files from being parsed. This is useful for filtering out temporary files, mock data, or specific test files that you don't want to be included in the analysis.\n\nFor instance, if you want to ignore all files ending in `_test.js`, you could set `ASTGEN_IGNORE_FILE_PATTERN` to `_test\\.js$`. This gives you fine-grained control over which files are considered for dependency analysis, improving both the speed and accuracy of the generated SBOM."}]}
{"messages": [{"role": "user", "content": "How can I enable verbose logging in cdxgen to see its decision-making process?"}, {"role": "assistant", "content": "To get the most detailed logging output from cdxgen, you should set the `CDXGEN_DEBUG_MODE` environment variable to `verbose`. This setting not only enables standard debug messages but also activates a special 'think mode'. The think mode provides insight into the internal heuristics and decision-making logic of cdxgen as it analyzes your project.\n\nThis level of logging is extremely helpful for advanced troubleshooting or for understanding why cdxgen chose a particular scanner or method for dependency resolution. For example, you might see logs explaining why it preferred one lock file over another or how it identified a project's components."}]}
{"messages": [{"role": "user", "content": "What's the difference between `debug` and `verbose` for the `CDXGEN_DEBUG_MODE` setting?"}, {"role": "assistant", "content": "The `CDXGEN_DEBUG_MODE` environment variable controls the level of logging detail provided by cdxgen. Setting it to `debug` enables standard debug messages, which give you a more detailed view of the tool's operations, such as which commands are being executed and which files are being processed. This is typically sufficient for general troubleshooting.\n\nSetting `CDXGEN_DEBUG_MODE` to `verbose` goes a step further by activating the 'think mode' in addition to the debug messages. This mode logs the internal reasoning of cdxgen, explaining the logic behind its decisions. You'll see why certain dependencies were included or excluded, how project types were detected, and other heuristic-based actions. The `verbose` mode is best for deep-dive analysis and understanding the tool's behavior."}]}
{"messages": [{"role": "user", "content": "I'm running cdxgen inside a Docker container. Do I need to set a specific environment variable?"}, {"role": "assistant", "content": "Yes, when running cdxgen within a containerized environment like Docker, it is recommended to set the `CDXGEN_IN_CONTAINER` environment variable to `true`. While cdxgen can often auto-detect that it's running in a container, setting this variable explicitly ensures that certain container-specific configurations and optimizations are enabled.\n\nThese optimizations might include adjustments to file path handling, network configurations, or how it interacts with the container's filesystem. Explicitly setting `CDXGEN_IN_CONTAINER=true` guarantees consistent behavior and helps avoid potential issues related to the containerized execution context, leading to more reliable SBOM generation."}]}
{"messages": [{"role": "user", "content": "What is the function of the `CDXGEN_IN_CONTAINER` environment variable?"}, {"role": "assistant", "content": "The `CDXGEN_IN_CONTAINER` environment variable is used to explicitly inform cdxgen that it is executing inside a container. When this variable is set to `true`, cdxgen activates specific settings and optimizations tailored for containerized environments. This can influence how it handles file paths, manages temporary files, and interacts with the underlying system.\n\nFor example, knowing it's in a container might change how cdxgen resolves paths or accesses system resources, which can differ from a standard host machine. While cdxgen often attempts to auto-detect this context, setting the variable ensures the correct behavior is applied, which is especially important in complex CI/CD pipelines or custom container images."}]}
{"messages": [{"role": "user", "content": "cdxgen failed with a message about max buffer size. How do I fix this?"}, {"role": "assistant", "content": "If you encounter an error related to buffer size, it's likely because the output (stdout or stderr) from a command executed by cdxgen has exceeded the default limit. You can increase this limit by setting the `CDXGEN_MAX_BUFFER` environment variable. This variable defines the maximum buffer size in bytes for stdout and stderr.\n\nThe default value is 100MB (104857600 bytes). If your project's dependency analysis generates a very large amount of text output, you may need to set a higher value. For example, to set it to 200MB, you would set `CDXGEN_MAX_BUFFER=209715200`. This should resolve errors caused by excessive command-line output during SBOM generation."}]}
{"messages": [{"role": "user", "content": "What is the default value for `CDXGEN_MAX_BUFFER` and when should I change it?"}, {"role": "assistant", "content": "The `CDXGEN_MAX_BUFFER` environment variable controls the maximum size of the buffer for standard output (stdout) and standard error (stderr) when cdxgen executes external commands. The default value is set to 100MB. For most projects, this is more than sufficient to handle the output from dependency analysis tools.\n\nYou should consider changing this value if you are working with a very large or complex monorepo where the dependency listing commands (like `npm ls` or `mvn dependency:tree`) produce an exceptionally large volume of text. If the output exceeds 100MB, cdxgen might fail with a buffer-related error. In such cases, you can increase the `CDXGEN_MAX_BUFFER` value to a larger size, for example, `209715200` for 200MB, to accommodate the output."}]}
{"messages": [{"role": "user", "content": "How can I disable the HTTP request cache in cdxgen?"}, {"role": "assistant", "content": "To disable the built-in caching for HTTP requests in cdxgen, you can set the `CDXGEN_NO_CACHE` environment variable. Setting this variable to `true` or `1` will instruct the HTTP request agent used by cdxgen to not cache responses.\n\nThis can be useful in several scenarios. For instance, if you suspect that cdxgen is using stale data from a previous run, disabling the cache will force it to fetch fresh information from remote sources like package registries. It's also helpful in CI/CD environments where you want to ensure every run is completely clean and not influenced by a cache from a previous build."}]}
{"messages": [{"role": "user", "content": "What does setting `CDXGEN_NO_CACHE=true` actually do?"}, {"role": "assistant", "content": "Setting the `CDXGEN_NO_CACHE` environment variable to `true` or `1` deactivates the caching mechanism for the HTTP request agent within cdxgen. By default, cdxgen may cache some HTTP responses to speed up subsequent runs by avoiding redundant network requests for the same resource, such as package metadata.\n\nWhen you disable the cache, cdxgen is forced to perform a live network request for every piece of remote information it needs during the SBOM generation process. This guarantees that the data being used is the most current version available from the remote server, which is critical for security scanning and ensuring dependency information is up-to-date. However, it may also slow down the generation process, especially for projects with many remote dependencies."}]}
{"messages": [{"role": "user", "content": "How can I specify a custom directory for my cdxgen plugins?"}, {"role": "assistant", "content": "You can define a custom directory for cdxgen plugins by setting the `CDXGEN_PLUGINS_DIR` environment variable. This variable should be set to the absolute or relative path of the directory where your plugins are located. When this variable is set, cdxgen will look for plugins exclusively in the specified directory.\n\nIf `CDXGEN_PLUGINS_DIR` is not set, cdxgen's behavior changes. It defaults to an empty value but may fall back to searching for plugins in a global `node_modules` path if one is available on the system. Using this variable is the recommended way to manage a custom set of plugins, especially in controlled environments or when testing your own plugins."}]}
{"messages": [{"role": "user", "content": "Where does cdxgen look for plugins if `CDXGEN_PLUGINS_DIR` is not set?"}, {"role": "assistant", "content": "If the `CDXGEN_PLUGINS_DIR` environment variable is not set, cdxgen's plugin loading behavior is based on the environment. The variable defaults to an empty value, which means cdxgen does not look in a specific user-defined plugin directory. Instead, it will attempt to locate plugins from the global `node_modules` path, if such a path is configured and accessible in the Node.js environment.\n\nThis fallback mechanism is useful for plugins that have been installed globally via npm. However, for predictable and reproducible builds, it is highly recommended to explicitly define the plugin directory using `CDXGEN_PLUGINS_DIR`. This ensures that cdxgen uses a specific, intended set of plugins and avoids any ambiguity from globally installed packages."}]}
{"messages": [{"role": "user", "content": "Is it possible to save my command history from the cdxgen REPL?"}, {"role": "assistant", "content": "Yes, you can save the command history from the cdxgen Read-Eval-Print Loop (REPL). To do this, you need to set the `CDXGEN_REPL_HISTORY` environment variable to the file path where you want the history to be saved. For example, you could set it to `CDXGEN_REPL_HISTORY=~/.cdxgen_history`.\n\nOnce this variable is set, cdxgen will append every command you execute in the REPL to the specified file. This allows you to persist your command history across different sessions, making it easy to recall and reuse previous commands. If the variable is not set or the specified path is not writable, the REPL history will not be saved."}]}
{"messages": [{"role": "user", "content": "What happens if I don't set the `CDXGEN_REPL_HISTORY` variable?"}, {"role": "assistant", "content": "If you do not set the `CDXGEN_REPL_HISTORY` environment variable, cdxgen will attempt to save the REPL command history to a default location. However, if this default directory does not exist or if cdxgen does not have the necessary permissions to write to it, the REPL history will not be saved at all.\n\nThis means that your command history will be lost as soon as you exit the REPL session. To ensure your history is always saved and accessible for future sessions, it is best practice to explicitly set `CDXGEN_REPL_HISTORY` to a valid and writable file path, such as a file in your home directory."}]}
{"messages": [{"role": "user", "content": "How do I adjust the request timeout for cdxgen when running in server mode?"}, {"role": "assistant", "content": "To adjust the default request timeout when running cdxgen in server mode, you need to use the `CDXGEN_SERVER_TIMEOUT_MS` environment variable. This variable allows you to specify a timeout value in milliseconds. By default, cdxgen has a predefined timeout for server requests, but you may need to increase it for very large repositories or slow network connections.\n\nFor example, to set the timeout to 5 minutes (300,000 milliseconds), you would set `CDXGEN_SERVER_TIMEOUT_MS=300000`. This will prevent requests from timing out prematurely while cdxgen processes large projects, ensuring that the SBOM generation process can complete successfully."}]}
{"messages": [{"role": "user", "content": "What is the unit for the `CDXGEN_SERVER_TIMEOUT_MS` variable?"}, {"role": "assistant", "content": "The `CDXGEN_SERVER_TIMEOUT_MS` environment variable specifies the default timeout for requests when cdxgen is operating in server mode. The unit for this value is milliseconds (ms). This allows for precise control over how long the server will wait for a response before terminating a request.\n\nFor example, a value of `60000` corresponds to a timeout of 60 seconds or 1 minute. You should adjust this value based on the expected processing time for your largest projects to avoid premature timeouts, especially in environments with high latency or for very complex dependency trees."}]}
{"messages": [{"role": "user", "content": "How can I restrict the cdxgen server to only clone from my company's GitLab and GitHub Enterprise instances?"}, {"role": "assistant", "content": "To enhance security when running cdxgen in server mode, you can restrict which Git hosts it is allowed to clone from by using the `CDXGEN_SERVER_ALLOWED_HOSTS` environment variable. This variable accepts a comma-separated list of hostnames that you want to add to an allowlist.\n\nFor example, to allow cloning only from your company's `gitlab.mycompany.com` and `github.mycompany.com`, you would set the variable as follows: `CDXGEN_SERVER_ALLOWED_HOSTS=gitlab.mycompany.com,github.mycompany.com`. Any request to the server to clone a repository from a host not on this list will be rejected, preventing the server from interacting with unauthorized sources."}]}
{"messages": [{"role": "user", "content": "Is there a way to limit the local directories cdxgen can scan when in server mode?"}, {"role": "assistant", "content": "Yes, you can and should restrict the local filesystem paths that cdxgen is allowed to scan when operating in server mode. This is a critical security measure to prevent directory traversal attacks or scanning of sensitive system directories. To do this, set the `CDXGEN_SERVER_ALLOWED_PATHS` environment variable.\n\nThis variable takes a comma-separated list of allowed local paths. For instance, if you want to limit scanning to projects within the `/app/repos` directory, you would set `CDXGEN_SERVER_ALLOWED_PATHS=/app/repos`. Any request to scan a path outside of this directory (or its subdirectories) will be denied by the server."}]}
{"messages": [{"role": "user", "content": "How can I create an allowlist of remote hosts that cdxgen can contact during a scan?"}, {"role": "assistant", "content": "You can control which remote hosts cdxgen is permitted to contact by using the `CDXGEN_ALLOWED_HOSTS` environment variable. This variable should be set to a comma-separated list of hostnames that you trust. When this is set, cdxgen will only make network requests to hosts on this list.\n\nThis is a valuable security feature to prevent cdxgen from reaching out to unexpected or malicious domains, for example, through a compromised dependency file. If you only want cdxgen to contact the official npm and PyPI registries, you could set it like this: `CDXGEN_ALLOWED_HOSTS=registry.npmjs.org,pypi.org`. Any attempt to access another host will be blocked."}]}
{"messages": [{"role": "user", "content": "I need to ensure cdxgen only executes approved commands like `mvn` and `npm`. How can I enforce this?"}, {"role": "assistant", "content": "To restrict the external commands that cdxgen is allowed to execute, you can use the `CDXGEN_ALLOWED_COMMANDS` environment variable. This provides a security mechanism to prevent potentially malicious or unintended commands from being run during the SBOM generation process. You should set this variable to a comma-separated list of the commands you approve.\n\nFor example, to allow only Maven, npm, and Gradle commands, you would set `CDXGEN_ALLOWED_COMMANDS=mvn,npm,gradle`. If cdxgen attempts to execute any command not present in this allowlist, the operation will be blocked. This is highly recommended in secure environments to reduce the attack surface."}]}
{"messages": [{"role": "user", "content": "How do I change the temporary directory that cdxgen uses for its intermediate files?"}, {"role": "assistant", "content": "You can specify a custom temporary directory for cdxgen by setting the `CDXGEN_TEMP_DIR` environment variable. This variable should be set to the path of the parent directory where you want cdxgen to create its temporary working directory for storing intermediate files during an SBOM scan.\n\nThis is useful if the default system temporary directory has limited space or specific permissions restrictions. cdxgen will create a unique subdirectory within the path you specify and, importantly, will automatically clean it up by deleting it after the SBOM generation process is complete. For example, `CDXGEN_TEMP_DIR=/mnt/fast_storage/cdxgen_tmp` would direct all temporary files to be created under that path."}]}
{"messages": [{"role": "user", "content": "Does cdxgen clean up its temporary files automatically?"}, {"role": "assistant", "content": "Yes, cdxgen is designed to automatically clean up after itself. When it runs, it creates a temporary directory to store intermediate files, such as downloaded packages or command outputs. This directory is created within the path specified by the `CDXGEN_TEMP_DIR` environment variable, or in the system's default temporary location if the variable is not set.\n\nUpon successful completion or even in case of an error, the cdxgen process ensures that this temporary directory and all of its contents are removed. This prevents cluttering the filesystem with residual files from the scan and ensures a clean state for subsequent runs."}]}
{"messages": [{"role": "user", "content": "How can I log cdxgen's internal 'think mode' output to a specific file?"}, {"role": "assistant", "content": "To log the internal thinking process of cdxgen to a file, you need to use two environment variables together. First, you must enable the 'think mode' by setting `CDXGEN_DEBUG_MODE` to `verbose`. This activates the detailed logging of cdxgen's internal logic.\n\nSecond, you must specify the output file path using the `CDXGEN_THOUGHT_LOG` environment variable. For example: `CDXGEN_THOUGHT_LOG=/var/log/cdxgen/think.log`. When both variables are set, the 'think mode' output will be redirected to `think.log` instead of the standard output (stdout). If `CDXGEN_THOUGHT_LOG` is not defined, the think log will be printed to the console along with other program output."}]}
{"messages": [{"role": "user", "content": "I want to audit the external commands and network requests made by cdxgen. How can I log this information?"}, {"role": "assistant", "content": "To trace and log all external commands executed and remote hosts accessed by cdxgen, you need to use the `CDXGEN_TRACE_LOG` environment variable in conjunction with a trace mode. First, enable the tracing feature by setting `CDXGEN_TRACE_MODE` (the documentation implies its existence, though the variable itself isn't in the list, `CDXGEN_TRACE_LOG` depends on it).\n\nThen, define the `CDXGEN_TRACE_LOG` variable with the path to your desired log file, for instance, `CDXGEN_TRACE_LOG=/var/log/cdxgen/trace.log`. With these settings, cdxgen will record every external command it runs (e.g., `mvn`, `npm`) and every remote host it contacts. This is extremely useful for security audits and for understanding exactly what resources the tool is using during a scan. If `CDXGEN_TRACE_LOG` is not set, this trace information defaults to `process.stdout`."}]}
{"messages": [{"role": "user", "content": "My Gradle build takes a long time, and cdxgen is timing out. How can I increase the timeout?"}, {"role": "assistant", "content": "If cdxgen is timing out during long-running build tool operations, you can increase the default timeout by setting the `CDXGEN_TIMEOUT_MS` environment variable. This variable sets a general timeout in milliseconds for known long-running executions, specifically including tools like Maven, Gradle, or sbt.\n\nFor example, if you want to set the timeout to 10 minutes (600,000 milliseconds) to accommodate a slow Gradle build, you would set `CDXGEN_TIMEOUT_MS=600000`. This will give the underlying build tool more time to complete its dependency resolution tasks before cdxgen terminates the process, preventing timeout errors for large and complex projects."}]}
{"messages": [{"role": "user", "content": "How do I get cdxgen to include license information for my npm packages?"}, {"role": "assistant", "content": "To instruct cdxgen to fetch and include license information in the generated SBOM, you need to set the `FETCH_LICENSE` environment variable to `true` or `1`. When this variable is enabled, cdxgen will make additional requests to the package registry (such as npm for Node.js projects or pkg.go.dev for Go projects) to retrieve license details for each dependency.\n\nThis will enrich your SBOM with valuable license data, which is often crucial for compliance checks and license management. Be aware that enabling this option may slightly increase the scan time due to the extra network requests required to gather the license information for every package."}]}
{"messages": [{"role": "user", "content": "Which package managers are supported by the `FETCH_LICENSE` option?"}, {"role": "assistant", "content": "The `FETCH_LICENSE` environment variable is used to enable the fetching of license information from package registries. According to the documentation, this feature is explicitly supported for npm (Node.js) and Go (golang) projects.\n\nWhen you set `FETCH_LICENSE=true`, cdxgen will query the respective registries (npm registry, pkg.go.dev) to gather license details for the dependencies found in your project. This helps in creating a more complete SBOM that includes not just component information but also their associated licenses, which is vital for compliance."}]}
{"messages": [{"role": "user", "content": "Why should I use a `GITHUB_TOKEN` with cdxgen, and how do I configure it?"}, {"role": "assistant", "content": "You should provide a `GITHUB_TOKEN` to cdxgen to avoid issues with API rate limiting, also referred to as traffic shaping, by GitHub. When cdxgen fetches information, such as license details or repository metadata from GitHub APIs, it makes a series of requests. Anonymous requests are subject to very strict rate limits, which can be easily exceeded when scanning large projects, causing the scan to fail.\n\nTo configure it, you need to generate a Personal Access Token (PAT) from your GitHub account settings. Then, you set the `GITHUB_TOKEN` environment variable with this token value. By providing an authenticated token, cdxgen can make requests on your behalf, which are subject to a much higher rate limit, ensuring that scans can complete reliably without being blocked by GitHub."}]}
{"messages": [{"role": "user", "content": "How do I specify which version of Java cdxgen should use for scanning?"}, {"role": "assistant", "content": "cdxgen allows you to specify the toolchain version for different major Java releases using a set of dedicated environment variables. You can set `JAVA8_TOOL`, `JAVA11_TOOL`, `JAVA17_TOOL`, `JAVA21_TOOL`, `JAVA22_TOOL`, `JAVA23_TOOL`, or `JAVA24_TOOL` to point to a specific version that your project requires.\n\nFor example, if your project is built with Java 17 and you want to use a specific Temurin build, you could set `JAVA17_TOOL=17.0.16-tem`. If these variables are not set, cdxgen will use its own default versions. This feature is particularly useful for ensuring that the dependency analysis is performed using the exact same Java version as your build environment, which can be critical for compatibility and accuracy."}]}
{"messages": [{"role": "user", "content": "What are the default Java toolchain versions used by cdxgen?"}, {"role": "assistant", "content": "cdxgen comes with pre-configured default toolchain versions for several major Java releases. If you do not override them using the `JAVA*_TOOL` environment variables, cdxgen will use these defaults. For example, the default for Java 8 is `8.0.452-amzn`, while the defaults for Java 11, 17, 21, 22, 23, and 24 are Temurin (tem) builds like `11.0.27-tem` and `17.0.16-tem`.\n\nThese defaults ensure that cdxgen can perform Java analysis out-of-the-box without requiring you to have a specific Java version pre-installed. However, for full build reproducibility, it is always recommended to set the `JAVA*_TOOL` variable to match the exact version used in your project's build environment."}]}
{"messages": [{"role": "user", "content": "How can I point cdxgen to my company's internal mirror of Maven Central?"}, {"role": "assistant", "content": "To configure cdxgen to use an internal mirror or a private repository instead of the public Maven Central, you should set the `MAVEN_CENTRAL_URL` environment variable. This variable's value should be the base URL of your repository manager (like Nexus or Artifactory) that serves as a proxy for Maven Central.\n\nFor example: `MAVEN_CENTRAL_URL=https://artifactory.mycompany.com/maven-central-proxy`. Once set, all Java-based scanners in cdxgen (including those for Gradle and Maven projects) will direct their requests for package metadata to your specified URL. This is crucial for operating in air-gapped or controlled network environments and for speeding up builds by using a local cache."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `NODE_NO_READLINE` environment variable?"}, {"role": "assistant", "content": "The `NODE_NO_READLINE` environment variable is used to alter the behavior of the Node.js command-line interface (CLI) or REPL. When you set `NODE_NO_READLINE=1`, it disables the default canonical terminal settings that are managed by the `readline` module in Node.js. This is an advanced setting typically used by command-line tools that need to implement their own custom input handling or readline behavior.\n\nIn the context of cdxgen, this might be used to avoid conflicts with how cdxgen or its underlying dependencies manage terminal input/output, especially in interactive sessions or when running inside certain CI/CD systems that have non-standard terminal emulations. For most users, this variable does not need to be set."}]}
{"messages": [{"role": "user", "content": "How can I digitally sign the SBOM generated by cdxgen?"}, {"role": "assistant", "content": "cdxgen supports digitally signing the generated SBOMs using a private key. To do this, you need to provide your private key and specify a signature algorithm. You can provide the key in one of two ways: either as a file path using `SBOM_SIGN_PRIVATE_KEY` or as a base64-encoded string using `SBOM_SIGN_PRIVATE_KEY_BASE64`.\n\nYou also need to specify the algorithm with the `SBOM_SIGN_ALGORITHM` variable, using values like `RS256`, `ES256`, etc. Optionally, you can also embed the corresponding public key directly into the SBOM's signature section by providing it via `SBOM_SIGN_PUBLIC_KEY` (file path) or `SBOM_SIGN_PUBLIC_KEY_BASE64` (base64 string). This creates a self-contained, verifiable SBOM."}]}
{"messages": [{"role": "user", "content": "What signing algorithms are supported for signing cdxgen SBOMs?"}, {"role": "assistant", "content": "To sign an SBOM, you must specify the desired algorithm using the `SBOM_SIGN_ALGORITHM` environment variable. cdxgen supports a range of standard digital signature algorithms, ensuring compatibility with various cryptographic standards and verification tools. Some of the valid values include `RS256`, `RS384`, and `RS512`, which are based on the RSA algorithm with SHA hashing.\n\nAdditionally, it supports algorithms based on Elliptic Curve (EC) and RSA-PSS padding schemes, such as `PS256`, `PS384`, `PS512`, and `ES256`. You should choose an algorithm that aligns with your organization's security policies and the capabilities of the systems that will be used to verify the SBOM's signature."}]}
{"messages": [{"role": "user", "content": "How can I provide my SBOM signing key as a base64 string instead of a file?"}, {"role": "assistant", "content": "cdxgen provides a convenient way to supply signing keys as base64-encoded strings, which is particularly useful in CI/CD environments where managing files can be cumbersome. Instead of using `SBOM_SIGN_PRIVATE_KEY`, you can use the `SBOM_SIGN_PRIVATE_KEY_BASE64` environment variable. You would set its value to the base64-encoded content of your private key.\n\nSimilarly, if you wish to embed the public key in the signature, you can use `SBOM_SIGN_PUBLIC_KEY_BASE64` instead of `SBOM_SIGN_PUBLIC_KEY`. This method allows you to store your keys securely as environment secrets in your CI system and pass them to cdxgen without writing them to the filesystem of the build agent."}]}
{"messages": [{"role": "user", "content": "I'm using SDKMAN to manage my Java versions. Does cdxgen have any specific integration with it?"}, {"role": "assistant", "content": "Yes, cdxgen has awareness of SDKMAN, a popular tool for managing versions of multiple Software Development Kits. You can use the `SDKMAN_VERSION` environment variable to specify a particular version of SDKMAN that cdxgen should use. This can be important for ensuring that cdxgen uses the correct SDKMAN environment to locate and use the appropriate toolchains (like Java, Gradle, etc.) that are managed by it.\n\nBy setting this variable, you can help cdxgen align with your development environment's setup, leading to more accurate dependency resolution by using the same SDK versions that you use for building your project. This is especially helpful in environments where multiple versions of SDKs are installed and managed via SDKMAN."}]}
{"messages": [{"role": "user", "content": "cdxgen seems to be searching `search.maven.org`. How can I disable this behavior?"}, {"role": "assistant", "content": "By default, if cdxgen cannot find the necessary Maven metadata within a `.jar` file, it will perform a search on `search.maven.org` to try and identify the component's group, artifact, and version. You can disable this fallback search mechanism by setting the `SEARCH_MAVEN_ORG` environment variable to `false` or `0`.\n\nDisabling this feature is useful in a few situations. If you are in an air-gapped environment with no internet access, this will prevent failed network requests. It can also slightly speed up the SBOM generation process if you are confident that all your Java dependencies have proper metadata embedded within their JAR files or are available from your configured internal repository."}]}
{"messages": [{"role": "user", "content": "How do I pass custom arguments, like specifying a bazelrc file, to Bazel when running cdxgen?"}, {"role": "assistant", "content": "To pass additional arguments to the Bazel command executed by cdxgen, you can use the `BAZEL_ARGS` environment variable. This variable allows you to append any command-line flags or options that you would normally pass to Bazel. This is particularly useful for configuring project-specific settings.\n\nFor example, if you need to use a specific `.bazelrc` file for remote builds, you can set the variable like this: `BAZEL_ARGS=\"--bazelrc=bazelrc.remote\"`. The content of `BAZEL_ARGS` will be added to the Bazel command line, allowing you to customize the build environment and behavior just as you would when running Bazel directly."}]}
{"messages": [{"role": "user", "content": "My private Maven repository has a prefix in the path. How do I make the Bazel scanner handle this correctly?"}, {"role": "assistant", "content": "When using a private Maven repository with Bazel, you may have a path prefix (like `/maven2/`) that needs to be stripped for cdxgen to correctly identify the Maven group. You can handle this by using the `BAZEL_STRIP_MAVEN_PREFIX` environment variable. By default, this variable is set to `/maven2/`.\n\nIf your repository uses a different prefix or no prefix at all, you can change or clear this variable. For example, if your repository structure is different, you might set `BAZEL_STRIP_MAVEN_PREFIX=/my-repo/`. This ensures that the group ID of your Maven dependencies is parsed correctly from the repository paths, leading to accurate component identification in your SBOM."}]}
{"messages": [{"role": "user", "content": "How can I tell cdxgen to generate an SBOM for a specific Bazel target instead of the whole project?"}, {"role": "assistant", "content": "By default, cdxgen attempts to build for the `:all` target in a Bazel project. To specify a different, more specific target, you should use the `BAZEL_TARGET` environment variable. Set this variable to the label of the Bazel target you want to analyze.\n\nFor instance, if you only want to generate an SBOM for the `//java-maven` target in your workspace, you would set `BAZEL_TARGET=//java-maven`. This directs cdxgen to focus its analysis on that specific part of your build, which is more efficient and results in an SBOM that accurately represents a particular application or library rather than the entire monorepo."}]}
{"messages": [{"role": "user", "content": "What is the `BAZEL_USE_ACTION_GRAPH` variable for, and when is it useful?"}, {"role": "assistant", "content": "The `BAZEL_USE_ACTION_GRAPH` environment variable provides an alternative, more precise method for discovering dependencies for a specific Bazel target. When you set this variable to `true`, cdxgen will execute a Bazel `aquery` (action query) to inspect the build graph. Specifically, it runs a query to find all `.jar` files that are generated as part of the dependency set for your specified `BAZEL_TARGET`.\n\nThis approach is useful when you need a highly accurate list of dependencies for a single, well-defined build output. It relies on Bazel's own understanding of the build process, which can be more reliable than other dependency discovery methods, especially in complex projects. You should use this when the default dependency scan doesn't accurately reflect the dependencies of your final build artifact."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen use a different Clojure command-line tool, such as a wrapper script?"}, {"role": "assistant", "content": "If you need to override the default `clojure` command used by cdxgen, you can do so by setting the `CLJ_CMD` environment variable. This variable allows you to specify a different command or a path to a custom script that should be executed for Clojure project analysis.\n\nFor example, if you have a wrapper script named `my-clojure-runner.sh` that sets up a specific environment before invoking the Clojure CLI, you could set `CLJ_CMD=/path/to/my-clojure-runner.sh`. cdxgen will then use your script instead of directly calling `clojure`, giving you full control over the execution environment."}]}
{"messages": [{"role": "user", "content": "In my Xcode project, I want to exclude a specific target and its nested targets from the dependency scan. How can I do this?"}, {"role": "assistant", "content": "To exclude specific targets from the CocoaPods dependency resolution in cdxgen, you can use the `COCOA_EXCLUDED_TARGETS` environment variable. This variable accepts a comma-separated list of target names you wish to ignore. When you list a target, that target and all of its nested sub-targets will be excluded from the scan.\n\nFor example, if you want to exclude the `MyUITests` target, you would set `COCOA_EXCLUDED_TARGETS=MyUITests`. If you need to exclude only a specific sub-target without excluding its parent, you can specify the full path to the target, like `MyMainTarget/MySubTarget`. This gives you precise control over which parts of your project are included in the SBOM."}]}
{"messages": [{"role": "user", "content": "What is the difference between a shallow and a full scan in cdxgen for Cocoa projects?"}, {"role": "assistant", "content": "The `COCOA_FULL_SCAN` environment variable controls the depth of the dependency analysis for CocoaPods projects. When set to `true` (the default), cdxgen performs a full, deep scan. This requires a working installation of the `pod` command-line tool and involves invoking it to get detailed information about each Pod, including its full dependency tree and metadata.\n\nIf you set `COCOA_FULL_SCAN` to `false` or `0`, cdxgen performs a shallow scan. In this mode, it only gathers the most basic information available directly from the `Podfile.lock`, such as the name, version, and PURL of each Pod. This mode does not require the `pod` tool to be installed and can be useful for quick scans or when running on non-macOS systems like Windows, but it will result in a less detailed SBOM."}]}
{"messages": [{"role": "user", "content": "Instead of excluding targets, can I specify only the targets I want cdxgen to scan in my Cocoa project?"}, {"role": "assistant", "content": "Yes, you can specify an explicit list of targets to include in the dependency scan, rather than listing exclusions. To do this, use the `COCOA_INCLUDED_TARGETS` environment variable. This variable works similarly to `COCOA_EXCLUDED_TARGETS`, accepting a comma-separated list of target names.\n\nWhen `COCOA_INCLUDED_TARGETS` is set, cdxgen will only resolve dependencies for the targets you have listed. For example, setting `COCOA_INCLUDED_TARGETS=MyApp,MyWatchApp` will limit the scan to only those two targets and their dependencies. This 'allowlist' approach can be simpler to manage than an 'excludelist' if you only care about a small subset of targets in a large project."}]}
{"messages": [{"role": "user", "content": "My SBOM analysis tool doesn't handle CocoaPods sub-specs correctly. Can cdxgen help with this?"}, {"role": "assistant", "content": "Yes, cdxgen can help in this scenario. Some dependency analysis tools do not correctly interpret CocoaPods sub-specs as distinct components, which can lead to incomplete dependency graphs. To address this, cdxgen provides the `COCOA_MERGE_SUBSPECS` environment variable, which is set to `true` by default.\n\nWhen this option is enabled, cdxgen will merge all sub-specs and their unique dependencies into the root spec of the Pod. This creates a single, consolidated component entry in the SBOM for the entire Pod, with a complete list of all transitive dependencies from the root and all its sub-specs. This ensures that tools like Dependency-Track can correctly visualize the entire dependency set, even if they don't understand the concept of sub-specs."}]}
{"messages": [{"role": "user", "content": "I have local pods with JSON podspecs that are failing to parse because they contain variables. How can I fix this in cdxgen?"}, {"role": "assistant", "content": "This is a common issue, especially in React Native or Expo projects where podspec files are generated dynamically. To handle this, cdxgen offers the `COCOA_PODSPEC_JSON_REPLACEMENTS` environment variable. This variable allows you to perform find-and-replace operations on the content of JSON-formatted `.podspec` files before they are parsed.\n\nYou can provide a comma-separated list of `text_to_find=replacement` pairs. For more advanced cases, you can use regular expressions by enclosing the pattern in slashes (e.g., `/pattern/`). For example, you might need to replace a variable placeholder with a static value. This pre-processing step enables the `pod ipc spec` command to parse the file successfully, allowing cdxgen to gather the correct dependency information."}]}
{"messages": [{"role": "user", "content": "How do I perform regex replacements on my `.podspec` files during a cdxgen scan?"}, {"role": "assistant", "content": "To perform regular expression-based replacements, you can use either `COCOA_PODSPEC_JSON_REPLACEMENTS` (for JSON podspecs) or `COCOA_PODSPEC_REPLACEMENTS` (for Ruby-based podspecs). To indicate that your pattern is a regex, you must enclose the 'text_to_find' part with forward slashes (`/`).\n\nFor example, if you want to replace a version variable, you could set the variable like this: `COCOA_PODSPEC_JSON_REPLACEMENTS='/\"version\": \"\\w+\"/=\"version\": \"1.0.0\"'`. You can also use capture groups in your replacement string with `$1`, `$2`, etc. This powerful feature allows you to fix syntactically invalid or dynamic podspec files on-the-fly, enabling successful parsing by cdxgen."}]}
{"messages": [{"role": "user", "content": "My project uses local pods from `node_modules`. How do I prevent cdxgen from resolving them this way?"}, {"role": "assistant", "content": "In projects that combine CocoaPods with Node.js, such as those using React Native or Expo, cdxgen will by default try to resolve local pods that are located inside the `node_modules` directory. If you want to disable this behavior and treat those pods differently, you can set the `COCOA_RESOLVE_FROM_NODE` environment variable to `false`.\n\nWhen this is set to `false`, cdxgen will no longer attempt to link local pod paths back to the `node_modules` directory. This might be necessary if your build process handles these dependencies in a custom way and you don't want cdxgen's default node resolution logic to interfere with it. This gives you more control over how dependencies from different ecosystems are represented in the final SBOM."}]}
{"messages": [{"role": "user", "content": "When resolving pods from `node_modules`, how can I exclude certain directories from this resolution?"}, {"role": "assistant", "content": "If you are using the `COCOA_RESOLVE_FROM_NODE` feature, there might be cases where you want to prevent certain directories within `node_modules` from being considered. You can achieve this using the `COCOA_RESOLVE_FROM_NODE_EXCLUSION_DIRS` environment variable. This variable accepts a comma-separated list of directory paths to exclude.\n\nBoth full and partial paths are supported. For example, if you want to exclude any pod resolution from a `react-native-unimodules` directory within `node_modules`, you could set `COCOA_RESOLVE_FROM_NODE_EXCLUSION_DIRS=react-native-unimodules`. This allows you to fine-tune the node resolution behavior to match your project's specific structure and dependencies."}]}
{"messages": [{"role": "user", "content": "How do I provide Docker registry credentials to cdxgen in a secure way?"}, {"role": "assistant", "content": "There are two primary methods to provide Docker registry credentials to cdxgen. The recommended and most secure method is to run `docker login` on the machine before invoking cdxgen. This will create or update the `$HOME/.docker/config.json` file with your credentials. cdxgen will automatically detect and use this file to authenticate with the registry.\n\nAlternatively, if you cannot use `docker login`, you can provide the credentials via environment variables. You would need to set `DOCKER_USER`, `DOCKER_PASSWORD`, `DOCKER_EMAIL`, and `DOCKER_SERVER_ADDRESS`. For CI/CD environments, you can also use `DOCKER_AUTH_CONFIG`, which takes a base64 encoded JSON string containing your credentials. Using the `config.json` file is generally preferred as it avoids exposing credentials directly as environment variables."}]}
{"messages": [{"role": "user", "content": "Can I use an alternative path for the Docker `config.json` file with cdxgen?"}, {"role": "assistant", "content": "Yes, you can specify an alternative path for the Docker configuration directory. By default, cdxgen looks for the `config.json` file in the standard `$HOME/.docker` directory. However, if your configuration is stored elsewhere, you can use the `DOCKER_CONFIG` environment variable to point cdxgen to the correct parent directory.\n\nFor example, if your Docker configuration is located at `/etc/docker-config`, you would set `DOCKER_CONFIG=/etc/docker-config`. cdxgen will then look for the `config.json` file inside that directory (`/etc/docker-config/config.json`) to find the authentication credentials for your Docker registry."}]}
{"messages": [{"role": "user", "content": "I need to use Podman instead of Docker for image analysis. How do I configure cdxgen for this?"}, {"role": "assistant", "content": "cdxgen is flexible and allows you to use other container tools like Podman or nerdctl instead of the default Docker command. To do this, you need to set the `DOCKER_CMD` environment variable to the command you want to use. For example, to use Podman, you would set `DOCKER_CMD=podman`.\n\nOnce this variable is set, cdxgen will use `podman` for all container-related operations, such as pulling images and inspecting layers. This allows you to integrate cdxgen seamlessly into workflows that are based on container technologies other than Docker, provided the alternative tool has a compatible command-line interface for the required operations."}]}
{"messages": [{"role": "user", "content": "How can I force cdxgen to use the Docker CLI to pull images instead of streaming from the registry?"}, {"role": "assistant", "content": "By default, cdxgen attempts to stream image layers directly from the Docker registry for efficiency. However, in some situations, you might want to force it to use the local Docker CLI for pulling images. This is particularly useful if the image you want to scan is already available on your local machine and you want to avoid re-downloading it. To do this, set the `DOCKER_USE_CLI` environment variable to `true`.\n\nWhen `DOCKER_USE_CLI=true`, cdxgen will invoke the `docker pull` command instead of using its internal streaming client. This ensures that the local Docker cache is utilized, which can be faster if the image exists locally. It can also be a necessary workaround if there are network issues or firewalls preventing direct streaming from the registry."}]}
{"messages": [{"role": "user", "content": "My Docker registry uses a self-signed certificate. How can I make cdxgen trust it?"}, {"role": "assistant", "content": "When connecting to a Docker registry that uses a custom or self-signed TLS certificate, you need to provide the certificate files to cdxgen so it can establish a secure connection. You can do this using the `DOCKER_CERT_PATH` environment variable. This variable should be set to the path of a directory containing the client certificate files, specifically `cert.pem` and `key.pem`.\n\nAdditionally, if the registry does not require strict TLS verification (for example, in a development environment), you can disable it by setting the `DOCKER_TLS_VERIFY` environment variable to an empty value (e.g., `DOCKER_TLS_VERIFY=`). This will cause cdxgen to connect to the registry without verifying the server's TLS certificate, but this should be used with caution and is not recommended for production environments."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen enrich my Go dependencies with their VCS URLs?"}, {"role": "assistant", "content": "To have cdxgen include the Version Control System (VCS) URL (e.g., the GitHub repository link) for your Go dependencies, you need to enable a specific feature flag. Set the `GO_FETCH_VCS` environment variable to `true` or `1`. When this is enabled, cdxgen will query the Go package discovery service (pkg.go.dev by default) for each dependency to retrieve its repository URL.\n\nThis information is then added to the SBOM, which is very useful for linking dependencies back to their source code and for use in systems that perform source code analysis or display repository information. Note that this will increase scan time due to the additional network requests for each package."}]}
{"messages": [{"role": "user", "content": "I need to use a private Go package repository. How do I configure cdxgen to use it?"}, {"role": "assistant", "content": "If you are using a private or custom Go package discovery service instead of the public `pkg.go.dev`, you can configure cdxgen to use it by setting the `GO_PKG_URL` environment variable. This variable should be set to the base URL of your private package service.\n\nFor example, if your service is hosted at `https://gopkgs.mycompany.com/`, you would set `GO_PKG_URL=https://gopkgs.mycompany.com/`. cdxgen will then direct all its metadata and VCS URL queries for Go packages to your specified URL, allowing it to work correctly within your organization's ecosystem."}]}
{"messages": [{"role": "user", "content": "How do I force cdxgen to use `go.sum` as the source of truth for dependencies instead of `go.mod`?"}, {"role": "assistant", "content": "By default, cdxgen primarily uses the `go.mod` file to determine the dependencies of a Go project. However, the `go.sum` file contains a more precise list of the exact versions and hashes of all direct and indirect dependencies used in a build. To make cdxgen use `go.sum` as the primary source of truth, you must set the `USE_GOSUM` environment variable to `true` or `1`.\n\nUsing `go.sum` can result in a more accurate and complete SBOM, as it reflects the entire dependency tree that was cryptographically verified during the build. This is the recommended approach for generating a high-fidelity SBOM for Go projects, as it ensures all transitive dependencies are included with their exact versions."}]}
{"messages": [{"role": "user", "content": "How can I pass additional arguments, like `--init-script`, to all Gradle tasks run by cdxgen?"}, {"role": "assistant", "content": "To pass additional arguments to every Gradle command that cdxgen executes (including `properties` and `dependencies` tasks), you should use the `GRADLE_ARGS` environment variable. This variable allows you to inject any command-line options that you need for your build configuration.\n\nFor example, if you need to apply a custom initialization script to your build, you can set `GRADLE_ARGS=\"--init-script /path/to/your-script.gradle\"`. The contents of this variable will be appended to each `gradle` invocation, making it a powerful way to customize the build environment for dependency analysis."}]}
{"messages": [{"role": "user", "content": "I need to pass a specific configuration only to the `gradle dependencies` task. How can I do that?"}, {"role": "assistant", "content": "cdxgen provides a way to pass arguments specifically to the `gradle dependencies` task, which is used to list the project's dependencies. To do this, you should use the `GRADLE_ARGS_DEPENDENCIES` environment variable. Any arguments you provide in this variable will only be applied to this specific task, not to others like `gradle properties`.\n\nThis is useful for controlling the scope of the dependency analysis. For example, if you only want to list dependencies from the `runtimeClasspath` configuration, you can set `GRADLE_ARGS_DEPENDENCIES=\"--configuration runtimeClasspath\"`. This ensures that your SBOM only includes runtime dependencies and excludes ones from test or compile-only scopes."}]}
{"messages": [{"role": "user", "content": "Is there a way to pass arguments only to the `gradle properties` task in cdxgen?"}, {"role": "assistant", "content": "Yes, you can pass arguments that will only be applied to the `gradle properties` task. This task is used by cdxgen to gather metadata about the Gradle project itself, such as its group, name, and version. To add arguments specifically for this purpose, you use the `GRADLE_ARGS_PROPERTIES` environment variable.\n\nWhile less commonly needed than `GRADLE_ARGS_DEPENDENCIES`, this could be useful if you have custom logic in your build that affects how project properties are exposed and you need to pass a flag to trigger it. For example, `GRADLE_ARGS_PROPERTIES=\"-PcustomProp=true\"` would pass that project property only when cdxgen is querying for project metadata."}]}
{"messages": [{"role": "user", "content": "How can I specify the Gradle cache directory for cdxgen to use?"}, {"role": "assistant", "content": "To specify a custom Gradle cache directory, you should set the `GRADLE_CACHE_DIR` environment variable. Pointing cdxgen to the correct cache directory is important, especially for class name resolving, as the cache contains downloaded dependencies and other build artifacts that cdxgen can leverage.\n\nBy setting `GRADLE_CACHE_DIR` to the path of your Gradle cache (e.g., `~/.gradle/caches`), you ensure that cdxgen has access to the same cached information that your local builds use. This can improve the accuracy of the SBOM and potentially speed up the analysis by avoiding redundant downloads."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use my `gradlew` wrapper script instead of a global `gradle` command?"}, {"role": "assistant", "content": "To override the default `gradle` command and use a different one, such as the Gradle wrapper (`gradlew`) included in your project, you should set the `GRADLE_CMD` environment variable. It is highly recommended to use the wrapper script to ensure that cdxgen uses the exact same Gradle version that your project is configured for.\n\nFor example, you would set `GRADLE_CMD=./gradlew` (or `gradlew.bat` on Windows). When this is set, cdxgen will invoke `./gradlew properties` and `./gradlew dependencies` instead of using a system-wide `gradle` command. This leads to more consistent and reproducible SBOM generation."}]}
{"messages": [{"role": "user", "content": "I have a Gradle module that fails during the `dependencies` task. How can I skip it?"}, {"role": "assistant", "content": "If a specific module in your multi-project Gradle build is causing the `dependencies` task to fail, you can instruct cdxgen to skip it for that specific task by using the `GRADLE_SKIP_MODULE_DEPENDENCIES` environment variable. This variable takes a comma-separated list of module names to skip. It's important to use their full Gradle path name, including the leading colon (e.g., `:my-failing-module`).\n\nFor example, `GRADLE_SKIP_MODULE_DEPENDENCIES=:failing-module,:another-problem-module`. This will still allow cdxgen to run the `properties` task on these modules to gather their metadata, but it will skip the part that lists their dependencies. This is a useful workaround for problematic modules that would otherwise cause the entire SBOM generation to fail. To skip the root module, use the name `root`."}]}
{"messages": [{"role": "user", "content": "How can I completely exclude a Gradle module from the cdxgen scan?"}, {"role": "assistant", "content": "To completely skip a Gradle module from all analysis, including both the `properties` and `dependencies` tasks, you should use the `GRADLE_SKIP_MODULES` environment variable. Provide a comma-separated list of the Gradle module names you want to exclude, using their full path with a leading colon (e.g., `:legacy-module`).\n\nWhen you use this variable, be aware of the consequences: cdxgen will not know the configured group, name, or version of the skipped modules, nor will it list any of their dependencies. The modules will be completely absent from the SBOM. This should be used for modules that are irrelevant to the final product or are known to be incompatible with the build analysis tools."}]}
{"messages": [{"role": "user", "content": "How can I control whether cdxgen uses the Gradle Daemon?"}, {"role": "assistant", "content": "You can control cdxgen's use of the Gradle Daemon via the `GRADLE_USE_DAEMON` environment variable. By default, this is set to `true`, which means cdxgen will try to use the daemon for faster execution. You can explicitly set it to `false` to prevent cdxgen from using the daemon, which might be necessary in some CI environments to ensure a clean build slate.\n\nThere is also a third option: `default`. Setting `GRADLE_USE_DAEMON=default` tells cdxgen to respect the system's default Gradle configuration regarding daemon usage, rather than enforcing its own preference. This is useful if you want the behavior to align perfectly with how developers run Gradle on their local machines."}]}
{"messages": [{"role": "user", "content": "How do I ensure the Gradle Daemon is stopped after cdxgen finishes?"}, {"role": "assistant", "content": "To ensure that any Gradle Daemon started during the cdxgen run is stopped afterward, you can use the `GRADLE_STOP_DAEMON` environment variable. This variable is closely tied to `GRADLE_USE_DAEMON`. By default, if `GRADLE_USE_DAEMON` is `true`, then `GRADLE_STOP_DAEMON` also defaults to `true`.\n\nThis means that cdxgen will automatically issue a `gradle --stop` command after it has completed its analysis, cleaning up the daemon process. This is good practice in ephemeral CI environments to avoid leaving orphaned processes behind. If you want to keep the daemon running for subsequent build steps, you can set `GRADLE_STOP_DAEMON=false`."}]}
{"messages": [{"role": "user", "content": "How do I specify a custom Gradle user home directory for cdxgen?"}, {"role": "assistant", "content": "You can specify a custom directory for the Gradle user home by setting the `GRADLE_USER_HOME` environment variable. The Gradle user home directory is where Gradle stores its caches, downloaded dependencies, wrapper distributions, and other global configuration files. By default, it's located at `$HOME/.gradle`.\n\nSetting this variable is useful in CI/CD pipelines where you might want to control the location of the cache for persistence between builds or to avoid interfering with a user's local Gradle setup. For example, `GRADLE_USER_HOME=/path/to/ci/gradle_home` will direct Gradle to use that specific directory for all its user-specific files."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen for Maven use a specific version of the CycloneDX plugin?"}, {"role": "assistant", "content": "If you want to override the default CycloneDX Maven plugin version used by cdxgen, you can set the `CDX_MAVEN_PLUGIN` environment variable. This variable should be set to the full coordinates of the plugin you wish to use, in the format `groupId:artifactId:version`.\n\nThe default version is `org.cyclonedx:cyclonedx-maven-plugin:2.9.1`. If you need to use a newer or older version due to specific features or compatibility requirements, you can specify it directly. For example: `CDX_MAVEN_PLUGIN=org.cyclonedx:cyclonedx-maven-plugin:2.7.9`. This gives you control over the exact tool used for SBOM generation when the plugin-based approach is active."}]}
{"messages": [{"role": "user", "content": "I want to generate a single SBOM for my multi-module Maven project. Which `CDX_MAVEN_GOAL` should I use?"}, {"role": "assistant", "content": "For a multi-module Maven project, you typically want to generate a single, aggregated SBOM that includes all modules and their dependencies. To achieve this with the CycloneDX Maven plugin, you should ensure the `CDX_MAVEN_GOAL` environment variable is set to `makeAggregateBom`. This is the default goal used by cdxgen.\n\nThe `makeAggregateBom` goal is designed specifically for this purpose. It should be executed from the root of the project, and it will scan all the sub-modules to create one comprehensive SBOM. Other available goals like `makeBom` would create separate SBOMs for each module, which might not be what you want."}]}
{"messages": [{"role": "user", "content": "How can I exclude test-scoped dependencies from my Maven project's SBOM?"}, {"role": "assistant", "content": "By default, cdxgen includes dependencies with a `test` scope when analyzing Maven projects. If you wish to exclude these dependencies to create a production-focused SBOM, you need to set the `CDX_MAVEN_INCLUDE_TEST_SCOPE` environment variable to `false`.\n\nWhen `CDX_MAVEN_INCLUDE_TEST_SCOPE` is set to `false`, the underlying dependency analysis (whether it's using the CycloneDX plugin or `dependency:tree`) will be configured to ignore any dependencies that are only used for testing. This results in a cleaner SBOM that more accurately represents the components that will be part of your final, deployed artifact."}]}
{"messages": [{"role": "user", "content": "How can I point cdxgen to a custom Maven installation directory?"}, {"role": "assistant", "content": "If you have installed Maven in a custom location and it's not available on the system `PATH`, you need to tell cdxgen where to find it. You can do this by setting the `MAVEN_HOME` environment variable. This variable should be set to the path of your Maven installation directory.\n\nFor example, if Maven is installed at `/opt/apache-maven-3.9.6`, you would set `MAVEN_HOME=/opt/apache-maven-3.9.6`. cdxgen will then use this path to locate the `mvn` executable. This is essential for environments where you need to use a specific, non-default version of Maven for your builds."}]}
{"messages": [{"role": "user", "content": "How do I pass additional arguments, like a specific settings file, to the Maven command in cdxgen?"}, {"role": "assistant", "content": "To pass additional command-line arguments to the `mvn` command executed by cdxgen, you should use the `MVN_ARGS` environment variable. This allows you to customize the Maven execution by adding any flags or options you need, such as specifying a profile or an alternative settings file.\n\nFor example, to run Maven with a specific profile named `production` and a custom settings file, you would set the variable like this: `MVN_ARGS=\"-P production --settings /path/to/my-settings.xml\"`. The content of `MVN_ARGS` will be appended to the Maven command, giving you full control over its execution."}]}
{"messages": [{"role": "user", "content": "How can I force cdxgen to use `mvnw` (Maven wrapper) instead of a system `mvn` command?"}, {"role": "assistant", "content": "To make cdxgen use the Maven wrapper (`mvnw`) provided with your project, you need to set the `MVN_CMD` environment variable. Using the wrapper is the recommended practice because it ensures that the SBOM is generated with the exact Maven version specified by the project, leading to reproducible results.\n\nYou should set the variable to the path of the wrapper script. For example: `MVN_CMD=./mvnw` (or `mvnw.cmd` on Windows). cdxgen will then use this command for all Maven operations instead of looking for a globally installed `mvn`."}]}
{"messages": [{"role": "user", "content": "What is the difference between `PREFER_MAVEN_DEPS_TREE=true` and `false`?"}, {"role": "assistant", "content": "The `PREFER_MAVEN_DEPS_TREE` environment variable controls which method cdxgen uses to determine dependencies in a Maven project. It defaults to `true` (since v11), which means cdxgen will use the `mvn dependency:tree` command. This command is a standard part of Maven and provides a textual representation of the project's dependency tree, which cdxgen then parses.\n\nIf you set `PREFER_MAVEN_DEPS_TREE` to `false`, cdxgen will revert to the older method of using the CycloneDX Maven plugin (`cyclonedx-maven-plugin`). It will dynamically inject and execute this plugin to generate the SBOM. The `dependency:tree` method is often faster and has fewer dependencies, but the plugin method may offer more detailed component information in some cases."}]}
{"messages": [{"role": "user", "content": "How can I exclude test dependencies from the SBOM of my Mill project?"}, {"role": "assistant", "content": "To exclude test-related modules and their dependencies from the SBOM generated for a Mill project, you can use the `MILL_EXCLUDE_TEST` environment variable. By default, this is set to `false`, meaning test dependencies are included. To exclude them, you must set this variable to `true`.\n\nSetting `MILL_EXCLUDE_TEST=true` will configure cdxgen to ignore any modules and dependencies that are designated for testing purposes within your Mill build definition. This is useful for creating a production-oriented SBOM that only reflects the components of the final application, not the tools used to test it."}]}
{"messages": [{"role": "user", "content": "How can I manage the Mill server lifecycle when running cdxgen?"}, {"role": "assistant", "content": "cdxgen provides two environment variables to control its interaction with the Mill server for improved performance. The `MILL_USE_SERVER` variable, which defaults to `false`, can be set to `true` to instruct cdxgen to use a long-running Mill server process. This avoids the overhead of starting a new JVM for each Mill command.\n\nWhen `MILL_USE_SERVER` is `true`, the `MILL_SHUTDOWN_SERVER` variable comes into play. It defaults to `true`, meaning cdxgen will automatically shut down the Mill server after the scan is complete. This is ideal for CI environments to prevent lingering processes. If you want to keep the server running for subsequent build steps, you can set `MILL_SHUTDOWN_SERVER=false`."}]}
{"messages": [{"role": "user", "content": "I'm getting an 'Out Of Memory' error when running cdxgen on a large Node.js project. How can I fix this?"}, {"role": "assistant", "content": "When analyzing very large Node.js projects, the Node.js process itself might run out of heap memory. You can increase the memory allocated to Node.js by using the `NODE_OPTIONS` environment variable. This variable allows you to pass command-line options directly to the Node.js runtime that executes cdxgen.\n\nTo increase the heap size, you should use the `--max-old-space-size` flag, which sets the maximum memory for the old memory space in megabytes. For example, to allocate 8GB of heap memory, you would set `NODE_OPTIONS=\"--max-old-space-size=8192\"`. This should provide enough memory for cdxgen to process even very large dependency trees without crashing."}]}
{"messages": [{"role": "user", "content": "Is there a way to pass Node.js runtime options to cdxgen dynamically?"}, {"role": "assistant", "content": "Yes, in addition to the standard `NODE_OPTIONS`, cdxgen provides its own `CDXGEN_NODE_OPTIONS` environment variable. This variable serves a similar purpose: allowing you to pass additional options to the Node.js runtime. This can be useful for passing cdxgen-specific runtime flags without interfering with a globally configured `NODE_OPTIONS`.\n\nFor example, if you want to enable the experimental `async_hooks` for a cdxgen run without setting it for all Node.js applications, you could set `CDXGEN_NODE_OPTIONS=\"--cpu-prof\"`. The options provided in this variable will be passed to the Node.js process that is executing cdxgen."}]}
{"messages": [{"role": "user", "content": "Where does cdxgen look for globally installed Node.js modules if a local plugins directory isn't provided?"}, {"role": "assistant", "content": "If you don't specify a plugins directory with `CDXGEN_PLUGINS_DIR`, cdxgen may look for plugins in the global `node_modules` directory. You can explicitly tell cdxgen where this directory is located by setting the `GLOBAL_NODE_MODULES_PATH` environment variable. This variable should be set to the path where global npm packages are installed on your system.\n\nThis is useful if your Node.js or npm setup uses a non-standard location for global packages, or if you are in an environment where the path cannot be automatically discovered. By setting this variable, you ensure that cdxgen can find any globally installed plugins it might need."}]}
{"messages": [{"role": "user", "content": "My project requires the `--legacy-peer-deps` flag for `npm install`. How can I make cdxgen use it?"}, {"role": "assistant", "content": "When cdxgen needs to run `npm install` to build a dependency tree (for example, if `node_modules` is missing), you can pass additional arguments to that command using the `NPM_INSTALL_ARGS` environment variable. This is the perfect way to handle requirements like `--legacy-peer-deps`.\n\nTo have cdxgen use this flag, you would set `NPM_INSTALL_ARGS=--legacy-peer-deps`. You can also pass other arguments, such as `--package-lock-only` or `--force`. This ensures that cdxgen's automatic installation step behaves exactly as your project's build process requires, avoiding installation failures due to peer dependency conflicts."}]}
{"messages": [{"role": "user", "content": "cdxgen keeps trying to run `npm install` and failing. Can I limit how many times it tries?"}, {"role": "assistant", "content": "Yes, you can limit the number of times cdxgen will automatically attempt to run `npm install` during its analysis. This is controlled by the `NPM_INSTALL_COUNT` environment variable. By default, this is set to 2, meaning cdxgen might try to install dependencies up to two times if it detects they are needed.\n\nIf the installation is failing and you want to prevent repeated attempts, you can set this value to `1` or even `0` to disable automatic installation entirely. For example, `NPM_INSTALL_COUNT=1` will ensure it only tries once. This feature, available since cdxgen 11.0.5, helps prevent getting stuck in failing installation loops."}]}
{"messages": [{"role": "user", "content": "How can I configure cdxgen to use a private npm registry like Verdaccio?"}, {"role": "assistant", "content": "To point cdxgen to a private or custom npm registry, you need to set the `NPM_URL` environment variable. By default, cdxgen uses the public npm registry URL (`https://registry.npmjs.org/`). By overriding this, you can direct all of its package metadata requests to your own registry.\n\nFor example, if your private registry is hosted at `http://verdaccio.mycompany.local:4873/`, you would set `NPM_URL=http://verdaccio.mycompany.local:4873/`. This ensures that cdxgen can resolve and fetch information for all your internal and proxied packages correctly, allowing it to function in a corporate or offline environment."}]}
{"messages": [{"role": "user", "content": "How do I use NVM (Node Version Manager) with cdxgen to specify a Node.js version?"}, {"role": "assistant", "content": "If you use NVM to manage your Node.js versions, you can ensure cdxgen uses the correct NVM environment by setting the `NVM_DIR` environment variable. This variable should be set to the path where NVM is installed, which is typically `$HOME/.nvm`.\n\nBy setting `NVM_DIR`, you help cdxgen locate the NVM installation and correctly source its environment scripts. This allows cdxgen to use the specific Node.js version that you have activated via NVM for your project, ensuring that dependency analysis is performed with the correct runtime and toolchain. This is crucial for projects that have strict Node.js version requirements."}]}
{"messages": [{"role": "user", "content": "How can I configure cdxgen to use a custom NuGet feed for .NET projects?"}, {"role": "assistant", "content": "To configure cdxgen to use a custom NuGet package source or feed, you should use the `NUGET_URL` environment variable. This allows you to override the default behavior, which is to discover the feed URL from the official NuGet V3 API endpoint (`https://api.nuget.org/v3/index.json`).\n\nBy setting `NUGET_URL` to the URL of your private feed (e.g., from Azure Artifacts or a private NuGet server), you direct cdxgen to query your internal source for package metadata. For example: `NUGET_URL=https://nuget.mycompany.com/v3/index.json`. This is essential for scanning .NET projects that rely on internal or third-party packages not available on the public nuget.org."}]}
{"messages": [{"role": "user", "content": "My Python project requires `--ignore-requires-python` when installing dependencies. How do I pass this to cdxgen?"}, {"role": "assistant", "content": "When cdxgen needs to install Python dependencies using `pip`, you can pass additional arguments to the `pip install` command by using the `PIP_INSTALL_ARGS` environment variable. This is the correct way to provide flags like `--ignore-requires-python`.\n\nYou would set the variable like this: `PIP_INSTALL_ARGS=--ignore-requires-python`. You can also include other useful flags, such as `--no-warn-conflicts` or `--python-version`. This gives you fine-grained control over how `pip` behaves when cdxgen invokes it, allowing you to work around version conflicts or other installation issues specific to your project."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `PIP_TARGET` environment variable in cdxgen?"}, {"role": "assistant", "content": "The `PIP_TARGET` environment variable is used to specify a target directory for `pip install` commands executed by cdxgen. When `PIP_TARGET` is set, `pip` will install packages into the specified directory instead of the standard site-packages location. This is equivalent to using the `pip install --target` option.\n\nThis feature is particularly useful in cdxgen for creating isolated environments for dependency analysis. cdxgen can install dependencies into a temporary directory, analyze them, and then clean up the directory afterward. This avoids polluting the global or virtual environment and ensures that the dependency analysis is self-contained and clean for every run."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use a private PyPI repository like `devpi`?"}, {"role": "assistant", "content": "To configure cdxgen to use a private or custom Python Package Index (PyPI) repository, you need to set the `PYPI_URL` environment variable. By default, cdxgen uses the public PyPI URL (`https://pypi.org/pypi/`). By overriding this variable, you can point cdxgen to your internal repository server.\n\nFor example, if your `devpi` server is at `http://devpi.mycompany.local/root/pypi`, you would set `PYPI_URL=http://devpi.mycompany.local/root/pypi/`. This will cause cdxgen to send all its requests for Python package metadata to your server, enabling it to correctly resolve dependencies in a corporate or offline setting."}]}
{"messages": [{"role": "user", "content": "My Ruby project's tests fail if test-scoped gems are installed. How can I pass `--without=test` to the bundle install command in cdxgen?"}, {"role": "assistant", "content": "You can pass additional arguments to the `bundle install` command that cdxgen executes by using the `BUNDLE_INSTALL_ARGS` environment variable. This is the perfect mechanism for adding flags like `--without` to control which gem groups are installed.\n\nTo prevent the installation of gems in the `test` group, you would set the variable as follows: `BUNDLE_INSTALL_ARGS=--without=test`. cdxgen will then append these arguments to the `bundle install` command it runs, ensuring that the dependency installation matches your project's specific requirements and avoids potential issues with certain gem groups."}]}
{"messages": [{"role": "user", "content": "How do I pass arguments to the `bundle update` command in cdxgen?"}, {"role": "assistant", "content": "Similar to `bundle install`, cdxgen allows you to pass additional arguments to the `bundle update` command if it needs to be run. You can do this by setting the `BUNDLE_UPDATE_ARGS` environment variable. The string you provide will be appended to the `bundle update` command line.\n\nFor instance, if you want to force an update on a specific gem, you might set `BUNDLE_UPDATE_ARGS=--source my_gem`. This gives you control over the update process that cdxgen might trigger during its analysis, ensuring it aligns with your project's maintenance practices."}]}
{"messages": [{"role": "user", "content": "I'm using a custom `GEM_HOME` for my Ruby project. How do I make cdxgen aware of it?"}, {"role": "assistant", "content": "To make cdxgen use a custom `GEM_HOME` directory, you need to set the `CDXGEN_GEM_HOME` environment variable. This is particularly important when cdxgen is performing a deep scan to collect module names for all gems. By default, it might look in the system's default gem locations, but this variable allows you to point it to a project-specific or user-defined `GEM_HOME`.\n\nSetting `CDXGEN_GEM_HOME=/path/to/my/gem_home` ensures that cdxgen looks for installed gems in the correct location. You can also use this in combination with the standard `GEM_PATH` environment variable to improve the success rate of finding all necessary gems for a complete and accurate SBOM."}]}
{"messages": [{"role": "user", "content": "I use `rbenv` to manage my Ruby versions, but it's installed in a non-standard directory. How can I configure this in cdxgen?"}, {"role": "assistant", "content": "If you have a custom `rbenv` installation, you need to inform cdxgen of its location so it can correctly use the `rbenv` environment. You can do this by setting the `RBENV_ROOT` environment variable. This variable should be set to the root directory of your `rbenv` installation.\n\nFor example, if `rbenv` is installed in `/opt/rbenv`, you would set `RBENV_ROOT=/opt/rbenv`. This allows cdxgen to find the `rbenv` executable and correctly initialize the environment, ensuring that it uses the Ruby version and gems specified by your project's `.ruby-version` file and `Gemfile`."}]}
{"messages": [{"role": "user", "content": "How can I tell cdxgen to use a specific `rbenv` executable?"}, {"role": "assistant", "content": "If you need to use a specific `rbenv` command, for example, a wrapper script or one located in a non-standard `bin` directory, you can specify it using the `RBENV_CMD` environment variable. This variable overrides the default `rbenv` command that cdxgen would try to find on the system `PATH`.\n\nFor instance, if you have a custom `rbenv` runner at `/usr/local/bin/my-rbenv`, you would set `RBENV_CMD=/usr/local/bin/my-rbenv`. cdxgen will then use this specified command for all `rbenv`-related operations, giving you full control over how the Ruby environment is managed during the scan."}]}
{"messages": [{"role": "user", "content": "How do I configure cdxgen to use a private Rust crate registry?"}, {"role": "assistant", "content": "To make cdxgen interact with a private or mirrored Rust crate registry, you need to set the `RUST_CRATES_URL` environment variable. By default, cdxgen queries the public registry at `https://crates.io/api/v1/crates/` for package metadata. This variable allows you to redirect those requests to your own registry.\n\nFor example, if your company hosts a private registry at `https://crates.mycompany.com/api/v1/crates/`, you would set the `RUST_CRATES_URL` to this value. This is essential for scanning Rust projects that depend on internal crates or for working in environments with restricted access to the public internet."}]}
{"messages": [{"role": "user", "content": "I need cdxgen to use a specific sbt cache directory for class name resolving. How do I set this?"}, {"role": "assistant", "content": "To specify a custom sbt cache directory for cdxgen to use, you should set the `SBT_CACHE_DIR` environment variable. This is important for features like class name resolving, as the sbt cache (`~/.sbt/` or `~/.ivy2/cache/`) contains the downloaded dependency JARs and other artifacts that cdxgen can analyze.\n\nBy pointing cdxgen to the correct cache directory (e.g., `SBT_CACHE_DIR=/path/to/.ivy2/cache`), you ensure that it has access to the same artifacts that your build uses. This can improve the accuracy of the generated SBOM and may speed up the process by allowing cdxgen to find information locally instead of fetching it from remote repositories."}]}
{"messages": [{"role": "user", "content": "My Swift build requires special compiler arguments for semantic analysis. How can I provide them to cdxgen?"}, {"role": "assistant", "content": "When cdxgen performs semantic analysis on Swift code, it may need the same compiler arguments that your project uses to build correctly. You can provide a full string of these arguments using the `SWIFT_COMPILER_ARGS` environment variable. This string will be passed directly to the Swift compiler during analysis.\n\nFor example, you might need to specify an SDK path and framework search paths: `SWIFT_COMPILER_ARGS=\"-sdk /path/to/sdk -F /path/to/frameworks -Xcc -I /path/to/includes\"`. Providing the correct arguments is crucial for cdxgen to parse the code correctly and accurately identify dependencies, especially in complex projects with mixed Objective-C and Swift codebases."}]}
{"messages": [{"role": "user", "content": "How can I add extra compiler arguments to the ones cdxgen auto-detects for my Swift project?"}, {"role": "assistant", "content": "If you want to add a few specific compiler arguments to the ones that cdxgen automatically detects, without replacing the entire set, you should use the `SWIFT_COMPILER_EXTRA_ARGS` environment variable. This allows you to append additional flags to the detected compiler invocation.\n\nFor instance, if you want to suppress warnings and track system dependencies during the scan, you could set `SWIFT_COMPILER_EXTRA_ARGS=\"-suppress-warnings -track-system-dependencies\"`. This is more convenient than using `SWIFT_COMPILER_ARGS` when you only need to make small adjustments to the auto-detected configuration."}]}
{"messages": [{"role": "user", "content": "How do I specify Swift SDK arguments like the SDK path for cdxgen?"}, {"role": "assistant", "content": "To provide Swift SDK-related arguments, such as the path to a specific SDK, you can use the `SWIFT_SDK_ARGS` environment variable. This variable is specifically intended for arguments that define the SDK environment for the Swift compiler.\n\nFor example, if you need to build against a specific iOS SDK, you might set `SWIFT_SDK_ARGS=\"-sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk\"`. This ensures that cdxgen's analysis is performed in the context of the correct SDK, which is critical for resolving system frameworks and other SDK-provided dependencies."}]}
{"messages": [{"role": "user", "content": "How can I pass additional arguments to the `swift package show-dependencies` command?"}, {"role": "assistant", "content": "To pass extra arguments to the `swift package` command that cdxgen uses to discover dependencies, you can use the `SWIFT_PACKAGE_ARGS` environment variable. The arguments you provide will be inserted into the command line before the `show-dependencies` subcommand.\n\nThis is useful for controlling various aspects of the package resolution process. For example, you might need to specify the number of jobs to use or a path to Swift SDKs. An example setting would be: `SWIFT_PACKAGE_ARGS=\"--swift-sdks-path /path/to/sdks --jobs 4\"`. This allows you to customize how Swift Package Manager is invoked to match your project's build requirements."}]}
{"messages": [{"role": "user", "content": "I am running cdxgen in a restricted network. How can I disable the Maven search fallback?"}, {"role": "assistant", "content": "If you are in an environment with no access to the public internet, you should disable cdxgen's feature that searches `search.maven.org` for missing metadata. You can do this by setting the `SEARCH_MAVEN_ORG` environment variable to `false`.\n\nBy setting `SEARCH_MAVEN_ORG=false`, you prevent cdxgen from attempting to make outbound network requests to Maven Central when it encounters a JAR file with incomplete metadata. This will stop connection errors from appearing in your logs and can slightly speed up scans by skipping the unnecessary network attempts. This assumes that all necessary metadata is available in your private repository, which should be configured with `MAVEN_CENTRAL_URL`."}]}
{"messages": [{"role": "user", "content": "Can I provide my SBOM signing private key as an environment variable instead of a file?"}, {"role": "assistant", "content": "Yes, cdxgen supports providing the private key for SBOM signing directly as a base64-encoded environment variable. This is often more convenient and secure in CI/CD pipelines than managing key files on disk. To do this, use the `SBOM_SIGN_PRIVATE_KEY_BASE64` variable.\n\nYou should take your private key file, base64 encode its contents, and set the resulting string as the value for this environment variable. This method, combined with `SBOM_SIGN_ALGORITHM`, allows for a completely file-less signing process. You can similarly provide the public key using `SBOM_SIGN_PUBLIC_KEY_BASE64` if you wish to embed it in the signature."}]}
{"messages": [{"role": "user", "content": "What is the role of `GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE`?"}, {"role": "assistant", "content": "The `GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE` variable is used to configure how cdxgen detects standard proxy environment variables like `HTTP_PROXY` and `HTTPS_PROXY`. Some tools or environments might prefix these variables (e.g., `APP_HTTP_PROXY`), and this setting allows cdxgen to find them.\n\nBy default, this namespace is an empty string, meaning cdxgen looks for the standard, non-prefixed `HTTP_PROXY`. If your organization's proxy settings use a specific namespace, you can set this variable to that prefix. This ensures that cdxgen's outbound HTTP requests are correctly routed through your corporate proxy, which is crucial for network access in many enterprise environments."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use the `mvn dependency:tree` command for analyzing my Maven project?"}, {"role": "assistant", "content": "To ensure cdxgen uses the `mvn dependency:tree` command for Maven project analysis, you should set the `PREFER_MAVEN_DEPS_TREE` environment variable to `true`. Since version 11 of cdxgen, this is the default behavior, so you typically don't need to set it unless you want to be explicit or override a different configuration.\n\nThis method involves cdxgen executing `mvn dependency:tree`, which prints the project's resolved dependency hierarchy to the console. cdxgen then parses this text-based output to construct the SBOM. This approach is generally fast and doesn't require any extra Maven plugins to be installed or configured in your project."}]}
{"messages": [{"role": "user", "content": "When would I want to use the CycloneDX Maven plugin instead of `dependency:tree` with cdxgen?"}, {"role": "assistant", "content": "You would choose to use the CycloneDX Maven plugin over the `dependency:tree` method by setting `PREFER_MAVEN_DEPS_TREE=false`. This might be preferable in a few scenarios. The CycloneDX plugin is purpose-built for generating CycloneDX SBOMs and may provide richer or more accurate metadata in certain edge cases, as it has direct access to the Maven project object model during the build.\n\nAdditionally, if your project is already configured with a specific version of the `cyclonedx-maven-plugin` and you want to ensure cdxgen uses that exact logic, disabling `PREFER_MAVEN_DEPS_TREE` is the way to go. This can lead to more consistent SBOMs if you also generate them manually using the plugin in other parts of your workflow."}]}
{"messages": [{"role": "user", "content": "What happens if both `COCOA_INCLUDED_TARGETS` and `COCOA_EXCLUDED_TARGETS` are set?"}, {"role": "assistant", "content": "The documentation does not explicitly state the order of precedence if both `COCOA_INCLUDED_TARGETS` and `COCOA_EXCLUDED_TARGETS` are set. However, in typical software configuration, an 'include' or 'allow' list often takes precedence over an 'exclude' or 'deny' list. The most likely behavior is that cdxgen would first form a list of targets based on the `COCOA_INCLUDED_TARGETS` variable, and then it would filter that list, removing any targets that also appear in `COCOA_EXCLUDED_TARGETS`.\n\nFor the clearest and most predictable behavior, it is highly recommended to use only one of these variables at a time. If you want to scan a specific subset of targets, use `COCOA_INCLUDED_TARGETS`. If you want to scan most targets but skip a few, use `COCOA_EXCLUDED_TARGETS`. Using both simultaneously can lead to confusing and hard-to-debug configurations."}]}
{"messages": [{"role": "user", "content": "I am working on a react-native project. Which Cocoa environment variables are most relevant to me?"}, {"role": "assistant", "content": "For developers working with React Native or Expo, several Cocoa-related environment variables are particularly relevant due to the way these frameworks integrate native code. First, `COCOA_RESOLVE_FROM_NODE` is important, as it's enabled by default to correctly identify local pods included from your `node_modules` directory. You might use `COCOA_RESOLVE_FROM_NODE_EXCLUSION_DIRS` to fine-tune this behavior.\n\nSecond, you may encounter podspec files that are not directly parsable because they use variables or functions that are processed by the Podfile. In this case, `COCOA_PODSPEC_JSON_REPLACEMENTS` (for JSON podspecs) and `COCOA_PODSPEC_REPLACEMENTS` (for Ruby podspecs) are critical. These variables allow you to apply on-the-fly text substitutions to fix these podspecs before they are parsed by cdxgen, which is a common requirement in React Native projects."}]}
{"messages": [{"role": "user", "content": "How do I provide my Docker registry password to cdxgen without using a config file?"}, {"role": "assistant", "content": "If you cannot use the standard `$HOME/.docker/config.json` file, you can provide your Docker registry credentials directly to cdxgen using a set of environment variables. You will need to set `DOCKER_SERVER_ADDRESS` to your registry's URL, `DOCKER_USER` to your username, and `DOCKER_PASSWORD` to your password or access token.\n\nFor example:\n`DOCKER_SERVER_ADDRESS=https://myregistry.mycompany.com`\n`DOCKER_USER=my-username`\n`DOCKER_PASSWORD=my-secret-password`\nWhile this method is straightforward, be mindful of the security implications of exposing secrets like passwords directly as environment variables, especially in shared or logged CI/CD environments. Using a credentials manager or the Docker config file is generally a more secure practice."}]}
{"messages": [{"role": "user", "content": "Can cdxgen analyze a Docker image from a host connected via SSH?"}, {"role": "assistant", "content": "Yes, cdxgen can interact with a Docker daemon on a remote host via TCP or SSH. To do this, you need to set the `DOCKER_HOST` environment variable to the appropriate connection string. The Docker CLI documentation specifies the format for these strings.\n\nFor an SSH connection, you would set it like this: `DOCKER_HOST=ssh://user@remote-host`. When `DOCKER_HOST` is set to a remote machine, cdxgen will use the local Docker CLI to communicate with the remote daemon. This means the Docker CLI must be installed on the machine where you are running cdxgen. It will then pull the image from the remote host for analysis."}]}
{"messages": [{"role": "user", "content": "Why would I need to override the default Gradle dependency task name?"}, {"role": "assistant", "content": "The `GRADLE_DEPENDENCY_TASK` environment variable allows you to change the Gradle task that cdxgen uses to list project dependencies. By default, cdxgen uses the standard `dependencies` task. However, you might need to override this in a customized build environment.\n\nFor example, your project might have a custom-defined task, say `myCustomDependencies`, that is specifically configured to output the dependency graph in a certain format or for a specific, non-standard configuration. By setting `GRADLE_DEPENDENCY_TASK=myCustomDependencies`, you can instruct cdxgen to use your custom task instead of the default one, allowing for greater integration with complex Gradle builds."}]}
{"messages": [{"role": "user", "content": "My Gradle project has included builds. How does cdxgen handle these?"}, {"role": "assistant", "content": "cdxgen automatically detects and handles included builds in a Gradle project, which are common in composite build setups. It scans the main project and any builds included via the `settings.gradle` file. However, if the automatic detection fails or if you want to explicitly control which included builds are scanned, you can use the `GRADLE_INCLUDED_BUILDS` environment variable.\n\nThis variable takes a comma-separated list of the names of the included builds you want to scan. You should use the names as defined in your settings file (e.g., `my-library`). For convention plugins, remember to include the leading colon (`:`). This gives you manual control to ensure all necessary parts of your composite build are included in the SBOM."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `JAVA21_TOOL` variable?"}, {"role": "assistant", "content": "The `JAVA21_TOOL` environment variable is used to specify the exact Java 21 toolchain version that cdxgen should use for its analysis. This is particularly important for projects that are built and compiled with Java 21, as using the correct JDK version for dependency analysis ensures compatibility and accuracy.\n\nBy default, cdxgen uses a pre-configured version (`21.0.8-tem`), but your project may require a different patch version or a distribution from a different vendor. By setting `JAVA21_TOOL` to your desired version (e.g., `21.0.8-oracle`), you can align cdxgen's execution environment perfectly with your project's build environment, which is a best practice for creating reliable and reproducible SBOMs."}]}
{"messages": [{"role": "user", "content": "Is there a security risk if I don't set `CDXGEN_ALLOWED_HOSTS`?"}, {"role": "assistant", "content": "If you do not set the `CDXGEN_ALLOWED_HOSTS` environment variable, cdxgen is permitted to make network requests to any remote host. This could potentially introduce a security risk. For example, a malicious or compromised package in your project could specify a URL in its metadata that points to a harmful server. When cdxgen tries to fetch additional information from that URL, it could be exposed to an attack or data exfiltration attempt.\n\nBy setting `CDXGEN_ALLOWED_HOSTS` to a specific list of trusted hosts (e.g., `registry.npmjs.org,github.com,pypi.org`), you create a network boundary for cdxgen. Any attempt to contact a host not on this list will be blocked, significantly reducing the attack surface. This is a highly recommended security practice, especially in automated CI/CD environments."}]}
{"messages": [{"role": "user", "content": "How can I log cdxgen's trace output to the console instead of a file?"}, {"role": "assistant", "content": "By default, cdxgen's trace output is directed to the standard output of the process (`process.stdout`), which is typically your console. To enable this tracing, you need to set the `CDXGEN_TRACE_MODE` environment variable. Once enabled, details about external commands and remote hosts accessed will be printed to the console.\n\nThe `CDXGEN_TRACE_LOG` environment variable is used only when you want to redirect this output from the console to a specific file. Therefore, to log to the console, you simply need to enable the trace mode and ensure that `CDXGEN_TRACE_LOG` is not set. This is useful for real-time monitoring of cdxgen's activities during a manual run."}]}
{"messages": [{"role": "user", "content": "What are some valid values for the `SBOM_SIGN_ALGORITHM` environment variable?"}, {"role": "assistant", "content": "The `SBOM_SIGN_ALGORITHM` environment variable specifies which cryptographic algorithm to use for signing the generated SBOM. cdxgen supports a variety of standard algorithms to ensure broad compatibility. You should choose one based on your key type and security requirements.\n\nFor keys based on RSA, you can use `RS256`, `RS384`, or `RS512`. For keys using RSA with PSS padding, you can use `PS256`, `PS384`, or `PS512`. If you are using Elliptic Curve (EC) keys, a common choice is `ES256`. The choice of algorithm is critical for ensuring the integrity and authenticity of your SBOM, and it must match the key you provide."}]}
{"messages": [{"role": "user", "content": "My CocoaPods scan on Windows is very slow. Can I speed it up?"}, {"role": "assistant", "content": "Yes, you can significantly speed up CocoaPods scans when running on a non-macOS system like Windows. The slowness is likely because cdxgen is attempting a full scan, which requires the `pod` command-line toola tool that is not available on Windows. This attempt likely results in a timeout or a very slow failure path.\n\nTo fix this, you should perform a shallow scan by setting the `COCOA_FULL_SCAN` environment variable to `false` or `0`. In this mode, cdxgen will not attempt to invoke the `pod` tool. Instead, it will parse the `Podfile.lock` directly to extract basic dependency information like names and versions. This is much faster and is the intended way to run Cocoa scans on systems where the full CocoaPods toolchain is not present."}]}
{"messages": [{"role": "user", "content": "I'm generating an SBOM for a Go project. How can I ensure the VCS (Version Control System) URL is included for each dependency?"}, {"role": "assistant", "content": "To enrich your Go SBOM with VCS information, such as the source repository URL for each dependency, you need to enable a specific cdxgen feature. Set the environment variable `GO_FETCH_VCS` to `true` or `1`. \n\nWhen this option is activated, cdxgen will make network requests to the Go package discovery service (pkg.go.dev by default) for each dependency identified in your project. This service provides metadata that includes the canonical VCS URL. This information is then embedded in the SBOM, which is highly valuable for source code traceability and security analysis tools that need to link a component back to its repository."}]}
{"messages": [{"role": "user", "content": "Does cdxgen use my local Maven `settings.xml` file automatically?"}, {"role": "assistant", "content": "Yes, cdxgen is designed to work with your existing Maven configuration. When it executes the `mvn` command (or `mvnw`), Maven itself will automatically locate and use your `settings.xml` file from the standard locations (`${user.home}/.m2/settings.xml` and `${maven.home}/conf/settings.xml`). This means your configured repositories, mirrors, proxies, and authentication details will be respected during the SBOM generation process.\n\nIf you need to use a different `settings.xml` file for a specific run, you can use the `MVN_ARGS` environment variable to pass the `--settings` flag. For example: `MVN_ARGS=\"--settings /path/to/custom-settings.xml\"`. This allows you to override the default behavior and use a project-specific configuration."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use a specific Node.js version on a machine without NVM?"}, {"role": "assistant", "content": "If you are not using NVM and have multiple Node.js versions installed, the most reliable way to ensure cdxgen uses a specific version is to make sure that the `bin` directory of your desired Node.js installation comes first in your system's `PATH` environment variable. cdxgen, like any other command-line tool, will use the `node` executable it finds first in the `PATH`.\n\nAlternatively, if you are running cdxgen as a Node.js script (e.g., `node /path/to/cdxgen/index.js`), you can invoke it with the specific Node.js executable you want to use, for example: `/usr/local/bin/node-v18/bin/node /path/to/cdxgen/index.js`. While there isn't a dedicated environment variable in the provided list to specify a Node.js path, controlling it via the system `PATH` is the standard and most effective method."}]}
{"messages": [{"role": "user", "content": "Can I use `CDXGEN_ALLOWED_COMMANDS` to allow commands with specific paths?"}, {"role": "assistant", "content": "The `CDXGEN_ALLOWED_COMMANDS` variable is designed to allowlist command names, not full paths. For example, you would set it to `mvn,npm,gradle`. cdxgen then looks for these executables in the system's `PATH`. This provides a basic level of security by restricting which commands can be invoked by name.\n\nThis mechanism does not, however, prevent the execution of a command if it is invoked with a full path and that path is somehow passed as an argument to an allowed command (e.g., `bash -c /usr/bin/disallowed_command`). Therefore, while `CDXGEN_ALLOWED_COMMANDS` is a useful security layer, it should be combined with other security controls, such as running cdxgen in a minimal container with a restricted set of binaries available, to create a truly secure environment."}]}
{"messages": [{"role": "user", "content": "If I set `GRADLE_USE_DAEMON=false`, does cdxgen still try to stop the daemon?"}, {"role": "assistant", "content": "No, if you explicitly set `GRADLE_USE_DAEMON=false`, cdxgen will not attempt to use the Gradle Daemon, and as a consequence, it will not try to stop it either. The `GRADLE_STOP_DAEMON` variable is only relevant when the daemon is being used. Its default behavior of `true` is tied to `GRADLE_USE_DAEMON` also being `true`.\n\nBy disabling the daemon, you are telling cdxgen to run every Gradle command in a fresh JVM process (`--no-daemon`). This ensures maximum isolation for the build but comes at a performance cost. Since no new daemon process is being managed by cdxgen, there is nothing for it to stop at the end of the run."}]}
{"messages": [{"role": "user", "content": "Is there a way to make cdxgen ignore all dotfiles and dot-directories during AST generation?"}, {"role": "assistant", "content": "Yes, you can use the `ASTGEN_IGNORE_FILE_PATTERN` environment variable to create a regular expression that ignores files and directories starting with a dot. While dot-directories like `.git` or `.venv` are often ignored by default or can be added to `ASTGEN_IGNORE_DIRS`, a regex pattern can provide a more comprehensive solution.\n\nTo ignore all paths that contain a segment starting with a dot (e.g., `.git`, `.github`, `.DS_Store`), you could use a regex that matches the pattern `\\/\\.`. For example: `ASTGEN_IGNORE_FILE_PATTERN='\\/\\.'`. This would effectively exclude any file or directory that is typically hidden on Unix-like systems from the AST parsing phase, helping to focus the scan on actual source code."}]}
{"messages": [{"role": "user", "content": "Can I use environment variables to configure proxy settings for cdxgen?"}, {"role": "assistant", "content": "Yes, cdxgen respects standard proxy environment variables. The underlying HTTP agent it uses will automatically detect and use `HTTP_PROXY`, `HTTPS_PROXY`, and `NO_PROXY` if they are set in your environment. This is the standard way to configure proxy settings for command-line tools in most operating systems.\n\nThe `GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE` variable provides additional control. If your proxy variables are namespaced (e.g., `MYAPP_HTTP_PROXY`), you can set this variable to `MYAPP_` to make cdxgen use them. By default, the namespace is empty, so it looks for the standard, un-prefixed variables. This ensures cdxgen can make outbound requests through your corporate proxy for fetching package metadata."}]}
{"messages": [{"role": "user", "content": "What is the best way to handle 'Out Of Memory' errors in cdxgen?"}, {"role": "assistant", "content": "Encountering 'Out Of Memory' errors with cdxgen typically means the underlying Node.js process does not have enough heap memory to handle the size of your project's dependency graph. The best way to resolve this is by allocating more memory to the Node.js runtime using the `NODE_OPTIONS` environment variable.\n\nThe most effective flag for this is `--max-old-space-size`, which sets the maximum heap size in megabytes. For a large project, you might start by doubling the default, or setting it to a generous value like `8192` for 8GB. For example: `NODE_OPTIONS=\"--max-old-space-size=8192\" cdxgen ...`. This single adjustment is usually sufficient to resolve memory-related crashes."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support authentication with private NuGet feeds?"}, {"role": "assistant", "content": "The provided documentation focuses on configuring the URL for a private NuGet feed via the `NUGET_URL` environment variable. It does not explicitly list environment variables for providing usernames and passwords for NuGet feed authentication. In the .NET ecosystem, authentication is typically handled through `nuget.config` files, where you can store credentials for package sources.\n\nc-dxgen will likely rely on the underlying .NET tools (`dotnet` or `nuget`) to handle authentication. Therefore, the best practice would be to ensure your `nuget.config` file is correctly configured with credentials for your private feed. The tool, when invoked by cdxgen, should then be able to authenticate successfully. This is similar to how cdxgen relies on the `$HOME/.docker/config.json` for Docker authentication."}]}
{"messages": [{"role": "user", "content": "Can `CDXGEN_TEMP_DIR` point to a directory that doesn't exist yet?"}, {"role": "assistant", "content": "The documentation states that `CDXGEN_TEMP_DIR` specifies the *parent* temporary directory. This implies that cdxgen will create its own unique working subdirectory inside the path you provide. Therefore, the directory you specify with `CDXGEN_TEMP_DIR` must already exist and be writable by the user running cdxgen.\n\nFor example, if you set `CDXGEN_TEMP_DIR=/tmp/my-app-scans`, the `/tmp/my-app-scans` directory needs to exist before you run the command. cdxgen will then create a new directory inside it, for example, `/tmp/my-app-scans/cdxgen-12345`, to store its intermediate files. This temporary subdirectory will be automatically deleted upon completion."}]}
{"messages": [{"role": "user", "content": "How do I add a new directory to the default `ASTGEN_IGNORE_DIRS` list without overwriting it?"}, {"role": "assistant", "content": "The `ASTGEN_IGNORE_DIRS` environment variable replaces the default list entirely; it does not append to it. The documentation mentions that it defaults to a predefined list (including `venv`), so if you want to add a new directory, you must include the default ones you wish to keep.\n\nTo achieve this, you should first identify the likely default values (e.g., `venv`, `node_modules`, `bower_components`, `target`, `build`, `dist`) and then add your own. For example, if you want to add the `docs` directory to the ignore list, you would set the variable like this: `ASTGEN_IGNORE_DIRS=venv,node_modules,target,build,dist,docs`. This ensures you keep the beneficial default exclusions while adding your custom one."}]}
{"messages": [{"role": "user", "content": "What is the `CDX_MAVEN_GOAL` default value?"}, {"role": "assistant", "content": "The default value for the `CDX_MAVEN_GOAL` environment variable is `makeAggregateBom`. This goal is part of the CycloneDX Maven plugin and is specifically designed for multi-module Maven projects. When executed from the root of such a project, it aggregates dependency information from all sub-modules into a single, comprehensive SBOM file.\n\nThis default is sensible because it provides the most common desired behavior for Maven projects out-of-the-box. If you were working with a single-module project, this goal would still work correctly. You would only need to change it to another goal, like `makeBom` (for a single module's SBOM) or `makePackageBom`, if you have very specific requirements for how the SBOM is generated."}]}
{"messages": [{"role": "user", "content": "How do I use a base64 encoded public key for SBOM signing?"}, {"role": "assistant", "content": "To include a public key in your SBOM's signature section using a base64 encoded string, you should use the `SBOM_SIGN_PUBLIC_KEY_BASE64` environment variable. This is an optional step but is useful for creating a self-verifiable SBOM, as the key needed for verification is embedded directly within it.\n\nFirst, take your public key file (e.g., `public.pem`) and encode its contents into a base64 string. Then, set this string as the value for the `SBOM_SIGN_PUBLIC_KEY_BASE64` variable. When cdxgen creates the signature, it will include this base64-encoded public key in the signature block of the final SBOM."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support multi-project Gradle builds with modules defined in `node_modules`?"}, {"role": "assistant", "content": "Yes, cdxgen has specific support for hybrid projects, particularly those seen in frameworks like React Native, where some Gradle modules are sourced from the `node_modules` directory. This behavior is controlled by the `GRADLE_RESOLVE_FROM_NODE` environment variable, which is enabled by default.\n\nWhen this feature is active, cdxgen will attempt to resolve Gradle modules whose paths point inside the `node_modules` directory. This allows it to correctly identify and analyze these hybrid native dependencies that are managed via npm or Yarn. If you do not want this behavior, you can disable it by setting `GRADLE_RESOLVE_FROM_NODE=false`."}]}
{"messages": [{"role": "user", "content": "Is it possible to use cdxgen in an environment that requires TLS client certificate authentication for all outgoing traffic?"}, {"role": "assistant", "content": "The provided documentation shows specific support for TLS client certificates for Docker registry connections via the `DOCKER_CERT_PATH` variable. However, it does not mention a generic, global option for providing a client certificate for all other outgoing HTTP requests (e.g., to Maven, npm, or PyPI registries).\n\nIn such a highly secured environment, this functionality is typically handled by a forward proxy that manages the client certificate authentication on behalf of all applications. You would configure cdxgen to use this proxy by setting the `HTTPS_PROXY` environment variable. The proxy would then be responsible for presenting the required client certificate to the upstream servers, allowing cdxgen to function without needing direct knowledge of the certificates."}]}
{"messages": [{"role": "user", "content": "How does cdxgen handle a project with both a `package-lock.json` and a `yarn.lock` file?"}, {"role": "assistant", "content": "The documentation does not specify the exact precedence logic when multiple lockfiles for Node.js projects are present. Typically, dependency analysis tools have a defined order of preference. A common approach is to prefer the lockfile that corresponds to the most widely used package manager, or to look for other clues like the presence of a `.yarnrc.yml` file to infer which package manager is primary.\n\nTo ensure predictable behavior, it is best practice to have only one lockfile in your project repository that reflects the package manager you actively use (`npm`, `yarn`, or `pnpm`). If you must have multiple lockfiles, you may need to temporarily remove or rename the one you don't want cdxgen to use before running a scan. For more insight into the tool's choice, you can run it with `CDXGEN_DEBUG_MODE=verbose` to see the 'think mode' logs, which might explain which lockfile was chosen and why."}]}
{"messages": [{"role": "user", "content": "What is the best way to get a complete and accurate SBOM for a Go project using cdxgen?"}, {"role": "assistant", "content": "To get the most comprehensive and accurate SBOM for a Go project, you should configure cdxgen with a couple of specific environment variables. First, it is highly recommended to use the `go.sum` file as the source of truth, as it contains a complete, cryptographically verified list of all direct and transitive dependencies. You can enable this by setting `USE_GOSUM=true`.\n\nSecond, to enrich the SBOM with valuable source code location information, you should also enable VCS data fetching by setting `GO_FETCH_VCS=true`. This will add the repository URL to each component. Combining these two settings (`USE_GOSUM=true` and `GO_FETCH_VCS=true`) will produce a high-fidelity SBOM that accurately reflects your build's entire dependency graph and links each component back to its source."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to scan a project without any network access?"}, {"role": "assistant", "content": "Yes, you can run cdxgen in an offline or air-gapped environment, but you may need to configure it properly to prevent it from attempting to make network requests. First, you should disable any features that explicitly fetch data from the internet. This includes setting `FETCH_LICENSE=false` and `SEARCH_MAVEN_ORG=false`.\n\nAdditionally, you must ensure that all necessary dependencies are already available locally in the respective package caches (e.g., local Maven repository, npm cache, Go module cache). cdxgen will use these local caches to find dependency information. For container scans, the Docker image must already be present on the local daemon (`docker images`). By ensuring all artifacts are available locally and disabling online features, you can successfully generate an SBOM without any network access."}]}
{"messages": [{"role": "user", "content": "My Ruby on Rails project uses gems from a private gem server. How do I configure cdxgen for this?"}, {"role": "assistant", "content": "The provided list of environment variables for Ruby does not include a direct option to specify a custom gem server URL, similar to `NPM_URL` or `PYPI_URL`. In the Ruby ecosystem, the source of gems is typically configured within the project's `Gemfile` itself using the `source` directive.\n\ncdxgen works by invoking `bundle` commands, so it will naturally respect the configuration within your `Gemfile`. To use a private gem server, you should ensure your `Gemfile` specifies the correct source URL, like `source 'https://gems.mycompany.com'`. When cdxgen runs `bundle install`, Bundler will automatically use your private server to resolve and fetch gems. Therefore, no specific cdxgen configuration is needed; you just need to have a correctly configured `Gemfile`."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `COCOA_PODSPEC_REPLACEMENTS` variable?"}, {"role": "assistant", "content": "The `COCOA_PODSPEC_REPLACEMENTS` environment variable is a powerful tool for fixing issues in local CocoaPods that use the Ruby-based `.podspec` format. It functions similarly to its JSON counterpart, `COCOA_PODSPEC_JSON_REPLACEMENTS`, by allowing you to perform find-and-replace operations on the content of `.podspec` files before they are parsed.\n\nThis is often necessary in projects where podspecs are generated dynamically or contain custom helper functions that cdxgen's parsing mechanism cannot execute. You can provide a comma-separated list of `text_to_find=replacement` pairs or even use regular expressions. This on-the-fly patching enables cdxgen to correctly parse otherwise problematic podspecs and accurately determine their dependencies."}]}
{"messages": [{"role": "user", "content": "How can I check what external commands cdxgen is running?"}, {"role": "assistant", "content": "The best way to see the external commands that cdxgen is executing during its scan is to use its tracing feature. To do this, you need to enable the trace mode by setting the `CDXGEN_TRACE_MODE` environment variable (the documentation implies this variable enables the mode). The trace output will then be printed to the console by default.\n\nThis output will show you every time cdxgen invokes an external tool like `mvn`, `npm`, `gradle`, `git`, etc., including the full command and its arguments. If you prefer to log this information to a file for later review, you can also set the `CDXGEN_TRACE_LOG` variable to a file path. This is an excellent tool for debugging and for security auditing."}]}
{"messages": [{"role": "user", "content": "What happens if my `GITHUB_TOKEN` is invalid or expired?"}, {"role": "assistant", "content": "If the `GITHUB_TOKEN` you provide to cdxgen is invalid, revoked, or expired, the GitHub API will treat the requests as anonymous. This means you will be subject to the much lower rate limits applied to unauthenticated requests. For small projects, you might not notice any difference.\n\nHowever, when scanning larger projects with many dependencies that need to be looked up on GitHub (for license or repository information), you will likely hit the anonymous rate limit very quickly. When this happens, the GitHub API will start returning error responses (typically HTTP 403 Forbidden or 429 Too Many Requests). This will cause the cdxgen scan to fail, as it will be unable to retrieve the metadata it needs. Therefore, it's crucial to ensure your token is valid and has the necessary permissions."}]}
{"messages": [{"role": "user", "content": "In my multi-project Gradle build, can I skip the `dependencies` task for the root project but still run it for subprojects?"}, {"role": "assistant", "content": "Yes, you can specifically skip the `dependencies` task for the root project while allowing it to run on all the subprojects. To do this, you use the `GRADLE_SKIP_MODULE_DEPENDENCIES` environment variable and set its value to `root`.\n\nSetting `GRADLE_SKIP_MODULE_DEPENDENCIES=root` is useful in cases where the root `build.gradle` file does not declare dependencies in a standard way or is just an aggregator project whose dependencies are fully captured in its subprojects. This prevents potential errors from running the task at the root level but still allows cdxgen to thoroughly analyze all the child modules to build a complete dependency graph for your application."}]}
{"messages": [{"role": "user", "content": "How do I ensure cdxgen uses the Maven wrapper (`mvnw`) and also passes custom arguments to it?"}, {"role": "assistant", "content": "You can achieve both of these goals by using two separate environment variables. First, to ensure cdxgen uses the Maven wrapper, you must set `MVN_CMD=./mvnw` (or `mvnw.cmd` for Windows). This tells cdxgen to use the wrapper script instead of a global `mvn` command.\n\nSecond, to pass additional arguments, you use the `MVN_ARGS` variable. For example, if you want to activate the `release` profile, you would set `MVN_ARGS=\"-P release\"`. cdxgen will combine these, effectively running a command like `./mvnw -P release ...`. This combination gives you precise control, ensuring both the correct Maven version is used and the correct build parameters are applied."}]}
{"messages": [{"role": "user", "content": "Why is my `CDXGEN_REPL_HISTORY` file not being created?"}, {"role": "assistant", "content": "If your REPL command history file specified by `CDXGEN_REPL_HISTORY` is not being created, there are a few likely reasons. First, and most commonly, the directory where you are trying to save the file may not exist, or the user running cdxgen may not have write permissions to that directory. For example, if you set the path to `/var/log/cdxgen_history`, the process might not have permission to write to `/var/log`.\n\nSecond, ensure the variable is set correctly in the environment where you launch the cdxgen REPL. You can verify this by running `echo $CDXGEN_REPL_HISTORY` in your shell before starting cdxgen. The documentation notes that if the variable is not set or the default directory doesn't exist, history will not be saved. To fix this, ensure the full path to the file is valid and writable."}]}
{"messages": [{"role": "user", "content": "Does cdxgen support the Podman REST API for image scanning?"}, {"role": "assistant", "content": "The documentation indicates that you can use Podman as an alternative to Docker by setting `DOCKER_CMD=podman`. This setting configures cdxgen to use the Podman command-line interface (CLI) for container operations. It replaces `docker` commands with `podman` commands (e.g., `podman pull`).\n\nHowever, the documentation does not explicitly mention support for the Podman REST API, which is compatible with the Docker API. The primary mechanism described for non-Docker tools is via the `DOCKER_CMD` variable, which suggests a CLI-based integration. While the underlying libraries cdxgen uses might support it if `DOCKER_HOST` is configured to point to the Podman socket, the most reliable and documented way to use Podman is through the CLI override."}]}
{"messages": [{"role": "user", "content": "How does `COCOA_MERGE_SUBSPECS=false` change the SBOM output?"}, {"role": "assistant", "content": "By default, cdxgen sets `COCOA_MERGE_SUBSPECS` to `true`, which combines all of a Pod's sub-specs and their dependencies into the main root spec component in the SBOM. This creates a single, consolidated entry for the entire Pod.\n\nIf you set `COCOA_MERGE_SUBSPECS=false`, cdxgen will represent each sub-spec as a separate and distinct component in the SBOM. This creates a more granular and technically accurate dependency graph, where the main Pod might depend on `Pod/SubspecA` and `Pod/SubspecB`, and each of these might have their own unique dependencies. This is the more correct representation, but it may not be handled well by all SBOM analysis tools, some of which might not understand the concept of sub-specs as separate dependencies."}]}
{"messages": [{"role": "user", "content": "Can I use `DOCKER_AUTH_CONFIG` for a private registry that is not Docker Hub?"}, {"role": "assistant", "content": "Yes, the `DOCKER_AUTH_CONFIG` variable is designed to work with any Docker V2 compatible registry, not just Docker Hub. This variable expects a base64 encoded JSON string containing your credentials. The JSON structure includes a `serveraddress` key, which you should set to the URL of your private registry.\n\nFor example, the JSON object would look like `{'username': 'myuser', 'password': 'mypass', 'email': 'my@email.com', 'serveraddress': 'https://my.private.registry.com'}`. After base64 encoding this JSON object, you can set it as the value for `DOCKER_AUTH_CONFIG`. This method is very useful for passing credentials securely in CI/CD environments for any Docker-compatible registry."}]}
{"messages": [{"role": "user", "content": "How can I exclude test modules and their dependencies in my Mill project SBOM?"}, {"role": "assistant", "content": "To generate an SBOM for your Mill project that excludes any test-related modules and their associated dependencies, you need to set the `MILL_EXCLUDE_TEST` environment variable. By default, this option is disabled (`false`), so test dependencies are included.\n\nTo activate the exclusion, you must set `MILL_EXCLUDE_TEST=true`. When cdxgen runs with this setting, it will instruct the Mill build tool to resolve a dependency graph that does not include any modules or libraries designated for testing. This is the standard way to produce a clean, production-focused SBOM that accurately represents only the components shipped with your final application."}]}
{"messages": [{"role": "user", "content": "I am using `rbenv`. How do I make sure cdxgen uses the correct Ruby version and gems?"}, {"role": "assistant", "content": "To ensure cdxgen correctly uses your `rbenv`-managed Ruby environment, you should first make sure that `rbenv` is properly initialized in your shell. cdxgen will then typically pick up the correct Ruby version from your project's `.ruby-version` file. If your `rbenv` installation is in a non-standard location, you must set the `RBENV_ROOT` environment variable to point to its root directory.\n\nFurthermore, for gem locations, if you use a custom `GEM_HOME` or `GEM_PATH`, you should set the `CDXGEN_GEM_HOME` environment variable accordingly. This ensures cdxgen's deep scan for gem modules looks in the correct directory. By configuring these variables, you align cdxgen's environment with your project's specific `rbenv` and Bundler setup, leading to an accurate scan."}]}
{"messages": [{"role": "user", "content": "What is the simplest way to provide Docker credentials to cdxgen?"}, {"role": "assistant", "content": "The simplest and most common way to provide Docker credentials to cdxgen is to use the Docker CLI's built-in credential management. Before running cdxgen, simply execute the `docker login` command in your terminal and provide your credentials when prompted: `docker login my.private.registry.com`.\n\nThis command securely stores your credentials in the `config.json` file located in your user's `.docker` directory (usually `$HOME/.docker/config.json`). cdxgen is designed to automatically detect and use this configuration file, so no further environment variables are needed. This method is secure, straightforward, and leverages the standard Docker workflow."}]}
{"messages": [{"role": "user", "content": "How do I use a specific version of the Java 22 toolchain with cdxgen?"}, {"role": "assistant", "content": "To configure cdxgen to use a specific version of the Java 22 toolchain, you need to set the `JAVA22_TOOL` environment variable. This allows you to override the default version (`22.0.2-tem`) that cdxgen uses for analyzing projects based on Java 22.\n\nFor instance, if your project requires a specific build or a version from a different vendor, you would set the variable to that version string, such as `JAVA22_TOOL=22.0.1-graalvm`. This ensures that cdxgen performs its dependency analysis using the exact same JDK that your project is built with, which is crucial for consistency and avoiding compatibility issues."}]}
{"messages": [{"role": "user", "content": "If `PREFER_MAVEN_DEPS_TREE` is false, what CycloneDX Maven plugin goal is used by default?"}, {"role": "assistant", "content": "When `PREFER_MAVEN_DEPS_TREE` is set to `false`, cdxgen will use the CycloneDX Maven plugin to generate the SBOM. In this mode, the specific goal used is controlled by the `CDX_MAVEN_GOAL` environment variable. The default value for this variable is `makeAggregateBom`.\n\nThe `makeAggregateBom` goal is the ideal choice for most projects, especially multi-module ones, as it creates a single SBOM that includes dependencies from all modules. Therefore, even when you opt to use the plugin method, cdxgen's default behavior is to produce a comprehensive, aggregated SBOM for the entire project."}]}
{"messages": [{"role": "user", "content": "How does cdxgen handle Swift package resolution with custom compiler arguments?"}, {"role": "assistant", "content": "cdxgen provides a layered approach to handling custom compiler arguments for Swift, which is essential for correct package resolution and semantic analysis. First, cdxgen attempts to auto-detect the necessary arguments. If you need to add to these, you can use `SWIFT_COMPILER_EXTRA_ARGS`.\n\nIf the auto-detection is insufficient or incorrect, you can provide the entire set of arguments with `SWIFT_COMPILER_ARGS`. For arguments specifically related to the SDK, you can use `SWIFT_SDK_ARGS`. Finally, for the `swift package show-dependencies` command, you can inject arguments before the subcommand using `SWIFT_PACKAGE_ARGS`. This comprehensive set of controls allows you to precisely replicate your project's build environment, ensuring that the Swift Package Manager can resolve dependencies correctly during the cdxgen scan."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to scan a Bazel project on a system where Bazel is not in the system PATH?"}, {"role": "assistant", "content": "The provided documentation does not list an environment variable analogous to `MVN_CMD` or `GRADLE_CMD` for specifying the path to the Bazel executable. Typically, command-line tools like cdxgen expect their dependencies (like Bazel, Maven, etc.) to be available in the system's `PATH`.\n\nIf Bazel is installed in a non-standard location, the best approach would be to temporarily modify the `PATH` environment variable in your shell session before running cdxgen. For example: `export PATH=\"/path/to/bazel/bin:$PATH\"` on Linux/macOS. This will make the `bazel` executable findable by cdxgen without requiring a dedicated configuration variable within the tool itself."}]}
{"messages": [{"role": "user", "content": "I have a Gradle project that uses conventions with a leading colon. How should I refer to them in `GRADLE_INCLUDED_BUILDS`?"}, {"role": "assistant", "content": "The documentation for `GRADLE_INCLUDED_BUILDS` specifically provides guidance for this scenario. When you are specifying included builds that are Gradle conventions, you must include the leading colon (`:`) in their names.\n\nFor example, if you have a convention plugin named `my-convention` that you want to explicitly include in the scan, you should list it in the environment variable as `:my-convention`. So, a full example would be `GRADLE_INCLUDED_BUILDS=:my-convention,another-build`. Following this naming convention is crucial for cdxgen to correctly identify and scan these specific types of included builds in your composite project setup."}]}
{"messages": [{"role": "user", "content": "What is the default behavior of cdxgen regarding test-scoped dependencies in Maven projects?"}, {"role": "assistant", "content": "By default, cdxgen is configured to include test-scoped dependencies when it analyzes a Maven project. This behavior is controlled by the `CDX_MAVEN_INCLUDE_TEST_SCOPE` environment variable, which defaults to `true`.\n\nThis means that without any custom configuration, your generated SBOM will contain all dependencies listed in your `pom.xml`, including those marked with `<scope>test</scope>`, such as JUnit or Mockito. While this provides a complete picture of all project dependencies, you may want to disable it by setting `CDX_MAVEN_INCLUDE_TEST_SCOPE=false` to create an SBOM that only reflects the production dependencies of your application."}]}
{"messages": [{"role": "user", "content": "How do I specify a private Rust registry that uses a different API path?"}, {"role": "assistant", "content": "To configure cdxgen for a private Rust registry, you use the `RUST_CRATES_URL` environment variable. This variable should be set to the full URL of the API endpoint for fetching crate information. The default value is `https://crates.io/api/v1/crates/`.\n\nIf your private registry uses a different API path, you must include that path in the URL you provide. For example, if your registry's API for crates is located at `https://my-crates.internal/api/v2/packages/`, you would set `RUST_CRATES_URL=https://my-crates.internal/api/v2/packages/`. cdxgen will then append the crate name and version to this base URL to fetch the required metadata."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `GLOBAL_NODE_MODULES_PATH` variable?"}, {"role": "assistant", "content": "The `GLOBAL_NODE_MODULES_PATH` environment variable is used to explicitly specify the location of the global `node_modules` directory. cdxgen may need to access this directory, for example, to find globally installed cdxgen plugins when a local plugins directory (`CDXGEN_PLUGINS_DIR`) has not been provided.\n\nWhile cdxgen can often determine this path automatically, this variable is useful in environments where Node.js or npm is installed in a non-standard location, or inside containers where the environment might be minimal. By setting this path directly, you ensure that cdxgen can reliably locate any globally installed packages it needs to function correctly."}]}
{"messages": [{"role": "user", "content": "Can I prevent cdxgen from automatically running `npm install`?"}, {"role": "assistant", "content": "Yes, you can prevent cdxgen from automatically running `npm install`. If cdxgen detects that a `node_modules` directory is missing or incomplete, it may try to run `npm install` to create an accurate dependency tree. This behavior can be controlled with the `NPM_INSTALL_COUNT` environment variable.\n\nTo completely disable automatic installation, you should set `NPM_INSTALL_COUNT=0`. With this setting, cdxgen will not attempt to run `npm install` at all. This is useful in CI/CD pipelines where the dependency installation step is handled separately and you want to ensure the scan only works with the pre-existing `node_modules` directory."}]}
{"messages": [{"role": "user", "content": "How can I customize the sbt cache directory used by cdxgen?"}, {"role": "assistant", "content": "To customize the sbt cache directory that cdxgen uses for its analysis, you need to set the `SBT_CACHE_DIR` environment variable. This is particularly useful for features like class name resolving, as the cache directory (typically containing `.ivy2/cache`) holds the downloaded JAR files for your project's dependencies.\n\nBy setting `SBT_CACHE_DIR` to the path of your project's cache, you ensure that cdxgen has access to the necessary artifacts. This can improve the quality of the generated SBOM by providing more detailed information and can also speed up the scan by leveraging locally available files instead of having to re-fetch them."}]}
{"messages": [{"role": "user", "content": "If I use `BAZEL_USE_ACTION_GRAPH=true`, do I still need to set `BAZEL_TARGET`?"}, {"role": "assistant", "content": "Yes, setting `BAZEL_TARGET` is still essential even when you enable `BAZEL_USE_ACTION_GRAPH=true`. The action graph query that cdxgen runs is dependent on having a specific target to analyze. The query is `bazel aquery 'outputs(\".*.jar\", deps(<BAZEL_TARGET>))'`, where `<BAZEL_TARGET>` is the placeholder for the value you provide.\n\nIf `BAZEL_TARGET` is not set, it defaults to `:all`, which may not be what you want for a precise action graph query. To get a meaningful SBOM for a specific application or library, you must set `BAZEL_TARGET` to the label of that specific build target, for example, `//my-app:my-app-binary`. This will give you a highly accurate SBOM for the dependencies of that specific artifact."}]}
{"messages": [{"role": "user", "content": "My private Maven repository has a group prefix that needs to be stripped by Bazel. How can I configure this?"}, {"role": "assistant", "content": "When using Bazel with a private Maven repository, the repository's structure might include a prefix in the path for Maven artifacts that is not part of the actual group ID. cdxgen's Bazel scanner can be configured to strip this prefix to correctly parse the component's coordinates. This is done using the `BAZEL_STRIP_MAVEN_PREFIX` environment variable.\n\nBy default, this variable is set to `/maven2/`, which is a common prefix. If your repository uses a different structure, for example, if artifacts are located under a path like `com/mycompany/...` but are served from `https://repo.mycompany.com/artifacts/com/mycompany/...`, you would set `BAZEL_STRIP_MAVEN_PREFIX=/artifacts/`. This ensures that the group ID is correctly identified as `com.mycompany`."}]}
{"messages": [{"role": "user", "content": "How do I use a custom Clojure CLI command with cdxgen?"}, {"role": "assistant", "content": "To instruct cdxgen to use a custom command for analyzing Clojure projects, you need to set the `CLJ_CMD` environment variable. By default, cdxgen will try to execute the standard `clojure` command-line tool.\n\nIf you use a wrapper script or a differently named executable (e.g., `clj`), you can specify it with this variable. For instance, `CLJ_CMD=clj` would make cdxgen use the `clj` command instead. This is useful for accommodating different Clojure project setups or for integrating with tools like Leiningen if it's wrapped in a command that behaves like the `clojure` CLI."}]}
{"messages": [{"role": "user", "content": "Can I use wildcards in `COCOA_EXCLUDED_TARGETS`?"}, {"role": "assistant", "content": "The documentation for `COCOA_EXCLUDED_TARGETS` specifies that it takes a comma-separated list of target names. It does not mention any support for wildcards or pattern matching. The examples provided, such as `target/subtarget`, suggest a literal, path-based matching system for nested targets.\n\nTherefore, it is unlikely that wildcards like `*Tests` or `Test*` would work. You would need to explicitly list every target you wish to exclude by its full name. For example, if you have `AppTests`, `LibraryTests`, and `FrameworkTests`, you would need to set `COCOA_EXCLUDED_TARGETS=AppTests,LibraryTests,FrameworkTests`."}]}
{"messages": [{"role": "user", "content": "What is the `NODE_NO_READLINE=1` setting used for in cdxgen?"}, {"role": "assistant", "content": "Setting `NODE_NO_READLINE=1` is an advanced Node.js option that disables the default behavior of the `readline` module. This module is what typically handles interactive input in a terminal, providing features like line editing, history, and raw character access. When disabled, the terminal settings are not modified by Node.js, allowing a program to implement its own custom input handling.\n\nIn the context of cdxgen, this variable is likely exposed to handle edge cases where the default readline behavior might conflict with the environment in which cdxgen is running. This could be a specific type of CI/CD runner, a non-standard terminal emulator, or when cdxgen is being used as a library within another tool that manages terminal I/O itself. For the vast majority of users, this variable will not need to be set."}]}
{"messages": [{"role": "user", "content": "How do I provide custom `pip` install arguments for my Python project scan?"}, {"role": "assistant", "content": "To provide custom arguments to the `pip install` commands that cdxgen may run, you should use the `PIP_INSTALL_ARGS` environment variable. This allows you to append any command-line options that `pip install` accepts, which can be crucial for handling complex or restrictive dependency requirements.\n\nFor example, if your project needs to ignore Python version constraints and also avoid warnings about dependency conflicts, you could set the variable like this: `PIP_INSTALL_ARGS=\"--ignore-requires-python --no-warn-conflicts\"`. cdxgen will then use these arguments whenever it needs to invoke `pip`, ensuring the installation process matches your project's specific needs."}]}
{"messages": [{"role": "user", "content": "How do I force a redownload of gems when cdxgen runs `bundle install`?"}, {"role": "assistant", "content": "If you need to ensure that cdxgen is working with freshly downloaded gems, you can force Bundler to redownload them by passing the `--redownload` flag. You can provide this flag to cdxgen by using the `BUNDLE_INSTALL_ARGS` environment variable.\n\nTo force the redownload, you would set the variable as follows: `BUNDLE_INSTALL_ARGS=--redownload`. When cdxgen invokes `bundle install`, this argument will be included, instructing Bundler to ignore any cached versions of the gems and fetch them again from the source. This can be useful for troubleshooting caching issues or ensuring a clean build."}]}
{"messages": [{"role": "user", "content": "My Mill build has a server. How can I make cdxgen use it but not shut it down afterwards?"}, {"role": "assistant", "content": "You can configure cdxgen to use an existing Mill server for performance and then leave it running after the scan is complete. To do this, you need to set two environment variables. First, enable server usage by setting `MILL_USE_SERVER=true`.\n\nSecond, you must prevent the automatic shutdown by setting `MILL_SHUTDOWN_SERVER=false`. By default, cdxgen will shut down the server it uses, but setting this to `false` overrides that behavior. This setup is ideal in a CI/CD pipeline where you might have another Mill-based build step immediately following the cdxgen scan, as it allows the next step to reuse the warm server, saving time."}]}
{"messages": [{"role": "user", "content": "How can I configure cdxgen to use my Artifactory instance as a PyPI registry?"}, {"role": "assistant", "content": "To configure cdxgen to use a private PyPI repository, such as one hosted on JFrog Artifactory, you need to set the `PYPI_URL` environment variable. This variable should be set to the URL of the PyPI API endpoint provided by your Artifactory instance.\n\nFor example, if your Artifactory PyPI repository is named `pypi-local` and is accessible at `https://artifactory.mycompany.com/artifactory/api/pypi/pypi-local`, you would set `PYPI_URL=https://artifactory.mycompany.com/artifactory/api/pypi/pypi-local/`. This will redirect all of cdxgen's requests for Python package metadata to your Artifactory server, allowing it to resolve internal and proxied Python packages correctly."}]}
{"messages": [{"role": "user", "content": "When scanning a Docker image, does cdxgen use credentials from `DOCKER_USER` and `DOCKER_PASSWORD` automatically?"}, {"role": "assistant", "content": "Yes, if you set the `DOCKER_USER` and `DOCKER_PASSWORD` environment variables, cdxgen will use them to authenticate with a Docker registry. This method is an alternative to using a pre-configured `config.json` file. You should also set `DOCKER_SERVER_ADDRESS` to specify which registry these credentials apply to. If `DOCKER_SERVER_ADDRESS` is not set, it typically defaults to the Docker Hub registry.\n\nThis method is convenient for CI/CD pipelines where credentials are often managed as secrets and injected as environment variables. For example: `DOCKER_USER=myuser DOCKER_PASSWORD=mypassword DOCKER_SERVER_ADDRESS=myregistry.com cdxgen -t docker myimage:latest`. This allows cdxgen to pull images from private repositories that require authentication."}]}
{"messages": [{"role": "user", "content": "How do I specify a target directory for pip installations inside a CI pipeline?"}, {"role": "assistant", "content": "In a CI pipeline, it's often desirable to install Python dependencies into a temporary or isolated directory to avoid conflicts with the system's Python environment. You can instruct cdxgen to do this by using the `PIP_TARGET` environment variable. This variable specifies the target directory for any `pip install` command cdxgen runs.\n\nFor example, you could set `PIP_TARGET=./pip_deps`. cdxgen would then run `pip install -r requirements.txt --target ./pip_deps`. This installs all packages into the `./pip_deps` directory within the workspace. This is a clean and effective way to manage dependencies for analysis within an ephemeral build environment."}]}
{"messages": [{"role": "user", "content": "Is there a way to make cdxgen use a specific Java version without using the `JAVA*_TOOL` variables?"}, {"role": "assistant", "content": "While the `JAVA*_TOOL` variables are the most direct way to control the Java toolchain version within cdxgen, you can also influence the Java version by manipulating the environment in which cdxgen runs. If these variables are not set, cdxgen will likely fall back to using the `java` executable found in the system's `PATH`.\n\nTherefore, you can control the Java version by ensuring that the `bin` directory of your desired JDK installation is the first Java-related entry in your `PATH` environment variable. For example, `export JAVA_HOME=/path/to/java11` and `export PATH=\"$JAVA_HOME/bin:$PATH\"`. When cdxgen then invokes `java`, it will use the version you've prioritized in the PATH. This is a more general, system-level approach compared to the specific cdxgen variables."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use a specific settings file for all Gradle invocations?"}, {"role": "assistant", "content": "To make cdxgen use a specific settings file for all Gradle tasks it invokes, you should use the `GRADLE_ARGS` environment variable to pass the `--settings-file` argument. The arguments provided in `GRADLE_ARGS` are applied universally to all Gradle commands run by cdxgen.\n\nFor example, to use a settings file located at `/path/to/custom-settings.gradle`, you would set the environment variable as follows: `GRADLE_ARGS=\"--settings-file /path/to/custom-settings.gradle\"`. This ensures that both the `properties` task and the `dependencies` task are executed with your custom settings, which might define specific repositories or other project configurations."}]}
{"messages": [{"role": "user", "content": "What does the `CDXGEN_SERVER_ALLOWED_PATHS` variable protect against?"}, {"role": "assistant", "content": "The `CDXGEN_SERVER_ALLOWED_PATHS` environment variable is a crucial security feature when running cdxgen in server mode. It is designed to protect against path traversal or arbitrary file access attacks. Without this protection, a malicious user could craft a request to the cdxgen server asking it to scan a sensitive path on the local filesystem, such as `/etc/passwd` or `/root/.ssh/`.\n\nBy setting `CDXGEN_SERVER_ALLOWED_PATHS` to a specific directory, for example `/data/repos`, you create a sandbox for the scanner. The server will then reject any request to scan a project located outside of this whitelisted directory and its subdirectories. This ensures that the cdxgen server can only access and analyze code from intended and safe locations on the filesystem."}]}
{"messages": [{"role": "user", "content": "How can I trace cdxgen's network access to a log file for auditing?"}, {"role": "assistant", "content": "To audit the network requests that cdxgen makes, you can enable its tracing feature and direct the output to a log file. This requires using two environment variables. First, you need to enable the feature by setting `CDXGEN_TRACE_MODE` (this variable is implied by the documentation for `CDXGEN_TRACE_LOG`).\n\nSecond, you must specify the destination log file using the `CDXGEN_TRACE_LOG` variable. For example, `CDXGEN_TRACE_LOG=/var/log/cdxgen/network_audit.log`. When cdxgen runs, it will log every remote host it attempts to connect to in this file. This provides a clear audit trail that can be used for security reviews to ensure the tool is only contacting expected and approved endpoints."}]}
{"messages": [{"role": "user", "content": "In a React Native project, how can I prevent cdxgen from resolving pod dependencies from `node_modules`?"}, {"role": "assistant", "content": "In React Native projects, cdxgen's default behavior is to intelligently resolve CocoaPods dependencies that are located within the `node_modules` directory. This is controlled by the `COCOA_RESOLVE_FROM_NODE` variable, which defaults to `true`. If you need to disable this behavior for any reason, you can do so easily.\n\nTo prevent cdxgen from treating pods inside `node_modules` as Node-resolved dependencies, you simply need to set the `COCOA_RESOLVE_FROM_NODE` environment variable to `false`. When disabled, cdxgen will treat these local pods based on their path as specified in the `Podfile`, without the special `node_modules` resolution logic. This gives you more control if your project has a custom setup for managing native dependencies."}]}
{"messages": [{"role": "user", "content": "How do I specify a custom sbt home directory if it's not in the default location?"}, {"role": "assistant", "content": "The provided documentation lists `SBT_CACHE_DIR` for specifying the cache, but not a direct variable for the sbt home directory (which is typically where the `sbt` launcher script and global plugins are located). The standard way to configure this in the sbt ecosystem is by setting the `-Dsbt.global.base` Java property.\n\nWhile not listed as a cdxgen environment variable, you could potentially pass this to the underlying `sbt` command if cdxgen uses a mechanism that respects `SBT_OPTS` or a similar environment variable. However, based on the provided list, the most reliable approach would be to ensure the `sbt` command itself is configured correctly in the environment where cdxgen is run, as cdxgen likely relies on the `sbt` command to find its own home directory."}]}
{"messages": [{"role": "user", "content": "My Swift project requires specific SDK arguments. Which variable should I use?"}, {"role": "assistant", "content": "For providing SDK-specific arguments to the Swift compiler during a cdxgen scan, you should use the `SWIFT_SDK_ARGS` environment variable. This variable is intended for flags that are directly related to the SDK being used, most notably the `-sdk` flag to specify the path to a particular SDK.\n\nFor example, if you need to analyze your code against the watchOS SDK, you might set `SWIFT_SDK_ARGS=\"-sdk /path/to/watchOS.sdk\"`. This is distinct from `SWIFT_COMPILER_ARGS`, which is for the full set of compiler flags, and `SWIFT_COMPILER_EXTRA_ARGS`, which is for appending additional flags. Using `SWIFT_SDK_ARGS` makes your configuration clearer by separating out the SDK-related settings."}]}
{"messages": [{"role": "user", "content": "Can cdxgen work with a Docker daemon over TCP?"}, {"role": "assistant", "content": "Yes, cdxgen can connect to a Docker daemon that is exposed over a TCP socket. To configure this, you need to set the `DOCKER_HOST` environment variable to the TCP address of the Docker host. The format should be `tcp://<host>:<port>`.\n\nFor example, if your Docker daemon is listening on `192.168.1.50` at port `2375`, you would set `DOCKER_HOST=tcp://192.168.1.50:2375`. When this is set, cdxgen (and the underlying Docker client library it uses) will direct all its API calls to this remote daemon instead of the default local Unix socket. This is a common setup for CI/CD environments where build agents need to interact with a shared Docker host."}]}
{"messages": [{"role": "user", "content": "How can I configure `rbenv` root directory for cdxgen?"}, {"role": "assistant", "content": "If your `rbenv` installation is located in a custom directory, you need to inform cdxgen of its location so that it can correctly initialize the Ruby environment for scanning. You can do this by setting the `RBENV_ROOT` environment variable. This variable should point to the root directory of your `rbenv` installation.\n\nFor example, if you have `rbenv` installed in `~/.local/rbenv`, you would set `RBENV_ROOT=~/.local/rbenv`. This ensures that when cdxgen invokes `rbenv`, it can find the necessary shims, versions, and plugins to select the correct Ruby runtime and gems as defined by your project, leading to an accurate dependency analysis."}]}
{"messages": [{"role": "user", "content": "What is the easiest way to generate a production-only SBOM for a Gradle project?"}, {"role": "assistant", "content": "To generate an SBOM for a Gradle project that includes only production dependencies, you should focus on limiting the scope of the `gradle dependencies` task. You can do this by using the `GRADLE_ARGS_DEPENDENCIES` environment variable to specify a production-only configuration.\n\nA common production configuration in Java/Gradle projects is `runtimeClasspath`. By setting `GRADLE_ARGS_DEPENDENCIES=\"--configuration runtimeClasspath\"`, you instruct Gradle to only list the dependencies that are required at runtime. This will effectively exclude compile-time only dependencies (like annotations) and all test-related dependencies (like JUnit), resulting in a clean SBOM that accurately reflects your production artifact."}]}
{"messages": [{"role": "user", "content": "How do I ensure that cdxgen does not use the Gradle daemon?"}, {"role": "assistant", "content": "To explicitly prevent cdxgen from using the Gradle Daemon, you should set the `GRADLE_USE_DAEMON` environment variable to `false`. By default, cdxgen attempts to use the daemon for better performance, but disabling it can be useful for ensuring clean, isolated builds in CI environments.\n\nWhen you set `GRADLE_USE_DAEMON=false`, cdxgen will effectively pass the `--no-daemon` flag to every Gradle command it executes. This forces each Gradle task to run in a brand new JVM process, which is slower but guarantees that there is no shared state from previous builds that could interfere with the dependency analysis."}]}
{"messages": [{"role": "user", "content": "How can I configure cdxgen to use a specific version of the CycloneDX Maven plugin, for example version 2.7.9?"}, {"role": "assistant", "content": "To use a specific version of the CycloneDX Maven plugin, you need to set the `CDX_MAVEN_PLUGIN` environment variable. This variable should contain the full Maven coordinates of the desired plugin, including the group ID, artifact ID, and version. The default is `org.cyclonedx:cyclonedx-maven-plugin:2.9.1`.\n\nTo use version 2.7.9 instead, you would set the variable as follows: `CDX_MAVEN_PLUGIN=org.cyclonedx:cyclonedx-maven-plugin:2.7.9`. This is particularly useful if you need a feature from a newer version or need to maintain compatibility with an older version for consistency with your existing build processes. This setting is used when `PREFER_MAVEN_DEPS_TREE` is set to `false`."}]}
{"messages": [{"role": "user", "content": "How do I use a custom NVM directory with cdxgen?"}, {"role": "assistant", "content": "If you have installed NVM (Node Version Manager) in a custom location other than the default `$HOME/.nvm`, you need to tell cdxgen where to find it. You can do this by setting the `NVM_DIR` environment variable to the path of your custom NVM installation directory.\n\nFor example, if NVM is installed at `/opt/nvm`, you would set `NVM_DIR=/opt/nvm`. This allows cdxgen to correctly locate the `nvm.sh` script and initialize the NVM environment. By doing so, cdxgen can use the specific Node.js version that your project requires (as defined by a `.nvmrc` file, for instance), ensuring that the dependency analysis is performed with the correct runtime."}]}
{"messages": [{"role": "user", "content": "When scanning a Go project, is `go.mod` or `go.sum` used by default?"}, {"role": "assistant", "content": "By default, when scanning a Go project, cdxgen uses the `go.mod` file as the primary source for identifying dependencies. The `go.mod` file lists the direct dependencies and their version constraints. While this provides a good overview of the project's intended dependencies, it may not include all transitive dependencies with their exact resolved versions.\n\nFor a more complete and accurate SBOM, it is recommended to use the `go.sum` file, which contains a cryptographically verified list of all direct and indirect dependencies. To enable this behavior, you must explicitly set the `USE_GOSUM` environment variable to `true` or `1`."}]}
{"messages": [{"role": "user", "content": "How can I provide extra arguments to the `bundle update` command that cdxgen might run?"}, {"role": "assistant", "content": "If cdxgen needs to run `bundle update` during its analysis of a Ruby project, you can pass additional command-line arguments to it using the `BUNDLE_UPDATE_ARGS` environment variable. The contents of this variable will be appended to the `bundle update` command.\n\nThis can be useful for various purposes, such as targeting a specific gem or group. For example, if you wanted to force the update of gems only in the `development` group, you could potentially set `BUNDLE_UPDATE_ARGS=--group development`. This allows you to customize the update behavior to fit your project's specific needs."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use my local `.npmrc` file for private registry configuration?"}, {"role": "assistant", "content": "cdxgen functions by invoking standard package manager commands like `npm`. Therefore, it will naturally respect the configurations found in your local `.npmrc` file. The `npm` command automatically discovers and applies settings from `.npmrc` files located in the project directory, your home directory, or global locations.\n\nThis means you don't need a special cdxgen variable to use your private registry. As long as your `.npmrc` file is correctly configured with the registry URL and authentication tokens (e.g., `registry=https://my-private-registry.com/` and `//my-private-registry.com/:_authToken=\"${NPM_TOKEN}\"`), cdxgen's invocations of `npm` will use that configuration seamlessly. You can also override the registry URL for a specific run using the `NPM_URL` environment variable if needed."}]}
{"messages": [{"role": "user", "content": "I am getting a timeout error from cdxgen server. How can I increase it?"}, {"role": "assistant", "content": "If you are experiencing timeout errors while using cdxgen in server mode, it's likely because the SBOM generation for a requested repository is taking longer than the server's default timeout. You can increase this timeout period by setting the `CDXGEN_SERVER_TIMEOUT_MS` environment variable.\n\nThis variable should be set to the desired timeout value in milliseconds. For example, to set the timeout to 3 minutes (180,000 milliseconds), you would set `CDXGEN_SERVER_TIMEOUT_MS=180000` before starting the server. This will give cdxgen more time to process large or complex projects without the client's request being prematurely terminated."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen include test dependencies for a Maven project?"}, {"role": "assistant", "content": "By default, cdxgen already includes test-scoped dependencies when analyzing Maven projects. This behavior is controlled by the `CDX_MAVEN_INCLUDE_TEST_SCOPE` environment variable, which has a default value of `true`. Therefore, you don't need to do anything to include them; it's the standard behavior.\n\nIf for some reason your configuration has this disabled and you want to re-enable it, you would just need to ensure the variable is set to `true`: `CDXGEN_MAVEN_INCLUDE_TEST_SCOPE=true`. This will cause the underlying Maven command (`dependency:tree` or the CycloneDX plugin) to include dependencies with the `test` scope in its output, which will then be included in the final SBOM."}]}
{"messages": [{"role": "user", "content": "Can I use `SBOM_SIGN_PRIVATE_KEY` with an encrypted private key?"}, {"role": "assistant", "content": "The documentation for `SBOM_SIGN_PRIVATE_KEY` specifies that it takes a private key file for signing. It does not mention any built-in support for handling encrypted private keys that require a passphrase to be unlocked. The underlying signing library would need to support this, and cdxgen would need a way to accept the passphrase.\n\nGiven the absence of a corresponding `SBOM_SIGN_KEY_PASSPHRASE` variable, it is safest to assume that cdxgen expects an unencrypted private key file in PEM or a similar format. If your key is encrypted, you would need to decrypt it first and provide the decrypted key to cdxgen, either as a temporary file or preferably as a base64-encoded string via the `SBOM_SIGN_PRIVATE_KEY_BASE64` variable to avoid writing the unencrypted key to disk."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen ignore the `dist` directory during analysis?"}, {"role": "assistant", "content": "To prevent cdxgen from analyzing the contents of your `dist` directory, which typically contains build artifacts rather than source code, you should add it to the list of ignored directories for Abstract Syntax Tree (AST) generation. This is done using the `ASTGEN_IGNORE_DIRS` environment variable.\n\nThis variable takes a comma-separated list of directory names. Since this variable overrides the defaults, you should include other common directories you also want to ignore. For example: `ASTGEN_IGNORE_DIRS=venv,node_modules,build,dist`. This will improve performance and prevent irrelevant files from being parsed, leading to a more accurate and focused SBOM."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `BAZEL_TARGET` variable?"}, {"role": "assistant", "content": "The `BAZEL_TARGET` environment variable is used to specify which part of a Bazel project cdxgen should analyze. Bazel projects are often large monorepos containing many different libraries and applications, which are defined as 'targets' in `BUILD` files. By default, cdxgen will try to analyze the entire workspace by using the `:all` target, which can be inefficient.\n\nBy setting `BAZEL_TARGET`, you can tell cdxgen to focus on a single, specific target. For example, `BAZEL_TARGET=//services/my-app` would instruct cdxgen to generate an SBOM only for the `my-app` application. This results in a much faster scan and produces an SBOM that accurately represents the dependencies of that specific piece of software, which is usually what is needed for release and deployment."}]}
{"messages": [{"role": "user", "content": "How do I configure cdxgen to trust an insecure Docker registry?"}, {"role": "assistant", "content": "If you need to connect to a Docker registry that does not use TLS (i.e., it's an insecure, HTTP-only registry) or uses a self-signed certificate that you don't want to validate, you can disable TLS verification. To do this, you need to set the `DOCKER_TLS_VERIFY` environment variable to an empty value.\n\nFor example, in your shell, you would set `export DOCKER_TLS_VERIFY=`. When this variable is set to be empty, cdxgen's Docker client will not attempt to enforce or verify a TLS connection to the registry. Please note that this should only be used for trusted, internal development environments, as it makes the connection vulnerable to man-in-the-middle attacks. It is not recommended for production use."}]}
{"messages": [{"role": "user", "content": "My Ruby project has gems managed by a custom `GEM_PATH`. How do I make cdxgen find them?"}, {"role": "assistant", "content": "When analyzing Ruby projects, cdxgen needs to be able to locate all the installed gems to gather detailed metadata. If your project uses a custom `GEM_PATH` to manage its gems in a non-standard location, you need to ensure cdxgen is aware of it. cdxgen will respect the standard `GEM_PATH` environment variable if it is set in the shell where you run the command.\n\nAdditionally, cdxgen provides the `CDXGEN_GEM_HOME` variable, which can be used to explicitly point to a specific gem directory. For the best results, you should ensure that your `GEM_PATH` is correctly exported, and you can also set `CDXGEN_GEM_HOME` to the primary gem installation directory. This combination will give cdxgen the highest chance of successfully locating all the required gems for a deep and accurate scan."}]}
{"messages": [{"role": "user", "content": "Can I provide a regex to ignore files for cdxgen's AST generation?"}, {"role": "assistant", "content": "Yes, you can provide a regular expression to filter out files that you do not want to be included in the Abstract Syntax Tree (AST) generation process. This is done by setting the `ASTGEN_IGNORE_FILE_PATTERN` environment variable. The value of this variable should be a valid regex.\n\nThis is a powerful feature for excluding files based on a pattern rather than just their directory. For example, if you want to exclude all files that are generated from a protobuf definition (e.g., `*.pb.go`), you could set `ASTGEN_IGNORE_FILE_PATTERN='\\.pb\\.go$'`. This prevents cdxgen from wasting time parsing generated code and keeps the focus on your handwritten source files."}]}
{"messages": [{"role": "user", "content": "What is the recommended way to sign SBOMs in a CI/CD pipeline with cdxgen?"}, {"role": "assistant", "content": "In a CI/CD pipeline, it is often insecure and cumbersome to manage files. Therefore, the recommended way to sign SBOMs with cdxgen is to use the base64-encoded key variables. You can store your private key as a secret in your CI/CD system (e.g., GitHub Actions Secrets, GitLab CI/CD variables). Then, in your pipeline script, you expose this secret to cdxgen via the `SBOM_SIGN_PRIVATE_KEY_BASE64` environment variable.\n\nYou should also set the `SBOM_SIGN_ALGORITHM` to your desired algorithm (e.g., `ES256`). This approach avoids writing the private key to the filesystem of the build runner, which is a significant security improvement. If you also wish to embed the public key, you can provide it via `SBOM_SIGN_PUBLIC_KEY_BASE64` in the same way. This creates a secure, file-less signing workflow."}]}
{"messages": [{"role": "user", "content": "My cdxgen scan is slow. How can I speed it up by ignoring directories?"}, {"role": "assistant", "content": "A common reason for slow cdxgen scans is that the Abstract Syntax Tree (AST) generator is spending a lot of time parsing directories that don't contain relevant source code. You can significantly speed up the process by telling cdxgen to ignore these directories using the `ASTGEN_IGNORE_DIRS` environment variable.\n\nThis variable should be set to a comma-separated list of directory names to exclude. Good candidates for exclusion are directories containing build outputs (`build`, `target`, `dist`), local dependencies (`node_modules`, `vendor`), virtual environments (`venv`), and test data. For example: `ASTGEN_IGNORE_DIRS=node_modules,venv,target,build,dist,docs,test-data`. This will focus the scan on your actual source code, reducing parse time and improving overall performance."}]}
{"messages": [{"role": "user", "content": "How do I specify which Bazel rule to use for dependency resolution?"}, {"role": "assistant", "content": "The provided documentation for cdxgen's Bazel integration does not indicate a variable to specify a particular Bazel rule for dependency resolution (like `maven_jar` or `http_archive`). Instead, cdxgen's approach is to analyze the outputs of a Bazel build or query.\n\nYou control what cdxgen analyzes by setting the `BAZEL_TARGET` variable to a specific build target (e.g., `//:my-app`). cdxgen then either builds this target and analyzes the results or, if `BAZEL_USE_ACTION_GRAPH` is true, it queries the action graph for that target's dependencies. The specific rules used to define those dependencies are part of your `BUILD` files and Bazel's internal logic, which cdxgen leverages indirectly by inspecting the outcome of the build process for the specified target."}]}
{"messages": [{"role": "user", "content": "What is the default behavior of `MILL_USE_SERVER` in cdxgen?"}, {"role": "assistant", "content": "The default behavior of the `MILL_USE_SERVER` environment variable in cdxgen is to be `false`. This means that, by default, cdxgen will not attempt to use a long-running Mill server process for its analysis. Instead, each Mill command it executes will start in a new, separate JVM process.\n\nWhile this is a safe default that ensures isolation, it is less performant than using a warm server. If you are running cdxgen in an environment where performance is a concern, you can enable server usage by explicitly setting `MILL_USE_SERVER=true`. This will significantly speed up the analysis of Mill-based projects by avoiding the cold-start overhead of the JVM for each command."}]}
{"messages": [{"role": "user", "content": "How does `FETCH_LICENSE=true` affect Go projects?"}, {"role": "assistant", "content": "When you set `FETCH_LICENSE=true` for a Go project, you are instructing cdxgen to perform an extra step to enrich the generated SBOM with license information for each dependency. For every Go package identified, cdxgen will make a network request to the Go package discovery service (by default, `https://pkg.go.dev/`).\n\nThis service provides detailed metadata about Go packages, including their detected license(s). cdxgen will parse this information and embed it into the corresponding component entry in the CycloneDX SBOM. This adds crucial data for license compliance and risk management, but it comes at the cost of increased scan time and a dependency on network connectivity to the package service."}]}
{"messages": [{"role": "user", "content": "Can I use `CDXGEN_SERVER_ALLOWED_HOSTS` to restrict access by IP address?"}, {"role": "assistant", "content": "The documentation specifies that `CDXGEN_SERVER_ALLOWED_HOSTS` takes a comma-separated list of allowed *git hosts*. This strongly implies that the matching is done based on the hostname provided in the git repository URL, not on the resolved IP address. For example, you would allow `github.com`, not `140.82.121.4`.\n\nTherefore, this feature should be used with hostnames. If you need to restrict access by IP address, that level of control is typically implemented at a lower level in the network stack, such as with firewall rules (e.g., iptables, security groups) on the machine running the cdxgen server. Using a firewall would be a more robust way to enforce IP-based restrictions."}]}
{"messages": [{"role": "user", "content": "What is the best way to get a production-ready SBOM for a Ruby on Rails application?"}, {"role": "assistant", "content": "To get a production-ready SBOM for a Ruby on Rails application, you should configure Bundler to exclude development and test dependencies when cdxgen runs. This can be done with the `BUNDLE_INSTALL_ARGS` environment variable. Bundler manages dependencies in groups, and you can exclude certain groups with the `--without` flag.\n\nFor a typical Rails application, you would want to exclude the `development` and `test` groups. You can achieve this by setting the variable as follows: `BUNDLE_INSTALL_ARGS=\"--without development test\"`. When cdxgen runs `bundle install`, it will use these arguments, and the resulting dependency graph will only include the gems that are part of your production environment, leading to a clean and accurate SBOM for your deployed application."}]}
{"messages": [{"role": "user", "content": "My Swift project uses a custom path for SDKs. How can I configure this for `swift package` commands?"}, {"role": "assistant", "content": "If your Swift project requires a custom path for the Swift SDKs when resolving packages, you can provide this path to the `swift package` command invoked by cdxgen. This is done using the `SWIFT_PACKAGE_ARGS` environment variable. You would use the `--swift-sdks-path` argument.\n\nFor example, if your SDKs are located in `/opt/swift-sdks`, you would set the environment variable like this: `SWIFT_PACKAGE_ARGS=\"--swift-sdks-path /opt/swift-sdks\"`. This ensures that when cdxgen calls `swift package show-dependencies`, the Swift Package Manager knows where to look for the necessary SDKs, allowing it to resolve dependencies correctly, especially those that have system-level requirements."}]}
{"messages": [{"role": "user", "content": "Does cdxgen use the `yarn.lock` file if both it and `package-lock.json` are present?"}, {"role": "assistant", "content": "The provided documentation does not explicitly define the order of precedence for Node.js lockfiles. When multiple lockfiles like `yarn.lock` and `package-lock.json` coexist in a project, dependency analysis tools must choose one. This choice is often based on a heuristic.\n\nA common heuristic is to check for the presence of other package manager-specific configuration files (like `.yarnrc.yml` for Yarn) or to default to a specific lockfile (often `package-lock.json` due to npm's ubiquity). To get a definitive answer for your project, the best approach is to run cdxgen with `CDXGEN_DEBUG_MODE=verbose`. The 'think mode' output will likely state which lockfile was selected for analysis and why. For guaranteed predictable behavior, it is strongly recommended to only keep the single, correct lockfile for your project's chosen package manager."}]}
{"messages": [{"role": "user", "content": "How can I prevent `gradlew` from stopping the daemon after a cdxgen scan?"}, {"role": "assistant", "content": "By default, when cdxgen is configured to use the Gradle Daemon (`GRADLE_USE_DAEMON=true`), it will also automatically stop the daemon after the scan is complete (`GRADLE_STOP_DAEMON` defaults to `true`). To prevent this and keep the daemon running for subsequent pipeline steps, you need to explicitly override this behavior.\n\nYou can do this by setting the `GRADLE_STOP_DAEMON` environment variable to `false`. For example: `GRADLE_USE_DAEMON=true GRADLE_STOP_DAEMON=false ./gradlew ...`. This configuration tells cdxgen to leverage the performance benefits of the daemon for its scan but to leave the process running afterwards, which is ideal for optimizing chained Gradle commands in a CI/CD environment."}]}
{"messages": [{"role": "user", "content": "Is there a way to limit the CPU or memory resources cdxgen uses when analyzing a Docker image?"}, {"role": "assistant", "content": "The cdxgen documentation provided does not list any specific environment variables for limiting the CPU or memory resources used during a Docker image scan. cdxgen itself is a Node.js application, so you can control its memory usage with `NODE_OPTIONS=\"--max-old-space-size=...\"`.\n\nHowever, the resource consumption during the image analysis phase is largely determined by the underlying tool that inspects the image layers and the size and complexity of the image itself. If you are running cdxgen inside a container, the best way to control its total resource consumption (including the analysis phase) is to apply resource limits to the container itself. For example, with Docker, you would use the `--memory` and `--cpus` flags on the `docker run` command that executes cdxgen."}]}
{"messages": [{"role": "user", "content": "How do I specify a Java 24 toolchain for cdxgen?"}, {"role": "assistant", "content": "To configure cdxgen to use a specific Java 24 toolchain for its analysis, you need to set the `JAVA24_TOOL` environment variable. This allows you to override the default version (`24.0.2-tem`) that cdxgen has pre-configured.\n\nThis is essential if your project is built with a different patch release or a JDK from a different vendor (e.g., Oracle, Azul). You would set the variable to the desired version string, for instance, `JAVA24_TOOL=24.0.2-open`. This ensures that the dependency analysis is performed in an environment that matches your build, which is critical for accuracy and reproducibility."}]}
{"messages": [{"role": "user", "content": "I have local podspecs in Ruby format that are failing to parse. What can I do?"}, {"role": "assistant", "content": "When you have local podspecs in the Ruby-based `.podspec` format that fail to parse, it's often because they contain dynamic variables or call custom functions that are only resolved when the `Podfile` is processed. To handle this, cdxgen provides the `COCOA_PODSPEC_REPLACEMENTS` environment variable.\n\nThis variable allows you to perform on-the-fly text substitutions on the podspec files before they are fed to the parser. You can provide a comma-separated list of `find=replace` pairs. You can even use regular expressions by wrapping the 'find' pattern in slashes (`/`). This pre-processing step can fix the syntax of the podspec, allowing cdxgen to parse it successfully and continue with the dependency analysis. This is a common workaround needed for projects using frameworks like React Native."}]}
{"messages": [{"role": "user", "content": "Can cdxgen automatically detect the correct Java version for my project?"}, {"role": "assistant", "content": "The documentation does not indicate that cdxgen has a feature to automatically detect the specific Java version required by a project (e.g., by parsing `build.gradle` or `pom.xml` source compatibility settings). Instead, it provides a set of `JAVA*_TOOL` environment variables that allow you to explicitly tell cdxgen which Java toolchain to use.\n\nThis explicit configuration (`JAVA8_TOOL`, `JAVA11_TOOL`, `JAVA17_TOOL`, etc.) is a more reliable approach, as it removes ambiguity. For the most accurate results, your build pipeline should determine the correct Java version for your project and then pass that information to cdxgen by setting the appropriate `JAVA*_TOOL` variable. This ensures the dependency analysis environment perfectly matches the build environment."}]}
{"messages": [{"role": "user", "content": "How do I use a custom rbenv command with cdxgen?"}, {"role": "assistant", "content": "If you need cdxgen to use a custom `rbenv` commandfor example, a wrapper script or an executable in a non-standard pathyou can specify it using the `RBENV_CMD` environment variable. This variable overrides the default behavior of searching for `rbenv` in the system's PATH.\n\nFor example, if you have a custom script at `/usr/local/bin/custom-rbenv`, you would set `RBENV_CMD=/usr/local/bin/custom-rbenv`. cdxgen will then use this command for all its interactions with `rbenv`, such as determining the correct Ruby version and environment for the scan. This gives you full control over the `rbenv` integration."}]}
{"messages": [{"role": "user", "content": "What is the difference between `CDXGEN_ALLOWED_HOSTS` and `CDXGEN_SERVER_ALLOWED_HOSTS`?"}, {"role": "assistant", "content": "These two environment variables control network access at different levels and in different modes of operation. `CDXGEN_ALLOWED_HOSTS` is a general-purpose security feature for any cdxgen run. It restricts all outbound network requests made by cdxgen (e.g., to package registries like npm or PyPI) to a list of whitelisted hosts.\n\nOn the other hand, `CDXGEN_SERVER_ALLOWED_HOSTS` is a more specific security feature that applies only when cdxgen is running in server mode. It specifically restricts which remote *git hosts* the server is allowed to clone repositories from. This prevents a user from requesting the server to clone code from an untrusted or malicious source. While `CDXGEN_ALLOWED_HOSTS` controls access to package registries, `CDXGEN_SERVER_ALLOWED_HOSTS` controls access to source code repositories."}]}
{"messages": [{"role": "user", "content": "How does cdxgen handle credentials for private Go modules?"}, {"role": "assistant", "content": "The provided documentation for cdxgen does not list specific environment variables for Go authentication, similar to how it does for Docker. Authentication for private Go modules is typically handled by configuring the Go toolchain itself, usually through the `.gitconfig` file and the `GOPRIVATE` environment variable.\n\nWhen cdxgen invokes Go commands, it does so in the environment where it's run. Therefore, it will respect your existing Go environment configuration. To access private modules, you should ensure that your environment is correctly set up before running cdxgen. This includes setting `GOPRIVATE` to your private repository's path (e.g., `GOPRIVATE=*.mycompany.com`) and ensuring your Git client is configured with the necessary credentials (e.g., via SSH keys or HTTPS tokens in `.gitconfig`) to access those repositories."}]}
{"messages": [{"role": "user", "content": "Can I use `PREFER_MAVEN_DEPS_TREE=true` with a custom Maven command specified by `MVN_CMD`?"}, {"role": "assistant", "content": "Yes, you can absolutely use these two variables together. The `MVN_CMD` variable simply tells cdxgen which executable to run for Maven commands (e.g., `./mvnw`), while `PREFER_MAVEN_DEPS_TREE=true` tells cdxgen which Maven command to execute with that executable (specifically, the `dependency:tree` goal).\n\nWhen you set both, cdxgen will construct a command like this: `<value_of_MVN_CMD> dependency:tree ...`. For example, `MVN_CMD=./mvnw` and `PREFER_MAVEN_DEPS_TREE=true` would result in cdxgen running `./mvnw dependency:tree`. This combination is very common and is the recommended way to get a reproducible SBOM for a Maven project using the project's own wrapper script."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen use a specific Python executable?"}, {"role": "assistant", "content": "The provided documentation does not list a specific environment variable (like `PYTHON_CMD`) to set the path to a Python executable. In the absence of such a variable, cdxgen will rely on the standard system behavior of finding executables like `python`, `python3`, and `pip` in the directories listed in the `PATH` environment variable.\n\nTherefore, to make cdxgen use a specific Python executable, you should ensure that the directory containing that executable is placed at the beginning of your `PATH`. For example, if you are using a virtual environment, you would activate it first (`source .venv/bin/activate`), which prepends the virtual environment's `bin` directory to the `PATH`. cdxgen will then naturally use the `python` and `pip` from that activated environment."}]}
{"messages": [{"role": "user", "content": "I am scanning a Rust project. How can I ensure the crates.io API is used?"}, {"role": "assistant", "content": "By default, cdxgen is already configured to use the public crates.io API for fetching metadata about Rust dependencies. The `RUST_CRATES_URL` environment variable defaults to `https://crates.io/api/v1/crates/`, which is the correct endpoint for the official registry.\n\nTherefore, you do not need to set any specific environment variable to use the public crates.io. You would only need to set `RUST_CRATES_URL` if you wanted to override this default behavior and point cdxgen to a private registry or a mirror. If the variable is unset, cdxgen will correctly use crates.io."}]}
{"messages": [{"role": "user", "content": "How do I provide a full compiler argument string for a Swift project scan?"}, {"role": "assistant", "content": "If you need to provide a complete, custom set of compiler arguments for cdxgen's semantic analysis of a Swift project, you should use the `SWIFT_COMPILER_ARGS` environment variable. This variable is designed to hold the entire argument string that will be passed to the Swift compiler.\n\nThis is useful when cdxgen's auto-detection is not sufficient for your project's complex build configuration. You would set the variable to a string containing all the necessary flags, such as SDK paths, framework search paths, and any other required compiler options. For example: `SWIFT_COMPILER_ARGS=\"-sdk /path/to/iPhoneOS.sdk -F /path/to/Frameworks -target x86_64-apple-ios15.0-simulator\"`. This gives you complete control over the compiler invocation."}]}
{"messages": [{"role": "user", "content": "How do I specify a private Maven repository URL for my Java projects?"}, {"role": "assistant", "content": "To configure cdxgen to use a private or internal Maven repository for all standard Java-based scans (including Maven and Gradle), you need to set the `MAVEN_CENTRAL_URL` environment variable. This variable should be set to the URL of your repository manager (like Nexus or Artifactory) that acts as a mirror or proxy for Maven Central.\n\nFor instance, if your company's repository is at `https://repo.mycompany.com/repository/maven-public/`, you would set `MAVEN_CENTRAL_URL=https://repo.mycompany.com/repository/maven-public/`. This will direct all dependency metadata lookups from cdxgen's Java scanners to your internal repository, which is essential for security, performance, and working in controlled network environments. If you also have Android projects, you should set `ANDROID_MAVEN_URL` as well."}]}
{"messages": [{"role": "user", "content": "What is the function of `GRADLE_HOME` in cdxgen?"}, {"role": "assistant", "content": "The `GRADLE_HOME` environment variable is used to specify the location of a Gradle installation directory. When you run a `gradle` command, it needs to know where to find the Gradle libraries and other resources required for its execution. Setting `GRADLE_HOME` tells the system where this installation is located.\n\nIn the context of cdxgen, this variable is useful if you are not using the Gradle wrapper (`gradlew`) and the `gradle` command is not in your system's `PATH`. By setting `GRADLE_HOME`, you can point cdxgen to a specific Gradle distribution on your filesystem. cdxgen can then use this information to construct the correct path to the `gradle` executable (e.g., `$GRADLE_HOME/bin/gradle`), ensuring it can run the necessary dependency analysis tasks."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `DOCKER_EMAIL` environment variable?"}, {"role": "assistant", "content": "The `DOCKER_EMAIL` environment variable is part of a set of variables used to provide Docker registry credentials to cdxgen when not using a `config.json` file. While modern Docker authentication primarily relies on a username and password (or token), some older versions of the Docker registry API or certain registry implementations used an email address as part of the authentication or user identification process.\n\nAlong with `DOCKER_USER`, `DOCKER_PASSWORD`, and `DOCKER_SERVER_ADDRESS`, `DOCKER_EMAIL` can be set to provide complete authentication details. For most modern registries like Docker Hub, this field is often optional, but it is included for compatibility with a wider range of registry systems. You would typically set it to the email address associated with your registry account."}]}
{"messages": [{"role": "user", "content": "How do I run cdxgen with increased Node.js heap size?"}, {"role": "assistant", "content": "If you are encountering 'Out of Memory' errors, you need to increase the heap size available to the Node.js process running cdxgen. This is done by passing the `--max-old-space-size` option to Node.js. The easiest way to do this with cdxgen is by using the `NODE_OPTIONS` environment variable.\n\nBefore running your cdxgen command, set the `NODE_OPTIONS` variable with the desired memory limit in megabytes. For example, to set the heap size to 4GB, you would execute: `export NODE_OPTIONS=\"--max-old-space-size=4096\"`. Then, run your `cdxgen` command as usual. This new memory limit will be applied, which should resolve memory issues when scanning very large projects."}]}
{"messages": [{"role": "user", "content": "Can I use cdxgen to generate an SBOM for a specific configuration in a Gradle project?"}, {"role": "assistant", "content": "Yes, you can generate an SBOM for a specific Gradle configuration by using the `GRADLE_ARGS_DEPENDENCIES` environment variable. This variable allows you to pass arguments directly to the `gradle dependencies` task, which is what cdxgen uses to list the dependencies.\n\nThe `--configuration` flag is used to specify which configuration's dependency graph you want to see. For example, if you want to generate an SBOM for only the `compileClasspath` dependencies, you would set `GRADLE_ARGS_DEPENDENCIES=\"--configuration compileClasspath\"`. This gives you precise control over the scope of the generated SBOM, allowing you to tailor it for different purposes like runtime analysis or compile-time analysis."}]}
{"messages": [{"role": "user", "content": "My Bazel build requires special arguments. How do I provide them to cdxgen?"}, {"role": "assistant", "content": "To provide additional arguments to the Bazel command that cdxgen executes, you should use the `BAZEL_ARGS` environment variable. This variable acts as a pass-through for any command-line options that you would normally provide to Bazel yourself.\n\nFor example, if your build requires a custom configuration flag like `--config=my-ci-config`, you would set the environment variable as follows: `BAZEL_ARGS=\"--config=my-ci-config\"`. cdxgen will append these arguments to its `bazel build` or `bazel aquery` command, ensuring that your project is analyzed with the correct build settings and configuration."}]}
{"messages": [{"role": "user", "content": "How do I disable the Gradle daemon when running cdxgen in a CI pipeline?"}, {"role": "assistant", "content": "To disable the Gradle Daemon in a CI pipeline for a cdxgen scan, you should set the `GRADLE_USE_DAEMON` environment variable to `false`. This is a common practice in CI environments to ensure each build is clean and isolated, without any state being carried over by a long-running daemon process.\n\nBy setting `GRADLE_USE_DAEMON=false`, you are telling cdxgen to invoke Gradle with the `--no-daemon` flag. This will cause Gradle to start a new JVM for the scan and terminate it upon completion. While this is slower than using a warm daemon, it provides the highest level of build reproducibility and avoids potential issues with resource leakage or caching in ephemeral build environments."}]}
{"messages": [{"role": "user", "content": "What is the difference between `MAVEN_HOME` and `MVN_CMD`?"}, {"role": "assistant", "content": "These two environment variables provide different ways to control how cdxgen interacts with Maven. `MAVEN_HOME` is used to specify the installation directory of a Maven distribution. cdxgen can use this path to find the `mvn` executable (e.g., in `$MAVEN_HOME/bin/mvn`). This is useful when Maven is not in the system's `PATH`.\n\n`MVN_CMD`, on the other hand, is more direct. It specifies the exact command to execute. This is typically used to point to a specific executable, most commonly the Maven wrapper script (`./mvnw`). If you set `MVN_CMD=./mvnw`, cdxgen will run that command directly, ignoring `MAVEN_HOME` and what's in the system `PATH`. `MVN_CMD` takes precedence and is the recommended way to ensure project-specific Maven versions are used via the wrapper."}]}
{"messages": [{"role": "user", "content": "How do I configure a custom NuGet V3 API endpoint with cdxgen?"}, {"role": "assistant", "content": "To configure cdxgen to use a custom NuGet V3 API endpoint, such as one from a private feed on Azure DevOps or Artifactory, you should use the `NUGET_URL` environment variable. This variable overrides the default public NuGet API endpoint.\n\nYou should set `NUGET_URL` to the base URL for the 'RegistrationsBaseUrl' resource of your feed. This URL can typically be found by inspecting the `index.json` of your V3 feed. For example, `NUGET_URL=https://pkgs.dev.azure.com/my-org/_packaging/my-feed/nuget/v3/registrations2/`. This will direct cdxgen to query your private feed for all .NET package metadata."}]}
{"messages": [{"role": "user", "content": "My Python project has conflicting dependencies. Can I make pip ignore them during the cdxgen scan?"}, {"role": "assistant", "content": "Yes, if your Python project has dependency conflicts that are causing `pip` to fail, you can instruct it to ignore these conflicts during the installation step that cdxgen performs. To do this, you can use the `PIP_INSTALL_ARGS` environment variable to pass the `--no-warn-conflicts` flag.\n\nBy setting `PIP_INSTALL_ARGS=--no-warn-conflicts`, you tell `pip` to proceed with the installation even if it detects conflicting version requirements between packages. While this is not a solution for the underlying dependency issue in your project, it can serve as a practical workaround to allow cdxgen to complete its scan and generate an SBOM, which can then be used to help analyze and resolve the conflicts."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen use a specific private key file for signing the SBOM?"}, {"role": "assistant", "content": "To sign the generated SBOM with a specific private key from a file, you need to use the `SBOM_SIGN_PRIVATE_KEY` environment variable. The value of this variable should be the full path to your private key file.\n\nFor example, if your private key is located at `/etc/keys/sbom_signer.pem`, you would set `SBOM_SIGN_PRIVATE_KEY=/etc/keys/sbom_signer.pem`. You must also specify the signing algorithm using the `SBOM_SIGN_ALGORITHM` variable (e.g., `RS256`). When both are set, cdxgen will read the key from the specified file and use it to create a digital signature for the SBOM."}]}
{"messages": [{"role": "user", "content": "What is the simplest way to get verbose output from cdxgen for debugging?"}, {"role": "assistant", "content": "The simplest way to get verbose output from cdxgen for debugging purposes is to set the `CDXGEN_DEBUG_MODE` environment variable to `verbose`. You can do this directly on the command line when you run the tool.\n\nFor example: `CDXGEN_DEBUG_MODE=verbose cdxgen -o sbom.json`. This will enable both standard debug messages and the special 'think mode', which provides detailed insights into the tool's internal decision-making process. This is the most comprehensive level of logging available and is invaluable for troubleshooting complex issues or understanding the tool's behavior."}]}
{"messages": [{"role": "user", "content": "How does cdxgen handle a project that uses both Gradle and Node.js (like in Expo)?"}, {"role": "assistant", "content": "cdxgen is designed to handle hybrid projects that combine ecosystems like Gradle and Node.js, which is common in frameworks like Expo and React Native. It has specific environment variables to manage this interaction. By default, `GRADLE_RESOLVE_FROM_NODE` is set to `true`, which tells cdxgen to be aware that some Gradle modules might be sourced from the `node_modules` directory.\n\nThis allows cdxgen to correctly identify and trace dependencies that cross the boundary between the JavaScript and native (Android/Java) parts of your application. For example, a package installed via npm might contain an `.aar` file that becomes a Gradle dependency. cdxgen's hybrid scanning capabilities are built to understand these relationships and represent them correctly in the final SBOM."}]}
{"messages": [{"role": "user", "content": "Can I use `DOCKER_USE_CLI` to scan an image that only exists locally?"}, {"role": "assistant", "content": "Yes, that is one of the primary use cases for the `DOCKER_USE_CLI` environment variable. By default, cdxgen might try to stream the image from a remote registry. If the image you want to scan only exists on your local machine and not in a remote registry, this streaming attempt would fail.\n\nBy setting `DOCKER_USE_CLI=true`, you force cdxgen to interact with the local Docker daemon via the command-line interface. In this mode, it will first check if the image is available locally. If it finds the image, it will proceed with the scan without attempting to contact a remote registry. This makes it the perfect setting for scanning locally built or manually pulled images."}]}
{"messages": [{"role": "user", "content": "How do I exclude a specific CocoaPods target, but not its sub-targets?"}, {"role": "assistant", "content": "The documentation for `COCOA_EXCLUDED_TARGETS` states that when you exclude a target, its nested targets are also excluded. This suggests that there is no direct way to exclude a parent target while keeping its children. The logic is hierarchical.\n\nHowever, it does describe a syntax for excluding only a specific nested target: `target/subtarget/subsubtarget`. This implies that the exclusion mechanism is path-based. If you want to achieve the effect of excluding a parent but including its children, you would likely need to restructure your exclusion list. Instead of excluding the parent, you would have to leave the parent included and then explicitly list all of the parent's *other* children (the ones you want to exclude) in the `COCOA_EXCLUDED_TARGETS` variable. This inverse logic would achieve the desired result."}]}
{"messages": [{"role": "user", "content": "What is the purpose of the `CDXGEN_MAX_BUFFER` environment variable?"}, {"role": "assistant", "content": "The `CDXGEN_MAX_BUFFER` environment variable is used to control the maximum amount of memory allocated for the standard output (stdout) and standard error (stderr) buffers when cdxgen executes external commands. Many of cdxgen's scanners work by running a command-line tool (like `npm ls` or `mvn dependency:tree`) and parsing its text output.\n\nFor very large projects, the output of these commands can be huge, potentially exceeding the default buffer size of 100MB. If this happens, the cdxgen process will crash with a buffer overflow error. By setting `CDXGEN_MAX_BUFFER` to a larger value (in bytes), you can increase this limit and allow cdxgen to successfully process the large output from the underlying build tools."}]}
{"messages": [{"role": "user", "content": "How can I configure a GitHub token for cdxgen?"}, {"role": "assistant", "content": "To configure a GitHub token for cdxgen, you first need to generate a Personal Access Token (PAT) from your GitHub account's developer settings. This token will be used to authenticate requests to the GitHub API.\n\nOnce you have the token, you need to provide it to cdxgen by setting the `GITHUB_TOKEN` environment variable. For example: `export GITHUB_TOKEN=ghp_YourTokenHere`. When this variable is set, cdxgen will use it in the authorization headers for all its requests to GitHub. This prevents you from hitting the low rate limits for anonymous API requests, which is crucial for reliably scanning projects with many dependencies whose metadata is hosted on GitHub."}]}
{"messages": [{"role": "user", "content": "How can I prevent cdxgen from creating a `.cdxgen.log` file?"}, {"role": "assistant", "content": "The provided documentation lists variables like `CDXGEN_THOUGHT_LOG` and `CDXGEN_TRACE_LOG` for redirecting specific log types to files. It does not mention a variable to control the creation of a general-purpose `.cdxgen.log` file. The creation of such a file might be a default behavior for certain types of unhandled errors or warnings.\n\nTo better control logging, you should use the specific log variables. For instance, if you want all trace information to go to the console instead of a file, ensure `CDXGEN_TRACE_LOG` is not set. If you are seeing a log file and want to disable it, you could try redirecting the standard error stream of the cdxgen process to `/dev/null` (`cdxgen ... 2>/dev/null`), but this is a blunt approach that will hide all error messages. The most direct way would be to see if `CDXGEN_DEBUG_MODE=verbose` provides insight into why the file is being created."}]}
{"messages": [{"role": "user", "content": "How can I make my Mill build SBOM exclude test modules?"}, {"role": "assistant", "content": "To create an SBOM for your Mill project that excludes all test-related modules and their transitive dependencies, you need to set the `MILL_EXCLUDE_TEST` environment variable to `true`. By default, this is `false`, so test dependencies are included in the scan.\n\nBy setting `MILL_EXCLUDE_TEST=true`, you are configuring cdxgen to request a dependency graph from Mill that is representative of a production build. This will filter out any libraries and modules that are only used for testing purposes, resulting in a cleaner and more accurate SBOM for your final application artifact."}]}
{"messages": [{"role": "user", "content": "How do I ensure cdxgen uses the Maven wrapper (`mvnw`)?"}, {"role": "assistant", "content": "To ensure that cdxgen uses the Maven wrapper script (`mvnw` or `mvnw.cmd`) included with your project, you must set the `MVN_CMD` environment variable. The value should be the path to the wrapper script, which is typically `./mvnw` from the root of your project.\n\nFor example: `MVN_CMD=./mvnw cdxgen -o sbom.json`. Using the wrapper is the recommended practice because it guarantees that cdxgen will use the exact same Maven version that your project is pinned to. This eliminates a major source of potential discrepancies and leads to more reliable and reproducible SBOM generation."}]}
{"messages": [{"role": "user", "content": "How can I scan a Docker image using nerdctl with cdxgen?"}, {"role": "assistant", "content": "cdxgen is flexible and allows you to substitute the `docker` command with other container management tools like `nerdctl` (containerd CLI). To do this, you need to use the `DOCKER_CMD` environment variable. You should set its value to `nerdctl`.\n\nWhen you run cdxgen with `DOCKER_CMD=nerdctl`, it will execute `nerdctl` commands instead of `docker` commands for all container-related operations, such as pulling and inspecting images. This allows you to seamlessly integrate cdxgen into a workflow that is based on containerd and nerdctl, as long as nerdctl provides a compatible command-line interface for the actions cdxgen needs to perform."}]}
{"messages": [{"role": "user", "content": "How do I make cdxgen fetch license information for my Go and npm dependencies?"}, {"role": "assistant", "content": "To have cdxgen enrich your SBOM with license information for dependencies from both Go and npm ecosystems, you need to enable the license fetching feature. This is done by setting the `FETCH_LICENSE` environment variable to `true` or `1`.\n\nWhen `FETCH_LICENSE=true`, cdxgen will perform additional network requests to the respective package registries (`registry.npmjs.org` for npm and `pkg.go.dev` for Go) to retrieve the license data for each dependency it finds. This information will then be included in the final SBOM, which is invaluable for compliance and legal reviews. Be aware that this will slightly increase the total scan time."}]}
{"messages": [{"role": "user", "content": "How can I run cdxgen in 'think mode' and save the output to a file?"}, {"role": "assistant", "content": "To run cdxgen in its diagnostic 'think mode' and redirect the special output to a file, you need to set two environment variables. First, you must enable the mode by setting `CDXGEN_DEBUG_MODE=verbose`. This activates the detailed logging of cdxgen's internal reasoning.\n\nSecond, you need to tell cdxgen where to write the log by setting the `CDXGEN_THOUGHT_LOG` variable to your desired file path. For example: `CDXGEN_THOUGHT_LOG=./cdxgen-reasoning.log`. When you run cdxgen with both variables set, the regular output will go to the console, but the detailed 'think mode' logs will be written exclusively to the specified file for later analysis."}]}
{"messages": [{"role": "user", "content": "How do I specify a private registry for my Rust project in cdxgen?"}, {"role": "assistant", "content": "To configure cdxgen to use a private registry or a mirror for your Rust project, you need to override the default crates.io URL. This is done by setting the `RUST_CRATES_URL` environment variable. The value should be the full base URL of your registry's API endpoint for crate information.\n\nFor example, if your private registry is hosted at `https://crates.my-org.com`, and its API path is `/api/v1/crates/`, you would set `RUST_CRATES_URL=https://crates.my-org.com/api/v1/crates/`. cdxgen will then use this URL to query for metadata about the crates used in your project, allowing it to work in an environment with private or proxied dependencies."}]}
{"messages": [{"role": "user", "content": "What does setting `USE_GOSUM=true` do for Go project scans?"}, {"role": "assistant", "content": "Setting the `USE_GOSUM` environment variable to `true` changes the source of truth that cdxgen uses for dependency analysis in a Go project. Instead of relying primarily on the `go.mod` file, which lists version constraints, cdxgen will use the `go.sum` file.\n\nThe `go.sum` file contains a complete and precise list of the exact versions and cryptographic hashes of every single dependencyboth direct and transitivethat was used to build the project. Using `go.sum` therefore results in a much more accurate and high-fidelity SBOM. It guarantees that all transitive dependencies are included with their exact resolved versions, creating a reproducible and verifiable dependency graph."}]}
{"messages": [{"role": "user", "content": "How can I completely skip a failing module in my Gradle build?"}, {"role": "assistant", "content": "If you have a module in your Gradle project that is causing the cdxgen scan to fail entirely, you can completely exclude it from all analysis. To do this, you should use the `GRADLE_SKIP_MODULES` environment variable. You need to provide the Gradle name of the module, including the leading colon.\n\nFor example, if the module `:broken-legacy-module` is failing both the `properties` and `dependencies` tasks, you would set `GRADLE_SKIP_MODULES=:broken-legacy-module`. This will cause cdxgen to ignore the module completely. Be aware that this means no information about this modulenot its identity nor its dependencieswill appear in the final SBOM. This is a drastic measure but can be necessary to unblock the scan for the rest of the project."}]}
{"messages": [{"role": "user", "content": "Can cdxgen sign an SBOM with an Elliptic Curve key?"}, {"role": "assistant", "content": "Yes, cdxgen supports signing SBOMs with keys based on Elliptic Curve cryptography. To do this, you need to provide your EC private key and specify an appropriate algorithm. For example, a very common algorithm for use with EC keys is ECDSA with SHA-256, which is represented by the value `ES256`.\n\nYou would provide your key via `SBOM_SIGN_PRIVATE_KEY` (file path) or `SBOM_SIGN_PRIVATE_KEY_BASE64` (base64 string) and set the algorithm like this: `SBOM_SIGN_ALGORITHM=ES256`. This will create a valid JWS (JSON Web Signature) for your SBOM using your Elliptic Curve key, ensuring its integrity and authenticity."}]}
{"messages": [{"role": "user", "content": "I have multiple Java versions installed. How do I force cdxgen to use a specific Java 11 version?"}, {"role": "assistant", "content": "To force cdxgen to use a specific version of Java 11 for its analysis, you should set the `JAVA11_TOOL` environment variable. This variable allows you to override cdxgen's default Java 11 toolchain (`11.0.27-tem`) and point it to the exact version your project requires.\n\nFor example, if your project is built with Adoptium Temurin version `11.0.19`, you would set `JAVA11_TOOL=11.0.19-tem`. By specifying the exact toolchain, you ensure that the dependency analysis performed by cdxgen is done in an environment that is consistent with your actual build environment, which is crucial for accuracy and reproducibility of the generated SBOM."}]}
{"messages": [{"role": "user", "content": "How do I pass the `--legacy-peer-deps` flag to `npm` through cdxgen?"}, {"role": "assistant", "content": "If cdxgen needs to run `npm install` for your project and you require the `--legacy-peer-deps` flag to resolve peer dependency conflicts, you can provide this flag using the `NPM_INSTALL_ARGS` environment variable. This variable allows you to pass any additional arguments directly to the `npm install` command.\n\nTo use the flag, simply set the variable before running cdxgen: `export NPM_INSTALL_ARGS=--legacy-peer-deps`. cdxgen will then execute a command similar to `npm install --legacy-peer-deps`, which should allow the installation to succeed in projects with older dependency structures, enabling cdxgen to build an accurate dependency tree for the SBOM."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen use a custom `clojure` command?"}, {"role": "assistant", "content": "To make cdxgen use a custom `clojure` command, such as a wrapper script or an alias, you need to set the `CLJ_CMD` environment variable. This variable's value will be used as the executable name for all Clojure-related operations.\n\nFor example, if your project uses the `lein` build tool and you have a way to make it behave like the `clojure` CLI for dependencies, you could set `CLJ_CMD=lein`. More commonly, you might have a script that sets up some environment before running the real `clojure` command: `CLJ_CMD=/path/to/my/clojure_wrapper.sh`. This provides the flexibility to integrate cdxgen with any custom Clojure toolchain."}]}
{"messages": [{"role": "user", "content": "My cdxgen run is failing on a Cocoa project on a Linux CI server. What could be wrong?"}, {"role": "assistant", "content": "The most likely reason for a cdxgen scan of a Cocoa project to fail on a Linux server is that it's attempting a full scan, which requires the CocoaPods command-line tool (`pod`). The `pod` tool is written in Ruby and has dependencies on macOS-specific components, so it cannot run on Linux. This attempt will time out or fail.\n\nTo fix this, you must run cdxgen in a shallow scan mode, which does not require the `pod` tool. You can enable this by setting the `COCOA_FULL_SCAN` environment variable to `false` or `0`. In this mode, cdxgen will only parse the `Podfile.lock` to get basic dependency information, a process that can run on any operating system. This is the intended way to perform Cocoa scans in non-macOS environments."}]}
{"messages": [{"role": "user", "content": "How do I add an extra argument to the Swift compiler flags that cdxgen detects?"}, {"role": "assistant", "content": "If you need to add one or more arguments to the Swift compiler flags that cdxgen auto-detects, without replacing the entire set of flags, you should use the `SWIFT_COMPILER_EXTRA_ARGS` environment variable. This variable is designed specifically for appending arguments.\n\nFor example, if you want to add the `-track-system-dependencies` flag to the existing configuration, you would set `SWIFT_COMPILER_EXTRA_ARGS=\"-track-system-dependencies\"`. cdxgen will then combine its auto-detected flags with the ones you provided in this variable. This is much more convenient than using `SWIFT_COMPILER_ARGS`, which would require you to supply the complete list of all required arguments yourself."}]}
{"messages": [{"role": "user", "content": "What is the role of `BAZEL_STRIP_MAVEN_PREFIX`?"}, {"role": "assistant", "content": "The `BAZEL_STRIP_MAVEN_PREFIX` environment variable is used by the Bazel scanner to correctly parse Maven coordinates from dependencies that are hosted in a private repository. Often, private repositories serve artifacts with a path prefix that is not part of the official Maven group ID, such as `/maven2/` or `/artifactory/libs-release/`.\n\nThis variable tells cdxgen to remove that specific prefix from the path before trying to determine the group ID. By default, it's set to `/maven2/`. If your repository has a different structure, you can change this variable to match your prefix. This ensures that a dependency like `https://myrepo/maven2/com/google/guava/guava/30.0-jre` is correctly identified with the group ID `com.google.guava` instead of `maven2.com.google.guava`."}]}
{"messages": [{"role": "user", "content": "How can I provide Docker credentials to cdxgen as a single base64 encoded JSON?"}, {"role": "assistant", "content": "For securely providing Docker credentials in automated environments, cdxgen supports the `DOCKER_AUTH_CONFIG` environment variable. This variable takes a single base64-encoded JSON object that contains all the necessary authentication details.\n\nThe JSON object should have keys for `username`, `password`, `email`, and `serveraddress`. You would create this JSON object, then use a tool to base64 encode the entire string. The resulting base64 string is then set as the value for `DOCKER_AUTH_CONFIG`. This method is particularly useful in CI/CD systems where you can store the entire encoded string as a single secret."}]}
{"messages": [{"role": "user", "content": "Can cdxgen resolve dependencies from a Gradle module that is sourced from `node_modules`?"}, {"role": "assistant", "content": "Yes, cdxgen has built-in support for the hybrid project structures commonly found in frameworks like React Native and Expo, where native Android dependencies are managed as npm packages and reside in the `node_modules` directory. This feature is controlled by the `GRADLE_RESOLVE_FROM_NODE` environment variable.\n\nBy default, `GRADLE_RESOLVE_FROM_NODE` is set to `true`, which enables this special resolution logic. cdxgen will identify when a Gradle module's path points into `node_modules` and will analyze it as part of the Gradle build. This allows it to correctly capture the native dependencies that are brought in via your JavaScript package manager, ensuring they are included in the final SBOM."}]}
{"messages": [{"role": "user", "content": "I need to pass a profile and a settings file to Maven. How do I do this with cdxgen?"}, {"role": "assistant", "content": "To pass multiple custom arguments like a profile and a settings file to the Maven command executed by cdxgen, you should use the `MVN_ARGS` environment variable. This variable can hold a string containing all the additional command-line options you need.\n\nFor example, to activate a profile named `ci` and use a settings file at `/etc/maven/ci-settings.xml`, you would set the variable as follows: `MVN_ARGS=\"-P ci --settings /etc/maven/ci-settings.xml\"`. cdxgen will append this entire string to its `mvn` invocation, ensuring your build is configured exactly as required for the dependency analysis."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen use my project's Python virtual environment?"}, {"role": "assistant", "content": "cdxgen will automatically use your project's Python virtual environment if you activate it in your shell before running the `cdxgen` command. When you activate a virtual environment (e.g., `source .venv/bin/activate`), it modifies your shell's `PATH` to prioritize the Python executable and `pip` command from within that environment.\n\nSince cdxgen invokes `python` and `pip` as external commands, it will respect the `PATH` and thus use the versions from your activated virtual environment. This is the standard and recommended way to work with project-specific Python dependencies, and no special cdxgen configuration is needed. This ensures that the SBOM is generated based on the exact set of packages installed in your project's isolated environment."}]}
{"messages": [{"role": "user", "content": "How do I specify a custom `GEM_HOME` for a deep scan of Ruby gems?"}, {"role": "assistant", "content": "For a deep scan of Ruby gems, where cdxgen inspects the installed gems to gather detailed information, you can specify a custom `GEM_HOME` directory by using the `CDXGEN_GEM_HOME` environment variable. This is important if your project's gems are installed in a location other than the system default.\n\nBy setting `CDXGEN_GEM_HOME=/path/to/my/project/gems`, you tell cdxgen exactly where to look for the gems' specifications and files. This can be used in conjunction with the standard `GEM_PATH` variable to increase the likelihood that cdxgen can find all necessary components for an accurate scan. This is particularly useful for projects that use Bundler's `--path` option to vendor gems."}]}
{"messages": [{"role": "user", "content": "How can I make cdxgen generate an SBOM for a specific Bazel target using the action graph?"}, {"role": "assistant", "content": "To generate a highly accurate SBOM for a specific Bazel target using its action graph, you need to set two environment variables. First, you must enable the action graph query method by setting `BAZEL_USE_ACTION_GRAPH=true`. This tells cdxgen to use `bazel aquery` instead of a standard build.\n\nSecond, you must specify which target you want to query by setting the `BAZEL_TARGET` variable. For example, `BAZEL_TARGET=//java/com/mycompany:my-app-binary`. When both are set, cdxgen will execute a query to find all `.jar` file outputs that are dependencies of that specific target, resulting in a very precise dependency list for that particular artifact."}]}
{"messages": [{"role": "user", "content": "My private Docker registry requires TLS client certificates. How can I configure cdxgen for this?"}, {"role": "assistant", "content": "To connect to a Docker registry that requires TLS client certificate authentication, you need to provide the necessary certificate files to cdxgen. This is done using the `DOCKER_CERT_PATH` environment variable. This variable should be set to the path of a directory that contains your client certificate (`cert.pem`) and private key (`key.pem`).\n\nFor example, if your certificates are in `~/.docker/certs/`, you would set `DOCKER_CERT_PATH=~/.docker/certs/`. cdxgen's Docker client will then use these files to authenticate its TLS connection to the registry specified by `DOCKER_HOST` or `DOCKER_SERVER_ADDRESS`. This allows cdxgen to pull images from highly secure registries that use mutual TLS (mTLS) for authentication."}]}
{"messages": [{"role": "user", "content": "What is the best way to get a production SBOM for a Node.js project?"}, {"role": "assistant", "content": "To generate an SBOM that reflects only the production dependencies of a Node.js project, you should ensure that the dependency analysis tool is invoked in a 'production' mode. When cdxgen runs `npm install` or `npm ls`, these commands can be modified with a `--production` flag (or by setting the `NODE_ENV=production` environment variable).\n\nWhile not explicitly listed as a cdxgen variable, you can often achieve this by using `NPM_INSTALL_ARGS`. For example, setting `NPM_INSTALL_ARGS=--production` might instruct cdxgen to run `npm install --production`. The most reliable method, however, is to run `npm install --production` yourself before the scan, so that the `node_modules` directory only contains production dependencies. cdxgen will then analyze this directory, resulting in a production-only SBOM."}]}
{"messages": [{"role": "user", "content": "Can I prevent cdxgen from contacting `search.maven.org`?"}, {"role": "assistant", "content": "Yes, you can prevent cdxgen from making fallback search requests to `search.maven.org`. This feature is used when cdxgen finds a JAR file with missing or incomplete Maven metadata. To disable it, you need to set the `SEARCH_MAVEN_ORG` environment variable to `false` or `0`.\n\nDisabling this is highly recommended for builds running in offline or air-gapped environments, as it will prevent failed network requests and potential build delays. It's also a good practice if you want to enforce a policy where all dependencies must be correctly defined in your primary Maven repository, which should be configured using the `MAVEN_CENTRAL_URL` variable."}]}
{"messages": [{"role": "user", "content": "How do I specify a Java 23 toolchain version for cdxgen?"}, {"role": "assistant", "content": "To specify a particular version of the Java 23 toolchain for cdxgen to use during its analysis, you should set the `JAVA23_TOOL` environment variable. This allows you to override the default version that cdxgen is configured with, which is `23.0.2-tem`.\n\nThis is important for ensuring that the SBOM is generated using the exact same JDK that your project is built with, which helps guarantee consistency and accuracy. For example, if you are using a specific build from Oracle, you might set `JAVA23_TOOL=23.0.1-oracle`. cdxgen will then use this specified toolchain for any Java-related scanning tasks."}]}
{"messages": [{"role": "user", "content": "How do I use a custom `rbenv` installation path with cdxgen?"}, {"role": "assistant", "content": "If you have `rbenv` installed in a non-standard location (i.e., not in the default directory in your user's home), you need to tell cdxgen where to find it. This is done by setting the `RBENV_ROOT` environment variable. The value of this variable should be the absolute path to your `rbenv` installation's root directory.\n\nFor example, if you installed `rbenv` to `/opt/rbenv`, you would set `RBENV_ROOT=/opt/rbenv`. This allows cdxgen to correctly locate and initialize the `rbenv` environment, so it can use the appropriate Ruby version and gems as specified by your project for the dependency scan."}]}
{"messages": [{"role": "user", "content": "What happens if I set `GRADLE_MULTI_PROJECT_MODE`?"}, {"role": "assistant", "content": "According to the provided documentation, the `GRADLE_MULTI_PROJECT_MODE` environment variable is now unused. The documentation explicitly states that multi-project builds are 'Automatically handled'.\n\nThis means that cdxgen has evolved to a point where it can automatically detect whether it is being run against a single-project or multi-project Gradle build. It will then adjust its scanning strategy accordingly without requiring any manual configuration from the user. Therefore, setting this variable will have no effect on the behavior of modern versions of cdxgen."}]}
{"messages": [{"role": "user", "content": "Can I use `SBOM_SIGN_ALGORITHM=PS256` for signing?"}, {"role": "assistant", "content": "Yes, `PS256` is listed as a valid value for the `SBOM_SIGN_ALGORITHM` environment variable. `PS256` refers to the RSASSA-PSS signature algorithm using SHA-256 as the hash function. This is a modern and secure signature scheme based on the RSA cryptosystem.\n\nTo use it, you would provide an RSA private key via `SBOM_SIGN_PRIVATE_KEY` or `SBOM_SIGN_PRIVATE_KEY_BASE64`, and set `SBOM_SIGN_ALGORITHM=PS256`. This will produce an SBOM with a JWS signature that can be verified by any system that supports the RSASSA-PSS standard, offering strong guarantees of the SBOM's integrity and authenticity."}]}
{"messages": [{"role": "user", "content": "How do I specify a proxy for cdxgen to use?"}, {"role": "assistant", "content": "cdxgen respects the standard de-facto environment variables for HTTP/HTTPS proxy configuration. To specify a proxy, you should set the `HTTP_PROXY` and `HTTPS_PROXY` variables in your shell before running the command. The format for these variables is typically `http://[user:password@]proxy-host:port`.\n\nFor example:\n`export HTTP_PROXY=http://proxy.mycompany.com:8080`\n`export HTTPS_PROXY=http://proxy.mycompany.com:8080`\nIf there are certain domains you do not want to go through the proxy (like internal servers), you can list them in the `NO_PROXY` environment variable. cdxgen's underlying HTTP agent will automatically pick up and use these settings for all its outbound network requests."}]}
{"messages": [{"role": "user", "content": "How do I limit cdxgen to only scan a specific included build in my Gradle project?"}, {"role": "assistant", "content": "To limit cdxgen's scan to a specific included build within your Gradle composite build, you should use the `GRADLE_INCLUDED_BUILDS` environment variable. While this variable is typically used to ensure certain builds are included, you can use it to create an explicit allowlist.\n\nIf you set this variable to the name of a single included build, for example, `GRADLE_INCLUDED_BUILDS=my-api-library`, cdxgen will focus its scan on that build. The documentation notes that cdxgen will scan these builds *on top of* the modules in your main project, so the behavior may depend on your project structure. For full isolation, you might also need to use `GRADLE_SKIP_MODULES` to exclude modules from the root project, effectively forcing the scan to only consider the specified included build."}]}
{"messages": [{"role": "user", "content": "My Swift analysis is failing due to missing compiler arguments. How can I fix this?"}, {"role": "assistant", "content": "If a Swift analysis is failing because of missing compiler arguments, it means cdxgen's semantic analysis phase cannot correctly parse your code without the same context your build process uses. To fix this, you need to provide the necessary arguments using the Swift-related environment variables.\n\nYour first step should be to try and identify the required flags from your Xcode build logs. A good starting point is to provide the SDK path and target using `SWIFT_COMPILER_ARGS`, for example: `SWIFT_COMPILER_ARGS=\"-sdk <path> -target <target>\"`. You may also need to provide framework search paths (`-F <path>`) or import paths (`-I <path>`). If you only need to add a few flags to what cdxgen auto-detects, `SWIFT_COMPILER_EXTRA_ARGS` is a better choice. Providing the correct build environment context is key to a successful scan."}]}
{"messages": [{"role": "user", "content": "How do I enable debug messages in cdxgen?"}, {"role": "assistant", "content": "Set the environment variable CDXGEN_DEBUG_MODE to debug."}]}
{"messages": [{"role": "user", "content": "How do I pass additional options to the node runtime dynamically?"}, {"role": "assistant", "content": "Use the CDXGEN_NODE_OPTIONS environment variable to pass additional NODE_OPTIONS."}]}
{"messages": [{"role": "user", "content": "How can I specify a GitHub token to prevent traffic shaping?"}, {"role": "assistant", "content": "Set the GITHUB_TOKEN environment variable to your GitHub token."}]}
{"messages": [{"role": "user", "content": "How can I override the maven command?"}, {"role": "assistant", "content": "Set the MVN_CMD environment variable to the desired command."}]}
{"messages": [{"role": "user", "content": "How can I pass additional arguments to maven, such as a profile or settings file?"}, {"role": "assistant", "content": "Set the MVN_ARGS environment variable with the additional arguments."}]}
{"messages": [{"role": "user", "content": "How do I specify the Maven home directory?"}, {"role": "assistant", "content": "Set the MAVEN_HOME environment variable to the Maven home directory."}]}
{"messages": [{"role": "user", "content": "How do I force cdxgen to use the cyclonedx-maven-plugin rather than maven dependency:tree?"}, {"role": "assistant", "content": "Set the PREFER_MAVEN_DEPS_TREE environment variable to false."}]}
{"messages": [{"role": "user", "content": "How do I specify the URL of Maven Central for metadata fetching?"}, {"role": "assistant", "content": "Set the MAVEN_CENTRAL_URL environment variable to the URL of Maven Central."}]}
{"messages": [{"role": "user", "content": "How do I specify the URL of the Android Maven Repository for metadata fetching?"}, {"role": "assistant", "content": "Set the ANDROID_MAVEN_URL environment variable to the URL of the Android Maven Repository."}]}
{"messages": [{"role": "user", "content": "How do I provide additional arguments for the Bazel command?"}, {"role": "assistant", "content": "Set the BAZEL_ARGS environment variable with the additional arguments."}]}
{"messages": [{"role": "user", "content": "How can I specify a Bazel target to build?"}, {"role": "assistant", "content": "Set the BAZEL_TARGET environment variable. The default is :all."}]}
{"messages": [{"role": "user", "content": "How do I strip a Maven group prefix from Bazel dependencies?"}, {"role": "assistant", "content": "Set the BAZEL_STRIP_MAVEN_PREFIX environment variable to the prefix you want to strip (e.g., /maven2/)."}]}
{"messages": [{"role": "user", "content": "How to use action graph to get SBOM for specific Bazel target?"}, {"role": "assistant", "content": "Set the BAZEL_USE_ACTION_GRAPH to true. Also ensure that the BAZEL_TARGET is set to specific bazel target."}]}
{"messages": [{"role": "user", "content": "How do I specify the Gradle cache directory?"}, {"role": "assistant", "content": "Set the GRADLE_CACHE_DIR environment variable to the Gradle cache directory."}]}
{"messages": [{"role": "user", "content": "How do I pass additional arguments to Gradle (all tasks)?"}, {"role": "assistant", "content": "Set the GRADLE_ARGS environment variable with the additional arguments."}]}
{"messages": [{"role": "user", "content": "How do I pass arguments only to the gradle properties task?"}, {"role": "assistant", "content": "Set the GRADLE_ARGS_PROPERTIES environment variable with the additional arguments."}]}
{"messages": [{"role": "user", "content": "How do I pass arguments only to the gradle dependencies task?"}, {"role": "assistant", "content": "Set the GRADLE_ARGS_DEPENDENCIES environment variable with the additional arguments."}]}
{"messages": [{"role": "user", "content": "How can I override the gradle command?"}, {"role": "assistant", "content": "Set the GRADLE_CMD environment variable to the desired command."}]}
{"messages": [{"role": "user", "content": "How do I specify the Gradle home directory?"}, {"role": "assistant", "content": "Set the GRADLE_HOME environment variable to the Gradle home directory."}]}
{"messages": [{"role": "user", "content": "How can I override the task name used to collect packages in Gradle?"}, {"role": "assistant", "content": "Set the GRADLE_DEPENDENCY_TASK environment variable to override the default task name 'dependencies'."}]}
{"messages": [{"role": "user", "content": "How do I specify includedBuilds Gradle modules that should be scanned?"}, {"role": "assistant", "content": "Set GRADLE_INCLUDED_BUILDS to a comma-separated list of modules (e.g., :module1,:module2). Use gradle-conventions for names."}]}
{"messages": [{"role": "user", "content": "How do I handle Gradle modules included from Node.js?"}, {"role": "assistant", "content": "Set GRADLE_RESOLVE_FROM_NODE to true to use npm packages as dependencies for better purl generation."}]}
{"messages": [{"role": "user", "content": "How do I skip modules during the Gradle dependencies task?"}, {"role": "assistant", "content": "Set GRADLE_SKIP_MODULE_DEPENDENCIES to a comma-separated list of modules to skip, using their Gradle names (e.g., :module1,:module2). Use \"root\" to skip the top module."}]}
{"messages": [{"role": "user", "content": "How do I skip modules for both properties and dependencies tasks in Gradle?"}, {"role": "assistant", "content": "Set GRADLE_SKIP_MODULES to a comma-separated list of modules to skip. Note: Using this will prevent the ID and dependencies of these modules from being available."}]}
{"messages": [{"role": "user", "content": "How do I specify the directory for the Gradle user home?"}, {"role": "assistant", "content": "Set the GRADLE_USER_HOME environment variable."}]}
{"messages": [{"role": "user", "content": "How do I specify the SBT cache directory?"}, {"role": "assistant", "content": "Set the SBT_CACHE_DIR environment variable to the SBT cache directory."}]}
{"messages": [{"role": "user", "content": "How do I fetch license information from the registry?"}, {"role": "assistant", "content": "Set the FETCH_LICENSE environment variable to true or 1."}]}
{"messages": [{"role": "user", "content": "How do I disable the search on search.maven.org for missing Maven metadata?"}, {"role": "assistant", "content": "Set the SEARCH_MAVEN_ORG environment variable to false or 0."}]}
{"messages": [{"role": "user", "content": "How do I generate BOMs for golang projects using go.sum instead of go.mod?"}, {"role": "assistant", "content": "Set the USE_GOSUM environment variable to true or 1."}]}
{"messages": [{"role": "user", "content": "How do I change the default timeout for maven, gradle or sbt?"}, {"role": "assistant", "content": "Set the CDXGEN_TIMEOUT_MS."}]}
{"messages": [{"role": "user", "content": "How can I increase buffer size for stdout and stderr?"}, {"role": "assistant", "content": "Set the CDXGEN_MAX_BUFFER environment variable. Defaults to 100MB."}]}
{"messages": [{"role": "user", "content": "How do I change the timeout value for the server mode?"}, {"role": "assistant", "content": "Set the CDXGEN_SERVER_TIMEOUT_MS environment variable."}]}
{"messages": [{"role": "user", "content": "How do I specify the clojure CLI command?"}, {"role": "assistant", "content": "Set the CLJ_CMD environment variable."}]}
{"messages": [{"role": "user", "content": "How do I specify the leiningen command?"}, {"role": "assistant", "content": "Set the LEIN_CMD environment variable."}]}
{"messages": [{"role": "user", "content": "How do I configure BOM signing?"}, {"role": "assistant", "content": "Set the SBOM_SIGN_ALGORITHM to a signature algorithm, SBOM_SIGN_PRIVATE_KEY to the private key and optionally, SBOM_SIGN_PUBLIC_KEY to include the public key in the SBOM signature."}]}
{"messages": [{"role": "user", "content": "How do I configure the CycloneDX Maven plugin?"}, {"role": "assistant", "content": "Set CDX_MAVEN_PLUGIN and CDX_MAVEN_GOAL to the desired plugin and goal. CDX_MAVEN_INCLUDE_TEST_SCOPE controls whether test scoped dependencies are included."}]}
{"messages": [{"role": "user", "content": "How do I specify directories to ignore during babel analysis?"}, {"role": "assistant", "content": "Set the ASTGEN_IGNORE_DIRS environment variable to a comma-separated list of directories. This variable is also used by atom and astgen."}]}
{"messages": [{"role": "user", "content": "How to set ignore regex pattern when parsing AST?"}, {"role": "assistant", "content": "The variable ASTGEN_IGNORE_FILE_PATTERN can be used to pass ignore regex to use."}]}
{"messages": [{"role": "user", "content": "How do I override the default PyPi URL?"}, {"role": "assistant", "content": "Set the PYPI_URL environment variable."}]}
{"messages": [{"role": "user", "content": "How do I override the default NPM registry URL?"}, {"role": "assistant", "content": "Set the NPM_URL environment variable."}]}
{"messages": [{"role": "user", "content": "How do I override the default Go pkg URL?"}, {"role": "assistant", "content": "Set the GO_PKG_URL environment variable."}]}
{"messages": [{"role": "user", "content": "How do I override the default Rust Crates URL?"}, {"role": "assistant", "content": "Set the RUST_CRATES_URL environment variable."}]}
{"messages": [{"role": "user", "content": "How do I override the default NuGet URL?"}, {"role": "assistant", "content": "Set the NUGET_URL environment variable to URL from registration hive \"RegistrationsBaseUrl/3.6.0\" at NuGet V3 API (https://api.nuget.org/v3/index.json)."}]}
{"messages": [{"role": "user", "content": "How do I specify an alternative path to the .docker directory?"}, {"role": "assistant", "content": "Set the DOCKER_CONFIG environment variable to the alternative path."}]}
{"messages": [{"role": "user", "content": "How can I perform docker login prior to invoking cdxgen?"}, {"role": "assistant", "content": "Set the DOCKER_AUTH_CONFIG environment variable to a Base64 encoded JSON with credentials, or set DOCKER_USER, DOCKER_PASSWORD, DOCKER_EMAIL, and DOCKER_SERVER_ADDRESS."}]}
{"messages": [{"role": "user", "content": "How do I override docker command?"}, {"role": "assistant", "content": "Set DOCKER_CMD with desired docker command."}]}
{"messages": [{"role": "user", "content": "How can I use docker with tcp or ssh hosts?"}, {"role": "assistant", "content": "Set DOCKER_HOST variable. docker cli would be used to pull the image."}]}
{"messages": [{"role": "user", "content": "How do I specify a directory for the certs for insecure registries with docker?"}, {"role": "assistant", "content": "Set the DOCKER_CERT_PATH environment variable to the path containing cert.pem and key.pem."}]}
{"messages": [{"role": "user", "content": "How do I disable TLS verification for insecure registries with docker?"}, {"role": "assistant", "content": "Set DOCKER_TLS_VERIFY to an empty value."}]}
{"messages": [{"role": "user", "content": "How can I increase the node heap size?"}, {"role": "assistant", "content": "Set the NODE_OPTIONS environment variable (e.g., --max-old-space-size=8192)."}]}
{"messages": [{"role": "user", "content": "How do I pass arguments to the npm install command?"}, {"role": "assistant", "content": "Set the NPM_INSTALL_ARGS environment variable (e.g., --package-lock, --legacy-peer-deps)."}]}
{"messages": [{"role": "user", "content": "How do I limit the automatic npm install count?"}, {"role": "assistant", "content": "Set the NPM_INSTALL_COUNT environment variable. Default is 2."}]}
{"messages": [{"role": "user", "content": "How do I specify the compiler arguments to Swift semantic analysis?"}, {"role": "assistant", "content": "Set the SWIFT_COMPILER_ARGS environment variable to the full compiler arguments string (e.g., -sdk <path> -F <path> -Xcc -I <path>). You can also use SWIFT_SDK_ARGS and SWIFT_COMPILER_EXTRA_ARGS."}]}
{"messages": [{"role": "user", "content": "How do I fetch vcs url from pkg.go.dev for golang?"}, {"role": "assistant", "content": "Set the GO_FETCH_VCS to true or 1."}]}
{"messages": [{"role": "user", "content": "How do I specify the namespace for HTTP_PROXY variable usage?"}, {"role": "assistant", "content": "Use GLOBAL_AGENT_ENVIRONMENT_VARIABLE_NAMESPACE variable."}]}
{"messages": [{"role": "user", "content": "How do I choose java tool version?"}, {"role": "assistant", "content": "Use variables JAVA8_TOOL, JAVA11_TOOL, JAVA17_TOOL, JAVA21_TOOL, JAVA22_TOOL, JAVA23_TOOL or JAVA24_TOOL to set desired version."}]}
{"messages": [{"role": "user", "content": "How do I define where cdxgen plugins are stored?"}, {"role": "assistant", "content": "Use variable CDXGEN_PLUGINS_DIR. If not set, a global node_modules path is used."}]}
{"messages": [{"role": "user", "content": "How can I override global node modules path?"}, {"role": "assistant", "content": "Set GLOBAL_NODE_MODULES_PATH to the path of the global node_modules directory."}]}
{"messages": [{"role": "user", "content": "How do I ignore directories when creating AST?"}, {"role": "assistant", "content": "Set ASTGEN_IGNORE_DIRS to a comma-separated list of directories to ignore. Example: venv."}]}
{"messages": [{"role": "user", "content": "How do I indicate that the process is running inside a containerized environment?"}, {"role": "assistant", "content": "Set CDXGEN_IN_CONTAINER to true."}]}
{"messages": [{"role": "user", "content": "How can I pass arguments to pip install?"}, {"role": "assistant", "content": "Use PIP_INSTALL_ARGS to pass arguments to pip install (eg. --no-warn-conflicts)."}]}
{"messages": [{"role": "user", "content": "How do I specify a target directory for pip installations?"}, {"role": "assistant", "content": "Set PIP_TARGET to the desired target directory."}]}
{"messages": [{"role": "user", "content": "How do I disable canonical terminal settings for Node.js?"}, {"role": "assistant", "content": "Set NODE_NO_READLINE to 1 to disable it."}]}
{"messages": [{"role": "user", "content": "How do I specify the path to save REPL command history?"}, {"role": "assistant", "content": "Set the CDXGEN_REPL_HISTORY environment variable to the desired path."}]}
{"messages": [{"role": "user", "content": "How do I specify the SDKMAN version?"}, {"role": "assistant", "content": "Set the SDKMAN_VERSION environment variable."}]}
{"messages": [{"role": "user", "content": "How do I define the directory of NVM (Node Version Manager)?"}, {"role": "assistant", "content": "Use the NVM_DIR environment variable."}]}
{"messages": [{"role": "user", "content": "How do I define custom RBENV_CMD to use"}, {"role": "assistant", "content": "Set RBENV_CMD with rbenv command to use."}]}
{"messages": [{"role": "user", "content": "How do I set the rbenv root directory for custom rbenv installations?"}, {"role": "assistant", "content": "Use RBENV_ROOT environment variable for setting rbenv root directory."}]}
{"messages": [{"role": "user", "content": "How do I pass additional arguments to bundle install command?"}, {"role": "assistant", "content": "Use BUNDLE_INSTALL_ARGS. Example: --redownload or --without=test."}]}
{"messages": [{"role": "user", "content": "How do I pass additional arguments to bundle update command?"}, {"role": "assistant", "content": "Use BUNDLE_UPDATE_ARGS environment variable."}]}
{"messages": [{"role": "user", "content": "How do I customize the GEM_HOME directory to use, while collecting the module names for all the gems in deep mode?"}, {"role": "assistant", "content": "Use the CDXGEN_GEM_HOME environment variable. This could be different from the system gems directory too. Can be used in addition to GEM_PATH environment variable too to improve the success rate."}]}
{"messages": [{"role": "user", "content": "How do I specify temporary directory for storing intermediate files during SBOM generation?"}, {"role": "assistant", "content": "Use the CDXGEN_TEMP_DIR environment variable."}]}
{"messages": [{"role": "user", "content": "How do I disable using the cache option for the HTTP request agent?"}, {"role": "assistant", "content": "Set the CDXGEN_NO_CACHE environment variable to `true` or `1`."}]}